{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EasyDeL \ud83d\udd2e","text":"<p>EasyDeL, an open-source library, is specifically designed to enhance and streamline the training process of machine learning models. It focuses primarily on Jax/Flax and aims to provide convenient and effective solutions for training Flax/Jax Models on TPU/GPU for both Serving and Training purposes. Additionally, EasyDeL will support mojo and will be rewritten for mojo as well.</p> <p>Some of the key features provided by EasyDeL include:</p> <ul> <li>Support for 8, 6, and 4 BIT inference and training in JAX</li> <li>Wide Range of models in Jax are supported which have never been implemented before such as falcon, Qwen2, Phi2,   MPT ...</li> <li>Integration of flashAttention in JAX for GPUs and TPUs</li> <li>Automatic serving of LLMs with mid and high-level APIs in both JAX and PyTorch</li> <li>LLM Trainer and fine-tuner in JAX</li> <li>RLHF (Reinforcement Learning from Human Feedback) in Jax (Beta Stage)</li> <li>And various other features to enhance the training process and optimize performance.</li> <li>LoRA: Low-Rank Adaptation of Large Language Models</li> </ul> <p>These features collectively aim to simplify and accelerate the training of machine learning models, making it more efficient and accessible for developers working with Jax/Flax.</p> <p>FlashAttention and Splash Attention are currently disabled for Falcon, MPT, PHI and GPTJ</p>"},{"location":"#what-makes-easydel-special","title":"What Makes EasyDeL \ud83d\udd2e Special","text":"<p>EasyDeL is built up on JAX and Flax and that's why EasyDeL can perform as fast and as easy as possible</p> <p>When comparing JAX to PyTorch and TensorFlow, there are several benefits to using JAX that are worth considering.</p> <ol> <li> <p>Performance: JAX provides excellent performance through its XLA (Accelerated Linear Algebra) backend, which can    optimize and compile your code for various hardware accelerators such as GPUs and TPUs. This can lead to significant    speed improvements for certain types of computations.</p> </li> <li> <p>Automatic Differentiation: JAX offers a powerful and flexible automatic differentiation system, which is    essential for training machine learning models. It allows for both forward-mode and reverse-mode automatic    differentiation, giving you more options for gradient computation.</p> </li> <li> <p>Functional Programming: JAX is built around functional programming concepts, which can lead to more composable    and modular code. This can make it easier to reason about your code and to create abstractions that are reusable    across different parts of your project.</p> </li> <li> <p>Interoperability with NumPy: JAX is designed to be compatible with NumPy, which means that you can often take    existing NumPy code and run it with minimal changes on JAX. This can be a significant advantage when transitioning    existing codebases to use JAX.</p> </li> <li> <p>Flexibility: JAX provides a high degree of flexibility, allowing you to drop down to lower-level abstractions    when needed. This can be particularly useful when implementing custom operations or experimenting with new research    ideas.</p> </li> </ol> <p>While JAX offers these benefits, it's important to note that PyTorch and TensorFlow have large and active communities, extensive libraries, and a wide range of pre-trained models, which can be advantageous in certain scenarios. Additionally, the choice of framework often depends on the specific requirements of the project and the familiarity of the team with a particular toolset.</p>"},{"location":"AvailableModels/","title":"Available Models","text":"Models FlashAttn Gradient Checkpointing 8/6/4Bit Interface and Training JIT Compatible Llama \u2705 \u2705 \u2705 \u2705 Mistral \u2705 \u2705 \u2705 \u2705 Qwen \u2705 \u2705 \u2705 \u2705 Mixtral \u2705 \u2705 \u2705 \u274c Llama2 \u274c \u2705 \u2705 \u2705 GPT-J \u2705 \u2705 \u2705 \u2705 Roberta \u2705 \u2705 \u2705 \u2705 GPT-2 \u274c \u2705 \u2705 \u2705 LT \u274c \u2705 \u274c \u2705 MosaicMPT \u2705 \u2705 \u2705 \u2705 GPTNeoX \u2705 \u2705 \u274c \u2705 Falcon \u2705 / \u274c \u2705 \u2705 \u2705 LucidTransformer \u2705 \u2705 \u2705 \u2705 Palm \u2705 \u2705 \ud83c\udf2a\ufe0f \u2705 T5 \u274c \u2705 \ud83c\udf2a\ufe0f \u2705 OPT \u274c \u2705 \u274c \u2705 PHI \u274c \u274c \u2705 \u2705 <p>you can also tell me the model you want in Flax/Jax version and ill try my best to build it ;)</p>"},{"location":"Bits/","title":"EasyBIT","text":""},{"location":"Bits/#about-bits-in-easydel","title":"About Bits in EasyDel","text":"<p>In easydel bits are totally different from huggingface and in EasyDel training model with 8 bit is supported too without needs to change the code just change the bit and that's all you have todo but by the way you still have to pass the dtype and param_dtype cause unlike the transformers and bitsandbytes which store parameters in int8 and do operations in float16, bfloat16, float32 we don't do that like this in Jax we still store parameters as float16,bfloat16 or float32 and do operations in bits like 8 6 4, and you can still train your model in this way and make it much more accurate than bitsandbytes or peft fine-tuning</p> <p>Right now im looking to make EasyBITs in EasyDel work on TPU-v3 cause on low amp GPUs and old TPUs it might now work as good as it does on TPU-v4/5</p>"},{"location":"CONTRIBUTING/","title":"Contributing to EasyDeL","text":"<p>Thank you for considering contributing to EasyDeL! We welcome your input. To ensure a smooth collaboration, please review and adhere to the following guidelines.</p>"},{"location":"CONTRIBUTING/#how-to-contribute","title":"How to Contribute","text":"<p>To contribute to EasyDeL, follow these steps: 1. Fork the repository. 2. Create a new branch for your feature or bug fix. 3. Make your changes and commit them with clear and descriptive messages. 4. Push your changes to your branch in your forked repository. 5. Submit a pull request to the main EasyDeL repository, detailing the changes you've made and the problem it solves.</p>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please adhere to the Apache Code of Conduct in all interactions related to EasyDeL.</p>"},{"location":"CONTRIBUTING/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you encounter a bug, please open an issue on the EasyDeL repository, providing a clear and detailed description of the issue, including steps to reproduce it.</p>"},{"location":"CONTRIBUTING/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>If you have ideas for enhancements, feel free to open an issue on the EasyDeL repository. Provide a clear and detailed description of your proposed enhancement.</p>"},{"location":"CONTRIBUTING/#development-setup","title":"Development Setup","text":"<p>To set up EasyDeL for development, follow the instructions in the README.md file.</p>"},{"location":"CONTRIBUTING/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>When submitting a pull request, please ensure the following: - Your code follows the project's coding standards. - Your commits are accompanied by clear and descriptive messages. - Your pull request addresses a single issue or feature.</p>"},{"location":"CONTRIBUTING/#license","title":"License","text":"<p>By contributing to EasyDeL, you agree that your contributions will be licensed under the Apache License, Version 2.0.</p> <p>Thank you for your interest in contributing to EasyDeL! We appreciate your support.</p>"},{"location":"DataProcessing/","title":"DataProcessing","text":""},{"location":"DataProcessing/#data-processing","title":"Data Processing","text":"<p>here in this case you will see an example data required by EasyDel to pre-train or fine-tune models</p> <pre><code>from datasets import load_dataset\nfrom EasyDel.data_preprocessing import DataProcessor, DataProcessorArguments\nfrom transformers import LlamaTokenizerFast\n\n\ndef main():\n    tokenizer = LlamaTokenizerFast.from_pretrained(\"meta-llama/Llama-2-7b-chat-hf\")\n    dataset = load_dataset(\"erfanzar/orca-lite\")\n    print(dataset)\n\n    #     DatasetDict({\n    #         train: Dataset({\n    #             features: ['user', 'gpt', 'system', 'llama_2_prompt_style', 'prompt_length'],\n    #             num_rows: 101397\n    #         })\n    #     })\n\n    processor_arguments = DataProcessorArguments(\n        max_position_embeddings=2048,\n        num_proc=6,\n        prompt_field='llama_2_prompt_style',\n\n    )\n\n    easydel_dataset = DataProcessor.process_data(\n        data=dataset['train'],\n        tokenizer=tokenizer,\n        arguments=processor_arguments,\n        field='train'\n    )\n    print(easydel_dataset)\n    # DatasetDict({\n    #     train: Dataset({\n    #         features: ['input_ids', 'attention_mask'],\n    #         num_rows: 101397\n    #     })\n    # })\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>now you can pass this data to Trainer and train your model \ud83d\ude07.</p>"},{"location":"EasyStateExample/","title":"EasyState","text":""},{"location":"EasyStateExample/#easydelstate","title":"EasyDelState","text":"<p>EasyDelState is a cool feature in easydel and have a lot of options like storing <code>Model Parameters</code>, Optimizer State, Model Config, Model Type, Optimizer and Scheduler Configs</p> <p>Let see and examples of using EasyDelState</p>"},{"location":"EasyStateExample/#fine-tuning","title":"Fine-tuning","text":"<p>Fine-tuning from a previous State or a new state</p> <pre><code>from EasyDel import (\n    AutoEasyDelConfig,\n    EasyDelState\n)\nfrom transformers import AutoTokenizer\nfrom jax import numpy as jnp, lax\nimport jax\n\nhuggingface_model_repo_id = \"REPO_ID\"\ncheckpoint_name = \"CKPT_NAME\"\n\nstate = EasyDelState.from_pretrained(\n    pretrained_model_name_or_path=huggingface_model_repo_id,\n    filename=checkpoint_name,\n    optimizer=\"adamw\",\n    scheduler=\"none\",\n    tx_init=None,\n    device=jax.devices('cpu')[0],  # Offload Device\n    dtype=jnp.bfloat16,\n    param_dtype=jnp.bfloat16,\n    precision=lax.Precision(\"fastest\"),\n    sharding_axis_dims=(1, -1, 1, 1),\n    sharding_axis_names=(\"dp\", \"fsdp\", \"tp\", \"sp\"),\n    query_partition_spec=jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\", None),\n    key_partition_spec=jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\", None),\n    value_partition_spec=jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\", None),\n    bias_partition_spec=jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), None, None, None),\n    attention_partition_spec=jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\", None),\n    use_shard_map=False,\n    input_shape=(1, 1),\n    backend=None,\n    init_optimizer_state=False,\n    free_optimizer_state=True,\n    verbose=True,\n    state_shard_fns=None,\n)\n\nconfig = AutoEasyDelConfig.from_pretrained(\n    huggingface_model_repo_id\n)\n\nconfig.use_pjit_attention_force = False\n\ntokenizer = AutoTokenizer.from_pretrained(\n    huggingface_model_repo_id,\n    trust_remote_code=True\n)\n\nmax_length = config.max_position_embeddings\n\nconfigs_to_initialize_model_class = {\n    'config': config,\n    'dtype': jnp.bfloat16,\n    'param_dtype': jnp.bfloat16,\n    'input_shape': (8, 8)\n}\n</code></pre> <p><code>EasyDelState</code> also has <code>.load_state()</code> and <code>.save_state()</code> with some other usable options like <code>.free_opt_state()</code> which free optimizer state or <code>.shard_params()</code> which shard parameters you can read docs in order to find out more about these options.</p>"},{"location":"EasyStateExample/#converting-to-huggingface-and-pytorch","title":"Converting to Huggingface and Pytorch","text":"<p>Let see how you can convert a EasyDelMistral Model to Huggingface Pytorch Mistral Model from a trained State</p> <pre><code>\nfrom transformers import MistralForCausalLM\nfrom EasyDel import (\n    AutoEasyDelConfig,\n    EasyDelState,\n    easystate_to_huggingface_model\n)\nimport jax\n\nhuggingface_model_repo_id = \"REPO_ID\"\n\nconfig = AutoEasyDelConfig.from_pretrained(\n    huggingface_model_repo_id\n)\nwith jax.default_device(jax.devices(\"cpu\")[0]):\n    model = easystate_to_huggingface_model(\n        state=EasyDelState.load_state(\n            \"PATH_TO_CKPT\"\n        ),  # You can Pass EasyDelState here\n        base_huggingface_module=MistralForCausalLM,\n        config=config\n    )\n\nmodel = model.half()  # it's a huggingface model now\n</code></pre>"},{"location":"EasyStateExample/#other-use-cases","title":"Other Use Cases","text":"<p><code>EasyDelState</code> have a general use you can use it everywhere in easydel for example for a stand-alone model , serve, fine-tuning and many other features, it's up to you to test how creative you are \ud83d\ude07.</p>"},{"location":"Falcon/","title":"About Falcon Models","text":"<p>Sure, here is a document about Falcon Models:</p> <p>Falcon Models</p> <p>Falcon Models is a family of large language models (LLMs) developed by the Technology Innovation Institute (TII) in Abu Dhabi. The models are trained on a massive dataset of text and code, and can be used for a variety of tasks, including</p> <ul> <li>Natural language understanding (NLU)</li> <li>Natural language generation (NLG)</li> <li>Machine translation</li> <li>Text summarization</li> <li>Question answering</li> <li>Code generation</li> </ul> <p>The Falcon models are available under the Apache 2.0 license, which means that they can be freely used, modified, and redistributed.</p> <p>Falcon-40B</p> <p>The Falcon-40B is the largest model in the Falcon family. It has 40 billion parameters, and is trained on a dataset of 500 billion words. The model is capable of state-of-the-art performance on a variety of NLP tasks.</p> <p>Falcon-7B</p> <p>The Falcon-7B is a smaller version of the Falcon-40B. It has 7 billion parameters, and is trained on a dataset of 100 billion words. The model is still capable of achieving strong performance on NLP tasks, but it is more efficient to train and deploy.</p> <p>Falcon-180B</p> <p>The Falcon-180B is the newest model in the Falcon family. It has 180 billion parameters, and is trained on a dataset of 2 trillion words. The model is the largest openly available LLM, and it is capable of achieving state-of-the-art performance on a variety of NLP tasks.</p> <p>Use Cases</p> <p>The Falcon models can be used for a variety of tasks, including:</p> <ul> <li>Natural language understanding (NLU): The Falcon models can be used to understand the meaning of text, such as   identifying the entities and relationships in a sentence.</li> <li>Natural language generation (NLG): The Falcon models can be used to generate text, such as writing different kinds of   creative content, like poems, code, scripts, musical pieces, email, letters, etc.</li> <li>Machine translation: The Falcon models can be used to translate text from one language to another.</li> <li>Text summarization: The Falcon models can be used to summarize a text document into a shorter, more concise version.</li> <li>Question answering: The Falcon models can be used to answer questions about a text document.</li> <li>Code generation: The Falcon models can be used to generate code, such as Python scripts or Java classes.</li> </ul> <p>Availability</p> <p>The Falcon models are available through the Hugging Face Hub. The models are also available in the TensorFlow Hub and the PyTorch Hub ( and EasyDel).</p> <p>Conclusion</p> <p>The Falcon models are a powerful family of LLMs that can be used for a variety of tasks. The models are open source and available for free, making them a valuable resource for researchers and developers.</p>"},{"location":"Falcon/#how-to-useload-them-in-easydel","title":"How to Use/Load Them in EasyDel","text":"<pre><code>import jax\nfrom EasyDel import AutoEasyDelModelForCausalLM\n\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(\n    'tiiuae/falcon-7b',\n    # other kwargs\n)\n</code></pre> <p>also keep that in mind that returned <code>config</code> includes <code>.get_partition_rules(fsdp=True)</code></p>"},{"location":"Falcon/#use-with-jaxserver","title":"Use With JaxServer","text":"<pre><code>from EasyDel.serve import JAXServer, JAXServerConfig\nfrom EasyDel import AutoEasyDelModelForCausalLM\nfrom transformers import AutoTokenizer\n\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(\n  'tiiuae/falcon-7b',\n  # other kwargs\n)\n\n\nclass FalconJaxServer(JAXServer):\n  ...\n  # You have to Custom this one yourself as you \n  # need read JaxServer Documents inorder to learn how\n\n\nserver = FalconJaxServer.from_parameters(\n  params=params,\n  model=model,\n  config_model=model.config,\n  add_params_field=True,\n  tokenizer=AutoTokenizer.from_pretrained('tiiuae/falcon-7b'),\n  verbose=False,\n  do_memory_log=True,\n  config=JAXServerConfig()\n)\n\nserver.fire()  # Launch FastAPI functions\n\nshared_urls = server.launch(\n  share_chat=True,\n  share_inst=True\n)\n</code></pre> <p>Done \ud83d\ude07 this method can be used for all the Falcon models</p>"},{"location":"FineTuningExample/","title":"Fine Tuning Example","text":""},{"location":"FineTuningExample/#finetuning-causal-language-model","title":"FineTuning Causal Language Model \ud83e\udd75","text":"<p>with using EasyDel FineTuning LLM (CausalLanguageModels) are easy as much as possible with using Jax and Flax and having the benefit of <code>TPUs</code> for the best speed here's a simple code to use in order to finetune your own Model</p> <p>Days Has Been Passed and now using easydel in Jax is way more similar to HF/PyTorch Style now it's time to finetune our model.</p> <pre><code>import jax.numpy\nfrom EasyDel import (\n    TrainArguments,\n    CausalLanguageModelTrainer,\n    AutoEasyDelModelForCausalLM,\n    EasyDelOptimizers,\n    EasyDelSchedulers,\n    EasyDelGradientCheckPointers\n)\nfrom datasets import load_dataset\nimport flax\nfrom jax import numpy as jnp\nfrom transformers import AutoTokenizer\n\nhuggingface_repo_id_or_path = \"TinyLlama/TinyLlama-1.1B-intermediate-step-1431k-3T\"\n\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(huggingface_repo_id_or_path, )\n\nmax_length = 2048\ntokenizer = AutoTokenizer.from_pretrained(\n    huggingface_repo_id_or_path,\n    trust_remote_code=True\n)\ntokenizer.pad_token = tokenizer.eos_token\n\nmodel.config.add_basic_configurations(\n    attn_mechanism=\"flash\",  # Change to 'normal' if the model you are using\n    # don't support flash attention, or you don't want to apply flash attention for the model\n    block_b=1,\n    block_q=1024,\n    block_k=1024,\n    block_k_major=1024,\n)\n\nconfigs_to_initialize_model_class = {\n    \"config\": model.config,\n    \"dtype\": jnp.bfloat16,\n    \"param_dtype\": jnp.bfloat16,\n    \"input_shape\": (1, 1)\n}\n\ntrain_arguments = TrainArguments(\n    model_class=type(model),\n    model_name=\"my_first_model_to_train_using_easydel\",\n    num_train_epochs=3,\n    configs_to_initialize_model_class=configs_to_initialize_model_class,\n    learning_rate=5e-5,\n    learning_rate_end=1e-6,\n    optimizer=EasyDelOptimizers.ADAMW,  # \"adamw\", \"lion\", \"adafactor\" are supported\n    scheduler=EasyDelSchedulers.LINEAR,\n    # \"linear\",\"cosine\", \"none\" ,\"warm_up_cosine\" and \"warm_up_linear\"  are supported\n    weight_decay=0.01,\n    total_batch_size=64,\n    max_training_steps=None,  # None to let trainer Decide\n    do_train=True,\n    do_eval=False,  # it's optional but supported \n    backend=\"tpu\",  # default backed is set to cpu, so you must define you want to use tpu cpu or gpu\n    max_length=max_length,  # Note that you have to change this in the model config too\n    gradient_checkpointing=EasyDelGradientCheckPointers.NOTHING_SAVEABLE,\n    sharding_array=(1, -1, 1, 1),  # the way to shard model across gpu,cpu or TPUs using sharding array (1, -1, 1, 1)\n    # everything training will be in fully FSDP automatic and share data between devices\n    use_pjit_attention_force=False,\n    remove_ckpt_after_load=True,\n    gradient_accumulation_steps=8,\n    loss_re_mat=\"\",\n    dtype=jnp.bfloat16\n)\n\n\ndef ultra_chat_prompting_process(\n        data_chunk\n):\n    user_part = [\n        chunk[\"content\"] for chunk in data_chunk[\"messages\"] if chunk[\"role\"] == \"user\"\n    ]\n    assistant_part = [\n        chunk[\"content\"] for chunk in data_chunk[\"messages\"] if chunk[\"role\"] == \"assistant\"\n    ]\n\n    prompt = \"\"\n\n    for uc, ac in zip(user_part, assistant_part):\n        prompt += f\"&lt;|user|&gt;\\n{uc}&lt;/s&gt;\\n&lt;|assistant|&gt;\\n{ac}&lt;/s&gt;\\n\"\n\n    return {\"prompt\": prompt}\n\n\ntokenization_process = lambda data_chunk: tokenizer(\n    data_chunk[\"prompt\"],\n    add_special_tokens=False,\n    max_length=max_length,\n    padding=\"max_length\"\n)\n\ndataset = load_dataset(\"HuggingFaceH4/ultrachat_200k\")\ndataset_train = dataset[\"train_gen\"].map(ultra_chat_prompting_process, num_proc=12)\ndataset_train = dataset_train.map(\n    tokenization_process,\n    num_proc=12,\n    remove_columns=dataset_train.column_names\n)\n\n# you can do the same for evaluation process dataset\n\ntrainer = CausalLanguageModelTrainer(\n    train_arguments,\n    dataset_train,\n    checkpoint_path=None\n)\n\noutput = trainer.train(flax.core.FrozenDict({\"params\": params}))\nprint(f\"Hey ! , here's where your model saved {output.checkpoint_path}\")\n</code></pre>"},{"location":"Install/","title":"Installing EasyDeL","text":"<p>EasyDeL uses FJFormer and JAX as main dependencies in order to run the scripts but there are some things that needs to be installed such as GO-lang to JAX specific platform installations, but you can simply install EasyDeL via pip:</p> <pre><code>pip install easydel\n</code></pre>"},{"location":"Install/#installing-jax","title":"Installing Jax","text":"<p>JAX uses XLA to compile and run your NumPy programs on GPUs and TPUs. Compilation happens under the hood by default, with library calls getting just-in-time compiled and executed. But JAX also lets you just-in-time compile your own Python functions into XLA-optimized kernels using a one-function API, jit.</p> <p>you can install other version too but easydel required at least version of 0.4.16</p>"},{"location":"Install/#tpu","title":"TPU","text":"<pre><code>!pip install jax[tpu] -f https://storage.googleapis.com/jax-releases/libtpu_releases.html -q\n</code></pre>"},{"location":"Install/#gpu","title":"GPU","text":""},{"location":"Install/#cuda-12","title":"CUDA-12","text":"<pre><code>pip install --upgrade pip\n# CUDA 12 installation\n# Note: wheels only available on linux.\npip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n</code></pre>"},{"location":"Install/#cuda-11","title":"CUDA-11","text":"<pre><code>pip install --upgrade pip\n# CUDA 11 installation\n# Note: wheels only available on linux.\npip install --upgrade \"jax[cuda11_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n</code></pre>"},{"location":"Install/#installing-go","title":"Installing GO","text":""},{"location":"Install/#note-this-library-needs-golang-to-run-for-some-tracking-stuff-on-tpugpucpu","title":"Note this Library needs golang to run (for some tracking stuff on TPU/GPU/CPU)","text":""},{"location":"Install/#ubuntu-go-installation","title":"Ubuntu GO installation","text":"<pre><code>sudo apt-get update &amp;&amp; apt-get upgrade -y\nsudo apt-get install golang -y \n</code></pre>"},{"location":"Install/#manjaroarch-go-installation","title":"Manjaro/Arch GO installation","text":"<pre><code>sudo pacman -Syyuu go\n</code></pre>"},{"location":"JAXServer/","title":"JAXServer","text":""},{"location":"JAXServer/#jaxserver","title":"JAXServer \ud83e\uddec","text":"<p><code>JAXServer</code> is one of offered utilities by EasyDel, and it's help hosting using and doing process with LLMs and its also hackable, so you can override your own method in it and use it support both mid-level and high-level apis and also give you a Gradio Chat and Instruct Pre-build and ready to use page</p> <ul> <li>Supported Models are:<ul> <li>EveryModel that have <code>transformers.FlaxPretrainedModel</code> as their Parent :)</li> </ul> </li> </ul>"},{"location":"JAXServer/#input-configs","title":"Input Configs","text":"<p>The config input is a dictionary that contains the following keys:</p> <ul> <li><code>port</code>: The port number that the server will listen on.<ul> <li>Default Value has been set to  <code>2059</code></li> </ul> </li> <li><code>batch_size</code>: The batch size for training.<ul> <li>Default Value has been set to  <code>1</code></li> </ul> </li> <li><code>max_sequence_length</code>: The maximum length of a sequence.<ul> <li>Default Value has been set to  <code>2048</code></li> </ul> </li> <li><code>max_new_tokens</code>: The maximum number of new tokens generated by the model in a single step.<ul> <li>Default Value has been set to  <code>2048</code></li> </ul> </li> <li><code>max_compile_tokens</code>: The maximum number of tokens that can be streamed to the model in a single batch.<ul> <li>Default Value has been set to  <code>32</code></li> </ul> </li> <li><code>temperature</code>: The temperature parameter for sampling from the model's output distribution.<ul> <li>Default Value has been set to  <code>0.1</code></li> </ul> </li> <li><code>top_p</code>: The top-p parameter for sampling from the model's output distribution.<ul> <li>Default Value has been set to  <code>0.95</code></li> </ul> </li> <li><code>top_k</code>: The top-k parameter for sampling from the model's output distribution.<ul> <li>Default Value has been set to  <code>50</code></li> </ul> </li> <li><code>mesh_axes_shape</code>: The shape of the mesh axes for distributed training.<ul> <li>Default Value has been set to  <code>(1, -1, 1, 1)</code></li> </ul> </li> <li><code>host</code>: The host address for the server.<ul> <li>Default Value has been set to  <code>'0.0.0.0'</code></li> </ul> </li> <li><code>dtype</code>: The data type for the model's parameters.<ul> <li>Default Value has been set to  <code>'fp16'</code></li> </ul> </li> <li><code>mesh_axes_names</code>: The names of the mesh axes for distributed training.<ul> <li>Default Value has been set to  <code>(\"dp\", \"fsdp\", \"tp\", \"sp\")</code></li> </ul> </li> <li><code>logging</code>: Whether the model should log its training progress.:<ul> <li>Default Value has been set to  <code>True</code></li> </ul> </li> <li><code>stream_tokens_for_gradio</code>: Whether the model should stream tokens to Gradio.<ul> <li>Default Value has been set to  <code>True</code></li> </ul> </li> <li><code>use_prefix_tokenizer</code>: Whether the model should use a prefix tokenizer.<ul> <li>Default Value has been set to  <code>True</code></li> </ul> </li> <li><code>pre_compile</code>: Whether the model should be pre-compiled.<ul> <li>Default Value has been set to  <code>True</code></li> </ul> </li> </ul>"},{"location":"JAXServer/#jaxserver-functions","title":"JAXServer Functions","text":"<p><code>JAXServer</code> has <code>format_chat</code> and <code>format_instruct</code> funcs that you have to implement them to prompt your model</p> <pre><code>@staticmethod\ndef format_instruct(system: str, instruction: str)-&gt;str:\n    \"\"\"\n    Here you will get the system and instruction from user, and you can apply your prompting style\n    \"\"\"\n    raise NotImplementedError()\n\n@staticmethod\ndef format_chat(history: typing.List[str], prompt: str, system: typing.Union[str, None])-&gt;str:\n    \"\"\"\n    Here you will get the system, prompt and history from user, and you can apply your prompting style\n    \"\"\"\n    raise NotImplementedError()\n</code></pre> <p><code>JAXServer</code> Contains a method named <code>.process</code> and with using <code>process</code> method you can generate text from text</p> <p>what does this do and how this works ? here's the inputs that <code>process</code> function takes in</p> <pre><code>def process(self,\n            string,\n            *,\n            greedy: bool = False,\n            max_new_tokens: int = None,\n            **kwargs\n            ) -&gt; [str, int]:\n    ...\n</code></pre> <ul> <li>Arguments:<ul> <li>string : String to be tokenized <code>(String)</code></li> <li>Greedy : Use Greedy Search Method or NO <code>(Bool)</code></li> <li>Max New Tokens : Number Of new Tokens to be Generated <code>(Int)</code></li> </ul> </li> <li>Yields:<ul> <li>String : Next Tokens Predicted to String <code>(String)</code></li> <li>Number of Used Tokens : Number of Used Tokens to generate answer <code>(Int)</code></li> </ul> </li> </ul> <p>you can use this function outside the class like this</p> <pre><code>for string, num_used_tokens in server.process(\n        'im a string',\n        greedy=False,\n        max_new_tokens=256  # or None to use Maximum numbers passed in Config\n):\n    print(f'\\r{num_used_tokens}: {string}', end=\"\")\n</code></pre>"},{"location":"JAXServer/#gradio-functions","title":"Gradio Functions \ud83e\udd16","text":"<p>if you want to change gradio response functions you can override them like this</p>"},{"location":"JAXServer/#chat-gradio-function","title":"Chat Gradio Function","text":"<p>this is the default gradio functions and this is how it looks :</p> <pre><code>def process_gradio_chat(self, prompt, history, max_new_tokens, system, greedy):\n    string = self.chat_format(history=history, prompt=prompt, system=system)\n\n    if not self.config.stream_tokens_for_gradio:\n        response = \"\"\n        for response, _ in self.process(\n                string=string,\n                greedy=greedy,\n                max_new_tokens=max_new_tokens,\n        ):\n            ...\n        history.append([prompt, response])\n    else:\n        history.append([prompt, \"\"])\n        for response, _ in self.process(\n                string=string,\n                greedy=greedy,\n                max_new_tokens=max_new_tokens,\n        ):\n            history[-1][-1] = response\n            yield \"\", history\n    return \"\", history\n</code></pre> <p>and here's a example of changing that in order to use Llama Models</p> <pre><code>def process_gradio_chat(self, prompt, history, max_new_tokens, system, greedy):\n    def prompt_llama2_model(message: str, chat_history,\n                            system_prompt: str) -&gt; str:\n\n        do_strip = False\n        texts = [f'&lt;s&gt;[INST] &lt;&lt;SYS&gt;&gt;\\n{system_prompt}\\n&lt;&lt;/SYS&gt;&gt;\\n\\n']\n        for user_input, response in chat_history:\n            user_input = user_input.strip() if do_strip else user_input\n            do_strip = True\n            texts.append(f'{user_input} [/INST] {response.strip()} &lt;/s&gt;&lt;s&gt;[INST] ')\n        message = message.strip() if do_strip else message\n        texts.append(f'{message} [/INST]')\n        return \"\".join(texts)\n\n    string = prompt_llama2_model(\n        message=prompt,\n        chat_history=history or [],\n        system_prompt=system\n    )\n    if not self.config.stream_tokens_for_gradio:\n        response = \"\"\n        for response, _ in self.process(\n                string=string,\n                greedy=greedy,\n                max_new_tokens=max_new_tokens,\n        ):\n            ...\n        history.append([prompt, response])\n    else:\n        history.append([prompt, \"\"])\n        for response, _ in self.process(\n                string=string,\n                greedy=greedy,\n                max_new_tokens=max_new_tokens\n        ):\n            history[-1][-1] = response\n            yield \"\", history\n\n    return \"\", history\n\n</code></pre> <p>as you see you can easily override the functions just like how you want and use them with some simple changes, and you can Also Use Their <code>Gradio Client</code> or use <code>JAXServer</code> <code>FastAPI</code> builtin methods</p>"},{"location":"JAXServer/#fastapi","title":"FastAPI \ud83c\udf2a","text":""},{"location":"JAXServer/#instruct-api","title":"Instruct API","text":"<p>to Override this api you have to code <code>forward_instruct</code> just like what you want the default implementation of this function is</p> <pre><code>def forward_instruct(self, data: InstructRequest):\n    if not self._funcs_generated:\n        return {\n            'status': \"down\"\n        }\n\n    string = self.config.instruct_format.format(instruct=data.prompt, system=data.system)\n    response, used_tokens = [None] * 2\n    for response, used_tokens in self.process(\n            string=string,\n            greedy=data.greedy,\n            max_new_tokens=None\n    ):\n        ...\n    self.number_of_served_request_until_last_up_time += 1\n    return {\n        'input': f'{string}',\n        'response': response,\n        'tokens_used': used_tokens,\n    }\n</code></pre> <ul> <li>BaseModel Class For PYData in FastAPI :</li> </ul> <pre><code>class InstructRequest(BaseModel):\n    prompt: str\n    system: Optional[str] = None\n    temperature: Optional[float] = None\n    greedy: Optional[bool] = False\n</code></pre> <ul> <li>And here's an example of using this api via python and creating a simple client with using <code>requests</code> library in   python :</li> </ul> <pre><code>import requests\n\ncontent = {\n    'prompt': 'can you code a simple neural network in c++ for me',\n    'system': 'You are an AI assistant generate short and useful response',\n    'temperature': 0.1,\n    'greedy': False\n}\n\nresponse = requests.post(\n    url='http://ip:port/instruct',\n    json=content\n).json()\n\nprint(response['response'])\n# Response of model\nprint(response['input'])\n# The input passed to the model\n\n</code></pre>"},{"location":"JAXServer/#chat-api","title":"Chat API","text":"<p>to Override this api you have to code <code>forward_chat</code> just like what you want the default implementation of this function is</p> <pre><code>def forward_chat(self, data: ChatRequest):\n    if not self._funcs_generated:\n        return {\n            'status': \"down\"\n        }\n\n    history = self.process_chat_history(data.history or [])\n    history += self.config.prompt_prefix_chat + data.prompt + self.config.prompt_postfix_chat\n\n    response, used_tokens = [None] * 2\n    for response, used_tokens in self.process(\n            string=history,\n            greedy=data.greedy,\n            max_new_tokens=None\n    ):\n        ...\n    self.number_of_served_request_until_last_up_time += 1\n    return {\n        'input': f'{history}',\n        'response': response,\n        'tokens_used': used_tokens,\n    }\n</code></pre> <ul> <li>BaseModel Class For PYData in FastAPI :</li> </ul> <pre><code>class ChatRequest(BaseModel):\n    prompt: str\n    history: Union[List[List], None] = None\n    temperature: Optional[float] = None\n    greedy: Optional[bool] = False\n</code></pre> <ul> <li>And here's an example of using this api via python and creating a simple client with using <code>requests</code> library in   python :</li> </ul> <pre><code>import requests\n\ncontent = {\n    'prompt': 'can you code a simple neural network in c++ for me',\n    'history': [\n        ['hello how are you', 'Hello\\nthanks, im here to assist you you have any question that i could help you with']\n    ],\n    'temperature': 0.1,\n    'greedy': False\n}\n\nresponse = requests.post(\n    url='http://ip:port/chat',\n    json=content\n).json()\n\nprint(response['response'])\n# Response of model\nprint(response['input'])\n# The input passed to the model\n\n</code></pre>"},{"location":"JAXServer/#status","title":"Status \ud83d\udce3","text":"<p>Simply by sending a get API to <code>https://ip:port/status</code> you will receive base information about the server and how it being run, num cores in use, number of generated prompt , number of request and ...</p>"},{"location":"Llama/","title":"About Llama Models","text":"<ul> <li>Introduction</li> </ul> <p>Llama models are a family of large language models (LLMs) developed by Meta AI. They are trained on a massive dataset of text and code, and they can be used for a variety of tasks, such as text generation, translation, summarization, question answering, code generation, and natural language inference.</p> <ul> <li>Model Architecture</li> </ul> <p>Llama models are based on the Transformer architecture, which is a neural network architecture that has been shown to be very effective for natural language processing tasks. The Transformer architecture uses self-attention to learn long-range dependencies between words in a sentence.</p> <ul> <li>Training Data</li> </ul> <p>Llama models are trained on a massive dataset of text and code. The text dataset includes text from a variety of sources, such as books, articles, and websites. The code dataset includes code from a variety of programming languages, such as Python, Java, and C++.</p> <ul> <li>Fine-tuning</li> </ul> <p>After being pre-trained on a massive dataset, Llama models can be fine-tuned for specific tasks. Fine-tuning involves training the model on a smaller dataset of data that is relevant to the specific task.</p> <ul> <li>Applications</li> </ul> <p>Llama models can be used for a variety of tasks, such as:</p> <pre><code>* Text generation: Llama models can be used to generate text, such as poems, code, scripts, and musical pieces.\n* Translation: Llama models can be used to translate text from one language to another.\n* Summarization: Llama models can be used to summarize text.\n* Question answering: Llama models can be used to answer questions about text.\n* Code generation: Llama models can be used to generate code.\n* Natural language inference: Llama models can be used to determine the relationship between two sentences.\n</code></pre> <ul> <li>Availability</li> </ul> <p>Llama models are available for free for research and commercial use. They can be downloaded from the Hugging Face Hub.</p> <ul> <li>Limitations</li> </ul> <p>Llama models are still under development, and they have some limitations. For example, they can sometimes generate incorrect or misleading text. They can also be biased, reflecting the biases that are present in the training data.</p> <ul> <li>Future Work</li> </ul> <p>Llama models are a promising new technology with the potential to be used for a variety of applications. Future work on Llama models will focus on improving their accuracy, reducing their bias, and making them more robust to errors.</p> <ul> <li>Text generation</li> <li>Translation</li> <li>Summarization</li> <li>Question answering</li> <li>Code generation</li> <li>Natural language inference</li> </ul> <p>Here is a table comparing the different sizes of Llama models:</p> Model Parameters Llama 7B 7 billion Llama 13B 13 billion Llama 33B 33 billion Llama 65B 65 billion Llama 70B 70 billion"},{"location":"Llama/#how-to-useload-them-in-easydel","title":"How to Use/Load Them in EasyDel","text":"<pre><code>from EasyDel import AutoEasyDelModelForCausalLM\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(\n    'meta-llama/Llama-2-7b',\n    # other kwargs\n)\n</code></pre> <p>also keep that in mind that returned <code>config</code> includes <code>.get_partition_rules(fsdp=True)</code></p>"},{"location":"Llama/#use-with-jaxserver","title":"Use With JaxServer","text":"<pre><code>from EasyDel.serve import JAXServer, JAXServerConfig\nimport jax\nfrom transformers import AutoTokenizer\n\nfrom EasyDel import AutoEasyDelModelForCausalLM\n\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(\n    'meta-llama/Llama-2-7b',\n    # other kwargs\n)\n\nDEFAULT_SYSTEM_PROMPT = \"You are a helpful, respectful and honest assistant and act as wanted\"\n\n\nclass Llama2JaxServer(JAXServer):\n    def process_gradio_chat(self, prompt, history, max_new_tokens, system, greedy):\n\n        system = None if system == \"\" else system\n        string = self.prompt_llama2_model(\n            message=prompt,\n            chat_history=history or [],\n            system_prompt=system or DEFAULT_SYSTEM_PROMPT\n        )\n        if not self.config.stream_tokens_for_gradio:\n            response = \"\"\n            for response, _ in self.process(\n                    string=string,\n                    greedy=greedy,\n                    max_new_tokens=max_new_tokens,\n            ):\n                ...\n            history.append([prompt, response])\n        else:\n            history.append([prompt, \"\"])\n            for response, _ in self.process(\n                    string=string,\n                    greedy=greedy,\n                    max_new_tokens=max_new_tokens\n            ):\n                history[-1][-1] = response\n                yield \"\", history\n\n        return \"\", history\n\n    def process_gradio_instruct(self, prompt, system, max_new_tokens, greedy):\n        string = self.prompt_llama2_model(system_prompt=DEFAULT_SYSTEM_PROMPT, message=prompt, chat_history=[])\n        if not self.config.stream_tokens_for_gradio:\n            response = \"\"\n            for response, _ in self.process(\n                    string=string,\n                    greedy=greedy,\n                    max_new_tokens=max_new_tokens,\n            ):\n                pass\n        else:\n            response = \"\"\n            for response, _ in self.process(\n                    string=string,\n                    greedy=greedy,\n                    max_new_tokens=max_new_tokens,\n                    stream=True\n            ):\n                yield \"\", response\n        return \"\", response\n\n    @staticmethod\n    def prompt_llama2_model(message: str, chat_history,\n                            system_prompt: str) -&gt; str:\n\n        do_strip = False\n        texts = [f'&lt;s&gt;[INST] &lt;&lt;SYS&gt;&gt;\\n{system_prompt}\\n&lt;&lt;/SYS&gt;&gt;\\n\\n']\n        for user_input, response in chat_history:\n            user_input = user_input.strip() if do_strip else user_input\n            do_strip = True\n            texts.append(f'{user_input} [/INST] {response.strip()} &lt;/s&gt;&lt;s&gt;[INST] ')\n        message = message.strip() if do_strip else message\n        texts.append(f'{message} [/INST]')\n        return \"\".join(texts)\n\n\nserver = Llama2JaxServer.from_parameters(\n    params=params,\n    model=model,\n    config_model=model.config,\n    add_params_field=True,\n    tokenizer=AutoTokenizer.from_pretrained('meta-llama/Llama-2-7b'),\n    verbose=False,\n    do_memory_log=True,\n    config=JAXServerConfig()\n)\n\nserver.fire()  # Launch FastAPI functions\n\nshared_urls = server.launch(\n    share_chat=True,\n    share_inst=True\n)\n</code></pre> <p>Done \ud83d\ude07 this method can be used for all the llama models</p>"},{"location":"Llama2/","title":"Llama2 Models","text":""},{"location":"Llama2/#about-llama2-models","title":"About Llama2 Models","text":"<p>Llama2 Models</p> <p>Llama2 Models is a family of pretrained and fine-tuned large language models (LLMs) developed by Meta AI. The models are trained on a massive dataset of text and code, and can be used for a variety of tasks, including</p> <ul> <li>Natural language understanding (NLU)</li> <li>Natural language generation (NLG)</li> <li>Machine translation</li> <li>Text summarization</li> <li>Question answering</li> <li>Code generation</li> </ul> <p>The Llama2 models are available under the Apache 2.0 license, which means that they can be freely used, modified, and redistributed.</p> <p>Model Architecture</p> <p>The Llama2 models are based on the Transformer architecture, which is a neural network architecture that has been shown to be very effective for NLP tasks. The models are trained using a technique called masked language modeling, which involves predicting the missing words in a sequence of text.</p> <p>Model Sizes</p> <p>The Llama2 models come in a variety of sizes, ranging from 7 billion to 70 billion parameters. The larger models have more capacity to learn complex patterns in language, but they are also more computationally expensive to train and deploy.</p> <p>Fine-tuning</p> <p>The Llama2 models are pretrained on a massive dataset of text and code, but they can be further fine-tuned on a specific task to improve their performance. Fine-tuning involves training the model on a dataset of labeled data for the specific task.</p> <p>Use Cases</p> <p>The Llama2 models can be used for a variety of tasks, including:</p> <ul> <li>Natural language understanding (NLU): The Llama2 models can be used to understand the meaning of text, such as   identifying the entities and relationships in a sentence.</li> <li>Natural language generation (NLG): The Llama2 models can be used to generate text, such as writing different kinds of   creative content, like poems, code, scripts, musical pieces, email, letters, etc.</li> <li>Machine translation: The Llama2 models can be used to translate text from one language to another.</li> <li>Text summarization: The Llama2 models can be used to summarize a text document into a shorter, more concise version.</li> <li>Question answering: The Llama2 models can be used to answer questions about a text document.</li> <li>Code generation: The Llama2 models can be used to generate code, such as Python scripts or Java classes.</li> </ul> <p>Availability</p> <p>The Llama2 models are available through the Hugging Face Hub. The models are also available in the TensorFlow Hub , the PyTorch Hub and EasyDel.</p> <p>Conclusion</p> <p>The Llama2 models are a powerful family of LLMs that can be used for a variety of tasks. The models are open source and available for free, making them a valuable resource for researchers and developers.</p>"},{"location":"Llama2/#how-to-useload-them-in-easydel","title":"How to Use/Load Them in EasyDel","text":"<pre><code>from EasyDel import AutoEasyDelModelForCausalLM\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(\n    'meta-llama/Llama-2-7b',\n    # other kwargs\n)\n</code></pre> <p>also keep that in mind that returned <code>config</code> includes <code>.get_partition_rules(fsdp=True)</code></p>"},{"location":"Llama2/#use-with-jaxserver","title":"Use With JaxServer","text":"<pre><code>from EasyDel.serve import JAXServer, JAXServerConfig\nimport jax\nfrom transformers import AutoTokenizer\n\nfrom EasyDel import AutoEasyDelModelForCausalLM\n\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(\n    'meta-llama/Llama-2-7b',\n    # other kwargs\n)\n\nDEFAULT_SYSTEM_PROMPT = \"You are a helpful, respectful and honest assistant and act as wanted\"\n\n\nclass Llama2JaxServer(JAXServer):\n    def process_gradio_chat(self, prompt, history, max_new_tokens, system, greedy):\n\n        system = None if system == \"\" else system\n        string = self.prompt_llama2_model(\n            message=prompt,\n            chat_history=history or [],\n            system_prompt=system or DEFAULT_SYSTEM_PROMPT\n        )\n        if not self.config.stream_tokens_for_gradio:\n            response = \"\"\n            for response, _ in self.process(\n                    string=string,\n                    greedy=greedy,\n                    max_new_tokens=max_new_tokens,\n            ):\n                ...\n            history.append([prompt, response])\n        else:\n            history.append([prompt, \"\"])\n            for response, _ in self.process(\n                    string=string,\n                    greedy=greedy,\n                    max_new_tokens=max_new_tokens\n            ):\n                history[-1][-1] = response\n                yield \"\", history\n\n        return \"\", history\n\n    def process_gradio_instruct(self, prompt, system, max_new_tokens, greedy):\n        string = self.prompt_llama2_model(system_prompt=DEFAULT_SYSTEM_PROMPT, message=prompt, chat_history=[])\n        if not self.config.stream_tokens_for_gradio:\n            response = \"\"\n            for response, _ in self.process(\n                    string=string,\n                    greedy=greedy,\n                    max_new_tokens=max_new_tokens,\n            ):\n                pass\n        else:\n            response = \"\"\n            for response, _ in self.process(\n                    string=string,\n                    greedy=greedy,\n                    max_new_tokens=max_new_tokens,\n                    stream=True\n            ):\n                yield \"\", response\n        return \"\", response\n\n    @staticmethod\n    def prompt_llama2_model(message: str, chat_history,\n                            system_prompt: str) -&gt; str:\n\n        do_strip = False\n        texts = [f'&lt;s&gt;[INST] &lt;&lt;SYS&gt;&gt;\\n{system_prompt}\\n&lt;&lt;/SYS&gt;&gt;\\n\\n']\n        for user_input, response in chat_history:\n            user_input = user_input.strip() if do_strip else user_input\n            do_strip = True\n            texts.append(f'{user_input} [/INST] {response.strip()} &lt;/s&gt;&lt;s&gt;[INST] ')\n        message = message.strip() if do_strip else message\n        texts.append(f'{message} [/INST]')\n        return \"\".join(texts)\n\n\nserver = Llama2JaxServer.from_parameters(\n    params=params,\n    model=model,\n    config_model=model.config,\n    add_params_field=True,\n    tokenizer=AutoTokenizer.from_pretrained('meta-llama/Llama-2-7b'),\n    verbose=False,\n    do_memory_log=True,\n    config=JAXServerConfig()\n)\n\nserver.fire()  # Launch FastAPI functions\n\nshared_urls = server.launch(\n    share_chat=True,\n    share_inst=True\n)\n</code></pre> <p>Done \ud83d\ude07 this method can be used for all the llama2 models</p>"},{"location":"LoRA-TransferLearningExample/","title":"LoRA and Transfer Learning","text":""},{"location":"LoRA-TransferLearningExample/#easydelxrapture-for-layer-tuning-and-lora","title":"EasyDeLXRapTure for layer tuning and LoRA","text":"<p>in case of using LoRA and applying that on the EasyDeL models there are some other things that you might need to config on your own but a lot of things being handled by EasyDeL so let just jump into an example for LoRA fine-tuning section and use EasyDeLXRapTure in for mistral models with flash attention example</p> <pre><code>from flax.core import FrozenDict\nfrom EasyDel import (\n    TrainArguments,\n    CausalLanguageModelTrainer,\n    AutoEasyDelModelForCausalLM,\n    EasyDelOptimizers,\n    EasyDelSchedulers,\n    EasyDelGradientCheckPointers,\n    EasyDeLXRapTureConfig\n)\nfrom datasets import load_dataset\nimport flax\nfrom jax import numpy as jnp\nfrom transformers import AutoTokenizer\n\nhuggingface_repo_id_or_path = \"mistralai/Mistral-7B-Instruct-v0.1\"\n\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(huggingface_repo_id_or_path, )\n\nmax_length = 8196\nmodel_parameters = FrozenDict({\"params\": params})\n\ndtype = jnp.bfloat16\nparam_dtype = jnp.bfloat16  # you can change that if you want \n\ntokenizer = AutoTokenizer.from_pretrained(\n    huggingface_repo_id_or_path,\n    trust_remote_code=True\n)\n\nmodel.config.add_basic_configurations(\n    attn_mechanism=\"flash\",  # Using FlashAttention\n    block_b=1,\n    block_q=1024,\n    block_k=1024,\n    block_k_major=1024,\n)\n\ntokenizer.pad_token = tokenizer.eos_token\nconfigs_to_initialize_model_class = {\n    \"config\": model.config,\n    \"dtype\": dtype,\n    \"param_dtype\": param_dtype,\n    \"input_shape\": (1, 1)\n}\n\nrapture = EasyDeLXRapTureConfig(\n    parameters=model_parameters,\n    lora_dim=64,\n    fully_fine_tune_parameters=[\"embed_tokens\"],  # Model layer to be fully fine tuned\n    lora_fine_tune_parameters=[\"q_proj\", \"v_proj\", \"k_proj\", \"o_proj\"],  # LoRA Layer Targets you can pass this to none\n    # For only Layer Tuning or transfer learning\n    verbose=True\n)\n\ntrain_arguments = TrainArguments(\n    model_class=type(model),\n    model_name=\"EasyDeL-Lora-Example\",\n    num_train_epochs=3,\n    configs_to_initialize_model_class=configs_to_initialize_model_class,\n    learning_rate=1e-4,  # Using higher learning rate is recommended\n    learning_rate_end=8e-5,\n    optimizer=EasyDelOptimizers.ADAMW,  # \"adamw\", \"lion\", \"adafactor\" are supported\n    scheduler=EasyDelSchedulers.LINEAR,\n    # \"linear\",\"cosine\", \"none\" ,\"warm_up_cosine\" and \"warm_up_linear\"  are supported\n    weight_decay=0.01,\n    total_batch_size=512,\n    max_training_steps=None,  # None to let trainer Decide\n    do_train=True,\n    do_eval=False,  # it's optional but supported \n    backend=\"tpu\",  # default backed is set to cpu, so you must define you want to use tpu cpu or gpu\n    max_length=max_length,  # Note that you have to change this in the model config too\n    gradient_checkpointing=EasyDelGradientCheckPointers.NOTHING_SAVEABLE,\n    sharding_array=(1, -1, 1, 1),  # the way to shard model across gpu,cpu or TPUs using sharding array (1, -1, 1, 1)\n    # everything training will be in fully FSDP automatic and share data between devices\n    use_pjit_attention_force=False,\n    remove_ckpt_after_load=True,\n    gradient_accumulation_steps=1,\n    loss_re_mat=\"\",\n    dtype=dtype,\n    param_dtype=param_dtype,\n    rapture_config=rapture,\n    merge_lora_rapture_parameters=True  # turning this off is still not supported and not recommended to do so\n    # What this does ? this will merge the lora parameters with the original model parameters and the end of training\n)\n\n\ndef ultra_chat_prompting_process(\n        data_chunk\n):\n    user_part = [\n        chunk[\"content\"] for chunk in data_chunk[\"messages\"] if chunk[\"role\"] == \"user\"\n    ]\n    assistant_part = [\n        chunk[\"content\"] for chunk in data_chunk[\"messages\"] if chunk[\"role\"] == \"assistant\"\n    ]\n\n    prompt = \"\"\n\n    for uc, ac in zip(user_part, assistant_part):\n        prompt += f\"&lt;|user|&gt;\\n{uc}&lt;/s&gt;\\n&lt;|assistant|&gt;\\n{ac}&lt;/s&gt;\\n\"\n\n    return {\"prompt\": prompt}\n\n\ntokenization_process = lambda data_chunk: tokenizer(\n    data_chunk[\"prompt\"],\n    add_special_tokens=False,\n    max_length=max_length,\n    padding=\"max_length\"\n)\n\ndataset = load_dataset(\"HuggingFaceH4/ultrachat_200k\")\ndataset_train = dataset[\"train_gen\"].map(ultra_chat_prompting_process, num_proc=12)\ndataset_train = dataset_train.map(\n    tokenization_process,\n    num_proc=12,\n    remove_columns=dataset_train.column_names\n)\n\n# you can do the same for evaluation process dataset\n\ntrainer = CausalLanguageModelTrainer(\n    train_arguments,\n    dataset_train,\n    checkpoint_path=None\n)\n\noutput = trainer.train()  # you should not pass the parameters in Trainer.train anymore when\n# you are using LoRA or transfer Learning\nprint(f\"Hey ! , here's where your model saved {output.checkpoint_path}\")\n</code></pre>"},{"location":"Mistral/","title":"Mistral Models","text":""},{"location":"Mistral/#mistral-models","title":"Mistral Models","text":"<p>Mistral LLM models. Mistral AI is a French startup that develops large language models (LLMs). Mistral's first LLM, Mistral-7B-v0.1, was released in October 2023. It is a 7 billion parameter decoder-based LM with a number of architectural innovations, including sliding window attention, grouped query attention, and byte-fallback BPE tokenizer. Mistral-7B-v0.1 has been shown to achieve state-of-the-art performance on a number of NLP benchmarks, including GLUE, SuperGLUE, and the Stanford Question Answering Dataset.</p> <p>Mistral AI has not yet released a commercial version of Mistral-7B-v0.1, but it is available for free download and evaluation. The company is also working on developing larger and more powerful LLMs, including a 100 billion parameter model.</p> <p>Mistral's LLMs have been praised for their ability to generate creative and informative text, as well as their ability to perform a wide range of NLP tasks, such as translation, question answering, and summarization. However, some concerns have been raised about the potential for Mistral's LLMs to be used to generate harmful content, such as instructions on how to make bombs or how to self-harm.</p> <p>Overall, Mistral AI is a promising startup in the field of LLM development. Its LLMs have the potential to be used in a wide range of applications, such as customer service, education, and creative writing. However, it is important to be aware of the potential risks associated with using LLMs, such as the risk of generating harmful content.</p> <p>README.md</p> <p>Mistral LLM models</p> <p>Mistral LLM models are a set of large language models (LLMs) developed by Mistral AI, a French startup. Mistral's LLMs are trained on massive datasets of text and code, and can be used to perform a variety of NLP tasks, including:</p> <ul> <li>Text generation</li> <li>Translation</li> <li>Question answering</li> <li>Summarization</li> <li>Code generation</li> <li>Creative writing</li> </ul> <p>Mistral-7B-v0.1 is the first LLM released by Mistral AI. It is a 7 billion parameter decoder-based LM with a number of architectural innovations, including sliding window attention, grouped query attention, and byte-fallback BPE tokenizer. Mistral-7B-v0.1 has been shown to achieve state-of-the-art performance on a number of NLP benchmarks, including GLUE, SuperGLUE, and the Stanford Question Answering Dataset.</p> <p>To use a Mistral LLM model:</p> <ol> <li>Download the model weights from the Mistral AI website: https://mistral.ai/.</li> <li>Install the necessary dependencies, such as the Transformers library.</li> <li>Load the model weights into a Python script or notebook.</li> <li>Call the model's <code>generate()</code> method to generate text, translate languages, answer questions, or perform other NLP    tasks.</li> </ol> <p>Mistral LLM models are still under development, but they have the potential to be used in a wide range of applications. If you are interested in using Mistral's LLMs, please visit the Mistral AI website: https://mistral.ai/ for more information.</p>"},{"location":"Mistral/#mistral-model-in-easydel","title":"Mistral Model In EasyDel","text":"<p>using Mistral Models are the same as all the other models in EasyDel Collection but let take a look at how can we train or finetune a Mistral model</p> <pre><code>from EasyDel.trainer import TrainArguments, CausalLanguageModelTrainer\nfrom datasets import load_dataset\nfrom transformers import AutoTokenizer\nfrom jax import numpy as jnp\nimport flax\nimport EasyDel\nfrom EasyDel import (\n    AutoEasyDelModelForCausalLM,\n    EasyDelOptimizers,\n    EasyDelSchedulers,\n    EasyDelGradientCheckPointers\n)\n\nmodel_huggingface_repo_id = 'mistralai/Mistral-7B-v0.1'\ndataset_train = load_dataset('&lt;TOKENIZED_MISTRAL_DATASET_AT_HUGGINGFACE&gt;')\ntokenizer = AutoTokenizer.from_pretrained(model_huggingface_repo_id, trust_remote_code=True)\nmodel, params = AutoEasyDelModelForCausalLM.from_pretrained(model_huggingface_repo_id)\nconfig = model.config\nconfig.freq_max_position_embeddings = config.max_position_embeddings  # 32768\nconfig.max_position_embeddings = 4096  # Let use context length of 4096 for training\nconfig.c_max_position_embeddings = config.max_position_embeddings\n\nmax_sequence_length = config.max_position_embeddings\n\ntrain_args = TrainArguments(\n    model_class=EasyDel.FlaxMistralForCausalLM,\n    configs_to_initialize_model_class={\n        'config': config,\n        'dtype': jnp.bfloat16,\n        'param_dtype': jnp.bfloat16,\n        'input_shape': (1, 1)\n    },\n    custom_rule=config.get_partition_rules(True),\n    model_name='Test',\n    num_train_epochs=2,\n    learning_rate=4e-5,\n    learning_rate_end=5e-6,\n    optimizer=EasyDelOptimizers.ADAMW,\n    scheduler=EasyDelSchedulers.WARM_UP_COSINE,\n    weight_decay=0.01,\n    total_batch_size=32,\n    max_training_steps=None,\n    do_train=True,\n    do_eval=False,\n    backend='tpu',\n    max_sequence_length=max_sequence_length,\n    gradient_checkpointing=EasyDelGradientCheckPointers.NOTHING_SAVEABLE,\n    sharding_array=(1, -1, 1, 1),\n    use_pjit_attention_force=False,\n    gradient_accumulation_steps=8,\n    remove_ckpt_after_load=True,\n    ids_to_pop_from_dataset=['token_type_ids'],\n    loss_re_mat=\"\",\n    dtype=jnp.bfloat16\n)\n\ntrainer = CausalLanguageModelTrainer(\n    train_args,\n    dataset_train['train'],\n    checkpoint_path=None\n)\n\noutput = trainer.train(flax.core.FrozenDict({'params': params}))\n# And Here were EasyDel goes brrrrrr and start training \n</code></pre>"},{"location":"MosaicMPT/","title":"About MosaicMPT Models","text":"<p>MosaicMPT Models</p> <p>MosaicMPT Models is a family of large language models (LLMs) developed by MosaicML. The models are trained on a massive dataset of text and code, and can be used for a variety of tasks, including</p> <ul> <li>Natural language understanding (NLU)</li> <li>Natural language generation (NLG)</li> <li>Machine translation</li> <li>Text summarization</li> <li>Question answering</li> <li>Code generation</li> </ul> <p>The MosaicMPT models are available under the Apache 2.0 license, which means that they can be freely used, modified, and redistributed.</p> <p>Model Architecture</p> <p>The MosaicMPT models are based on the Transformer architecture, which is a neural network architecture that has been shown to be very effective for NLP tasks. The models are trained using a technique called masked language modeling, which involves predicting the missing words in a sequence of text.</p> <p>Model Sizes</p> <p>The MosaicMPT models come in a variety of sizes, ranging from 7 billion to 70 billion parameters. The larger models have more capacity to learn complex patterns in language, but they are also more computationally expensive to train and deploy.</p> <p>MosaicPretrainedTransformer (MPT) Architecture</p> <p>The MosaicPretrainedTransformer (MPT) architecture is a modified transformer architecture that is optimized for efficient training and inference. The MPT architecture includes the following changes:</p> <ul> <li>Performance-optimized layer implementations</li> <li>Architecture changes that provide greater training stability</li> <li>Elimination of context length limits by replacing positional embeddings with Attention with Linear Biases (ALiBi)</li> </ul> <p>Thanks to these modifications, MPT models can be trained with high throughput efficiency and stable convergence. MPT models can also be served efficiently with both standard HuggingFace pipelines and NVIDIA's FasterTransformer.</p> <p>Use Cases</p> <p>The MosaicMPT models can be used for a variety of tasks, including:</p> <ul> <li>Natural language understanding (NLU): The MosaicMPT models can be used to understand the meaning of text, such as   identifying the entities and relationships in a sentence.</li> <li>Natural language generation (NLG): The MosaicMPT models can be used to generate text, such as writing different kinds   of creative content, like poems, code, scripts, musical pieces, email, letters, etc.</li> <li>Machine translation: The MosaicMPT models can be used to translate text from one language to another.</li> <li>Text summarization: The MosaicMPT models can be used to summarize a text document into a shorter, more concise   version.</li> <li>Question answering: The MosaicMPT models can be used to answer questions about a text document.</li> <li>Code generation: The MosaicMPT models can be used to generate code, such as Python scripts or Java classes.</li> </ul> <p>Availability</p> <p>The MosaicMPT models are available through the Hugging Face Hub. The models are also available in the TensorFlow Hub, the PyTorch Hub and EasyDel.</p> <p>Conclusion</p> <p>The MosaicMPT models are a powerful family of LLMs that can be used for a variety of tasks. The models are open source and available for free, making them a valuable resource for researchers and developers.</p>"},{"location":"MosaicMPT/#how-to-useload-them-in-easydel","title":"How to Use/Load Them in EasyDel","text":""},{"location":"MosaicMPT/#open-an-issue-or-a-request-to-update-this-section","title":"Open an issue or a request to update this section","text":""},{"location":"PyTorchServer/","title":"PytorchServer","text":""},{"location":"PyTorchServer/#pytorchserver","title":"PyTorchServer \ud83e\uddec","text":"<p><code>PyTorchServer</code> is one of offered utilities by EasyDel, and it's help hosting using and doing process with LLMs and its also hackable, so you can override your own method in it and use it support both mid-level and high-level apis and also give you a Gradio Chat and Instruct Pre-build and ready to use page</p> <ul> <li>Supported Models are:<ul> <li>EveryModel that have <code>transformers.PretrainedModel</code> as their Parent :)</li> </ul> </li> </ul> <p>Documents are On The Way Amigos...</p>"},{"location":"generated-data_preprocessing-_processor/","title":"data_preprocessing._processor","text":""},{"location":"generated-etils-auto_tx/","title":"etils.auto_tx","text":""},{"location":"generated-etils-auto_tx/#lib.python.EasyDel.etils.auto_tx.get_optimizer_and_scheduler","title":"<code>get_optimizer_and_scheduler(optimizer, scheduler, steps, learning_rate=1e-05, learning_rate_end=1e-05, gradient_accumulation_steps=1, extra_optimizer_kwargs=None, weight_decay=0.02, warmup_steps=0)</code>","text":"<p>The get_optimizer_and_scheduler function is a helper function that returns an optimizer and scheduler     based on the parameters passed to it.</p> <p>Parameters:</p> Name Type Description Default <code>optimizer</code> <code>AVAILABLE_OPTIMIZERS</code> <p>AVAILABLE_OPTIMIZERS: Choose the optimizer</p> required <code>scheduler</code> <code>AVAILABLE_SCHEDULERS</code> <p>AVAILABLE_SCHEDULERS: Determine the learning rate scheduler</p> required <code>steps</code> <code>int</code> <p>int: Specify the number of steps in the training process</p> required <code>learning_rate</code> <code>float</code> <p>float: Set the learning rate for the optimizer</p> <code>1e-05</code> <code>learning_rate_end</code> <code>float</code> <p>float: Set the final learning rate</p> <code>1e-05</code> <code>gradient_accumulation_steps</code> <code>int</code> <p>int: Accumulate the gradients before updating the weights</p> <code>1</code> <code>extra_optimizer_kwargs</code> <code>dict | None</code> <p>dict | None: Pass extra arguments to the optimizer</p> <code>None</code> <code>weight_decay</code> <code>float</code> <p>float: Set the weight decay for adamw optimizer</p> <code>0.02</code> <code>warmup_steps</code> <code>int</code> <p>int: Specify the number of steps to warm up the learning rate</p> <code>0</code> <p>Returns:</p> Type Description <p>A tuple of two objects: (Optimizer and scheduler)</p> Source code in <code>lib/python/EasyDel/etils/auto_tx.py</code> <pre><code>def get_optimizer_and_scheduler(\n        optimizer: AVAILABLE_OPTIMIZERS,\n        scheduler: AVAILABLE_SCHEDULERS,\n        steps: int,\n        learning_rate: float = 1e-5,\n        learning_rate_end: float = 1e-5,\n        gradient_accumulation_steps: int = 1,\n        extra_optimizer_kwargs: dict | None = None,\n        weight_decay: float = 0.02,\n        warmup_steps: int = 0\n):\n    \"\"\"\n    The get_optimizer_and_scheduler function is a helper function that returns an optimizer and scheduler\n        based on the parameters passed to it.\n\n    :param optimizer: AVAILABLE_OPTIMIZERS: Choose the optimizer\n    :param scheduler: AVAILABLE_SCHEDULERS: Determine the learning rate scheduler\n    :param steps: int: Specify the number of steps in the training process\n    :param learning_rate: float: Set the learning rate for the optimizer\n    :param learning_rate_end: float: Set the final learning rate\n    :param gradient_accumulation_steps: int: Accumulate the gradients before updating the weights\n    :param extra_optimizer_kwargs: dict | None: Pass extra arguments to the optimizer\n    :param weight_decay: float: Set the weight decay for adamw optimizer\n    :param warmup_steps: int: Specify the number of steps to warm up the learning rate\n    :return: A tuple of two objects: (Optimizer and scheduler)\n    \"\"\"\n    if extra_optimizer_kwargs is None:\n        extra_optimizer_kwargs = {}\n    if optimizer == EasyDelOptimizers.ADAFACTOR:\n        if scheduler == EasyDelSchedulers.LINEAR:\n            tx, sc = fjformer.optimizers.get_adafactor_with_linear_scheduler(\n                learning_rate_start=learning_rate,\n                learning_rate_end=learning_rate_end,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                steps=steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.COSINE:\n            tx, sc = fjformer.optimizers.get_adafactor_with_cosine_scheduler(\n                learning_rate=learning_rate,\n                steps=steps,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.NONE:\n            tx, sc = fjformer.optimizers.get_adafactor_with_linear_scheduler(\n                learning_rate_start=learning_rate,\n                learning_rate_end=learning_rate,\n                steps=steps,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.WARM_UP_COSINE:\n            tx, sc = fjformer.optimizers.get_adafactor_with_warm_up_cosine_scheduler(\n                learning_rate=learning_rate,\n                steps=steps,\n                weight_decay=weight_decay,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.WARM_UP_LINEAR:\n            tx, sc = fjformer.optimizers.get_adafactor_with_warmup_linear_scheduler(\n                learning_rate_start=learning_rate,\n                steps=steps,\n                learning_rate_end=learning_rate_end,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                warmup_steps=warmup_steps,\n                **extra_optimizer_kwargs\n\n            )\n\n        else:\n            raise ValueError(\n                \"seems like you have choose wrong type or unavailable scheduler\"\n            )\n    elif optimizer == EasyDelOptimizers.LION:\n        if scheduler == EasyDelSchedulers.LINEAR:\n            tx, sc = fjformer.optimizers.get_lion_with_linear_scheduler(\n                learning_rate_start=learning_rate,\n                learning_rate_end=learning_rate_end,\n                steps=steps,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.COSINE:\n            tx, sc = fjformer.optimizers.get_lion_with_cosine_scheduler(\n                learning_rate=learning_rate,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                steps=steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.NONE:\n            tx, sc = fjformer.optimizers.get_lion_with_linear_scheduler(\n                learning_rate_start=learning_rate,\n                learning_rate_end=learning_rate,\n                steps=steps,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.WARM_UP_COSINE:\n            tx, sc = fjformer.optimizers.get_lion_with_warm_up_cosine_scheduler(\n                learning_rate=learning_rate,\n                steps=steps,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                **extra_optimizer_kwargs\n            )\n\n        elif scheduler == EasyDelSchedulers.WARM_UP_LINEAR:\n            tx, sc = fjformer.optimizers.get_lion_with_with_warmup_linear_scheduler(\n                learning_rate_start=learning_rate,\n                steps=steps,\n                learning_rate_end=learning_rate_end,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                warmup_steps=warmup_steps,\n                **extra_optimizer_kwargs\n            )\n        else:\n            raise ValueError(\n                \"seems like you have choose wrong type or unavailable scheduler\")\n    elif optimizer == EasyDelOptimizers.ADAMW:\n        if scheduler == EasyDelSchedulers.LINEAR:\n            tx, sc = fjformer.optimizers.get_adamw_with_linear_scheduler(\n                learning_rate_start=learning_rate,\n                learning_rate_end=learning_rate_end,\n                steps=steps,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.COSINE:\n            tx, sc = fjformer.optimizers.get_adamw_with_cosine_scheduler(\n                learning_rate=learning_rate,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                steps=steps,\n                weight_decay=weight_decay,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.NONE:\n            tx, sc = fjformer.optimizers.get_adamw_with_linear_scheduler(\n                learning_rate_start=learning_rate,\n                learning_rate_end=learning_rate,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                steps=steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.WARM_UP_COSINE:\n            tx, sc = fjformer.optimizers.get_adamw_with_warm_up_cosine_scheduler(\n                learning_rate=learning_rate,\n                steps=steps,\n                weight_decay=weight_decay,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                **extra_optimizer_kwargs\n            )\n        elif scheduler == EasyDelSchedulers.WARM_UP_LINEAR:\n            tx, sc = fjformer.optimizers.get_adamw_with_warmup_linear_scheduler(\n                learning_rate_start=learning_rate,\n                steps=steps,\n                weight_decay=weight_decay,\n                learning_rate_end=learning_rate_end,\n                gradient_accumulation_steps=gradient_accumulation_steps,\n                warmup_steps=warmup_steps,\n                **extra_optimizer_kwargs\n            )\n        else:\n            raise ValueError(\n                \"seems like you have choose wrong type or unavailable scheduler\"\n            )\n    else:\n        raise ValueError(\n            \"seems like you have choose wrong type or unavailable optimizer\"\n        )\n    return tx, sc\n</code></pre>"},{"location":"generated-etils-configs/","title":"etils.configs","text":""},{"location":"generated-etils-configs/#lib.python.EasyDel.etils.configs.get_config","title":"<code>get_config(model_type, struct)</code>","text":"<p>The get_config function takes in a model_type and struct, and returns the corresponding config.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>str: Determine which model to use</p> required <code>struct</code> <code>str</code> <p>str: Specify the structure of the model</p> required <p>Returns:</p> Type Description <p>A dictionary of hyperparameters</p> Source code in <code>lib/python/EasyDel/etils/configs.py</code> <pre><code>def get_config(model_type: str, struct: str):\n    \"\"\"\n    The get_config function takes in a model_type and struct, and returns the corresponding config.\n\n    :param model_type: str: Determine which model to use\n    :param struct: str: Specify the structure of the model\n    :return: A dictionary of hyperparameters\n\n    \"\"\"\n    if model_type == \"llama\":\n        return llama_configs[struct]\n    elif model_type == \"llama2\":\n        return llama_2_configs[struct]\n    elif model_type == \"opt\":\n        return opt_configs[struct]\n    elif model_type == \"gptj\":\n        return gptj_configs[struct]\n    elif model_type == \"falcon\":\n        return falcon_configs[struct]\n    elif model_type == \"mpt\":\n        return mpt_configs[struct]\n    else:\n        raise ValueError(f\"Unknown ModelType : {model_type}\")\n</code></pre>"},{"location":"generated-etils-easystate/","title":"etils.easystate","text":""},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState","title":"<code>EasyDelState</code>","text":"<p>             Bases: <code>PyTreeNode</code></p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>class EasyDelState(struct.PyTreeNode):\n    step: int\n    module: Optional[EasyDelFlaxPretrainedModel] = struct.field(pytree_node=False)\n    module_config: Optional[EasyDelPretrainedConfig] = struct.field(pytree_node=False)\n    module_config_args: Optional[dict] = struct.field(pytree_node=True)\n    apply_fn: Callable = struct.field(pytree_node=False)\n    params: core.FrozenDict[str, Any] = struct.field(pytree_node=True)\n    tx: optax.GradientTransformation = struct.field(pytree_node=False)\n    opt_state: Optional[optax.OptState] = struct.field(pytree_node=True)\n    tx_init: Optional[dict] = struct.field(pytree_node=True)\n    hyperparameters: Optional[dict] = struct.field(pytree_node=True)\n\n    def apply_gradients(self, *, grads, **kwargs):\n\n        \"\"\"\n        The apply_gradients function is the core of the optimizer. It takes in a dictionary of gradients,\n        and returns an updated version of itself with new parameters and state. The function also updates\n        the step count.\n\n        :param self: Refer to the current instance of the class\n        :param *: Unpack the grads dictionary into positional arguments\n        :param grads: Pass in the gradients of the loss function with respect to each parameter\n        :param kwargs: Pass in additional arguments to the function\n        :return: A new State with the updated parameters and params\n        \"\"\"\n        if OVERWRITE_WITH_GRADIENT in grads:\n            grads_with_opt = grads['params']\n            params_with_opt = self.params['params']\n        else:\n            grads_with_opt = grads\n            params_with_opt = self.params\n\n        updates, new_opt_state = self.tx.update(\n            grads_with_opt, self.opt_state, params_with_opt\n        )\n        new_params_with_opt = optax.apply_updates(params_with_opt, updates)\n        if OVERWRITE_WITH_GRADIENT in grads:\n            new_params = {\n                'params': new_params_with_opt,\n                OVERWRITE_WITH_GRADIENT: grads[OVERWRITE_WITH_GRADIENT]\n            }\n        else:\n            new_params = new_params_with_opt\n        return self.replace(\n            step=self.step + 1,\n            params=new_params,\n            opt_state=new_opt_state,\n            **kwargs,\n        )\n\n    @classmethod\n    def create(\n            cls,\n            *,\n            apply_fn: Callable,\n            params: core.FrozenDict[str, Any] | Mapping[str, Any],\n            tx: optax.GradientTransformation,\n            tx_init: Optional[dict] = None,\n            hyperparameters: Optional[dict] = None,\n            module: Optional[EasyDelFlaxPretrainedModel] = None,\n            module_config: Optional[EasyDelPretrainedConfig] = None,\n            module_config_args: Optional[dict] = None,\n            **kwargs\n    ):\n\n        \"\"\"\n        The create function is used to create a new instance of the class.\n\n        :param cls: Create a new instance of the class\n        :param *: Pass a list of parameters to the function\n        :param apply_fn: Callable: Apply the model to a batch of data\n        :param params: core.FrozenDict[str,Any] | Mapping[str,Any]: Pass in the parameters of the model\n        :param tx: optax.GradientTransformation: Initialize the optimizer\n        :param tx_init: Optional[dict]: Initialize the optimizer\n        :param hyperparameters: Optional[dict]: Pass hyperparameters to the state for init\n        :param module: Optional[EasyDelFlaxPretrainedModel]: Pass the module to be used int state\n        :param module_config: Optional[EasyDelPretrainedConfig]: Pass in the module config\n        :param module_config_args: Optional[dict]: Store the config args of the model\n        :param kwargs: Pass in additional parameters to the\n        :return: A EasyDelState object\n        \"\"\"\n        if hyperparameters is None:\n            hyperparameters = {}\n        params_with_opt = (\n            params['params'] if OVERWRITE_WITH_GRADIENT in params else params\n        )\n        opt_state = tx.init(params_with_opt)\n        if module_config is not None:\n            module_config = copy.deepcopy(module_config)\n            cls.safe_dict(module_config.__dict__)\n        return cls(\n            step=0,\n            apply_fn=apply_fn,\n            module=module,\n            params=params,\n            tx=tx,\n            opt_state=opt_state,\n            tx_init=cls.safe_dict(tx_init),\n            hyperparameters=hyperparameters,\n            module_config=module_config,\n            module_config_args=None,\n            **kwargs,\n        )\n\n    @classmethod\n    def load(\n            cls,\n            *,\n            apply_fn: Callable,\n            params: core.FrozenDict[str, Any] | Mapping[str, Any],\n            step: int = 0,\n            opt_state: Optional[optax.OptState] = None,\n            tx_init: Optional[dict] = None,\n            hyperparameters: Optional[dict] = None,\n            module: Optional[EasyDelFlaxPretrainedModel] = None,\n            module_config: Optional[EasyDelPretrainedConfig] = None,\n            module_config_args: Optional[dict] = None,\n            **kwargs\n    ):\n\n        \"\"\"\n        The load function is used to load a saved state of the Model and optimizer or Model Only.\n\n        :param cls: Make the function a class method\n        :param *: Pass in a variable number of arguments\n        :param step: int: Keep track of the number of steps that have been taken\n        :param apply_fn: Callable: Apply the optimizer to the model\n        :param params: core.FrozenDict[str,Any] | Mapping[str,Any]: Pass in the parameters of the model\n        :param opt_state: Optional[optax.OptState]: optimizer state\n        :param tx_init: Optional[dict]: Pass the hyperparameters to the optimizer\n        :param hyperparameters: Optional[dict]: Load hyperparameters from the state dict\n        :param module: Optional[EasyDelFlaxPretrainedModel]: Pass in the module\n        :param module_config: Optional[EasyDelPretrainedConfig]: Pass the module config\n        :param module_config_args: Optional[dict]: Pass the config_args to the model\n        :param kwargs: Pass in any additional parameters that may be needed for the model\n        :return: A new instance of the class\n        \"\"\"\n        if module_config is not None:\n            module_config = copy.deepcopy(module_config)\n\n        if tx_init is None:\n            tx_init = {}\n        tx_init = copy.deepcopy(tx_init)\n        tx_init = cls.unsafe_dict(tx_init)\n\n        tx_init[\"optimizer\"] = cls.search(\"optimizer\", tx_init, \"admaw\")\n        tx_init[\"scheduler\"] = cls.search(\"scheduler\", tx_init, \"none\")\n        tx_init[\"steps\"] = cls.search(\"steps\", tx_init, 1e6)\n        try:\n            tx, sc = get_optimizer_and_scheduler(\n                **tx_init\n            )\n        except TypeError:\n            termcolor.cprint(\n                \"Couldn't load past optimizer State initializing new one with default Optimizer and Scheduler\",\n                color=\"red\", force_color=True\n            )\n            tx, sc = get_optimizer_and_scheduler(\n                optimizer=\"adamw\",\n                scheduler=\"none\",\n                steps=10000,\n            )\n        if hyperparameters is None:\n            hyperparameters = {}\n\n        if module_config is not None:\n            hyperparameters = cls.create_hyperparameters(module_config.model_type)\n            cls.safe_dict(module_config.__dict__)\n\n        return cls(\n            step=step,\n            apply_fn=apply_fn,\n            params=params,\n            tx=tx,\n            opt_state=opt_state,\n            tx_init=cls.safe_dict(tx_init),\n            hyperparameters=hyperparameters,\n            module=module,\n            module_config=module_config,\n            module_config_args=None,\n            **kwargs,\n        )\n\n    @classmethod\n    def load_state(\n            cls,\n            checkpoint_path: str | os.PathLike,\n            init_optimizer_state: bool = False,\n            state_shard_fns: Optional[Mapping[str, Callable]] = None,\n            verbose: bool = False\n    ):\n\n        \"\"\"    \n        The load_state function is a class method that loads the state of an EasyDelModel from a checkpoint.\n\n        :param cls: Create an instance of the class\n        :param checkpoint_path: str | os.PathLike: Specify the path to the checkpoint file\n        :param init_optimizer_state: bool: Initialize the optimizer if it's not Initialized yet (if it Initialized the option\n        will be ignored )\n        :param state_shard_fns: Optional[Mapping[str,Callable]]: Specify the function that will be used \n        to shard the loaded state\n        :param verbose: bool: Print out the progress of loading\n        :return: A state object\n        \"\"\"\n        from ..modules.auto_easydel_model import get_modules_by_type\n\n        checkpoint = fjformer.CheckpointManager.load_checkpoint(\n            path=checkpoint_path,\n            shard_fns=state_shard_fns,\n            verbose=verbose,\n        )\n\n        hyperparameters = checkpoint.get(\"hyperparameters\")\n        cfg, module, convertor = get_modules_by_type(model_type=cls.get_model_type(hyperparameters))\n        module_config = checkpoint.pop(\"module_config\", None)\n        if checkpoint[\"module_config_args\"] is not None:\n            module_config = cfg.from_dict(checkpoint.get(\"module_config_args\", {}))\n\n        state = cls.load(\n            apply_fn=module.__call__,\n            module=module,\n            module_config=module_config,\n            **checkpoint\n        )\n        state = state.replace(\n            module_config_args=None  # removing because it's not needed anymore\n        )\n        if init_optimizer_state:\n            state = state.init_opt_state()\n        return state\n\n    @classmethod\n    def get_model_type(cls, dictionary):\n        return cls.find_key(\"model_type\", dictionary)\n\n    def save_state(\n            self,\n            filename: str | os.PathLike,\n            save_optimizer: bool = False,\n            checkpoint_dir: Optional[str | os.PathLike] = None,\n            verbose: bool = False,\n            gather_fns: dict[Callable] = None,\n            float_dtype: str | jax.numpy.dtype = None,\n    ):\n\n        \"\"\"\n        The save_state function saves the state of a model to disk.\n\n        :param self: Pass the object itself to the function\n        :param filename: str | os.PathLike: Specify the name of the file to save\n        :param save_optimizer: bool: Determine whether to save the optimizer state or not\n        :param checkpoint_dir: Optional[str | os.PathLike]: Specify the directory where the checkpoint is saved\n        :param verbose: bool: Print out the path of the saved file\n        :param gather_fns: dict[Callable]: Specify a dictionary of functions that can be used to gather\n        :param float_dtype: str | jax.numpy.dtype: Specify the precision of the saved model\n        :param : Save the optimizer state\n        :return: None\n        \"\"\"\n        state = self\n        if not save_optimizer:\n            state = self.replace(\n                opt_state=None\n            )\n        fjformer.CheckpointManager.save_state_to_file(\n            state=state,\n            path=os.path.join(checkpoint_dir, filename) if checkpoint_dir is not None else filename,\n            verbose=verbose,\n            gather_fns=gather_fns,\n            float_dtype=float_dtype,\n        )\n\n    def free_opt_state(self) -&gt; \"EasyDelState\":\n\n        \"\"\"\n        The free_opt_state function is used to free the memory allocated by a previous call to setopt.\n        It should be called after all the options have been set, and before you perform any of the transfers.\n\n\n        :param self: Represent the instance of the class\n        :return: A new state with the opt_state field set to none\n        \"\"\"\n        return self.replace(\n            opt_state=None\n        )\n\n    def init_opt_state(self) -&gt; \"EasyDelState\":\n\n        \"\"\"\n        The init_opt_state function initializes the optimizer state.\n        :param self: Make the object callable, and params is used to pass in a dictionary of parameters\n        :return: A new instance of the class with opt_state initialized\n        \"\"\"\n        if self.opt_state is None:\n            params_with_opt = (\n                self.params['params'] if OVERWRITE_WITH_GRADIENT in self.params else self.params\n            )\n            opt_state = self.tx.init(params_with_opt)\n\n            return self.replace(\n                opt_state=opt_state\n            )\n        return self\n\n    @classmethod\n    def from_pretrained(\n            cls,\n            pretrained_model_name_or_path: str,\n            filename: Optional[str] = None,\n            optimizer: AVAILABLE_OPTIMIZERS = \"adamw\",\n            scheduler: AVAILABLE_SCHEDULERS = \"none\",\n            tx_init: Optional[dict] = None,\n            device=jax.devices('cpu')[0],\n            dtype: jax.numpy.dtype = jax.numpy.float32,\n            param_dtype: jax.numpy.dtype = jax.numpy.float32,\n            precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\"),\n            sharding_axis_dims: Sequence[int] = (1, -1, 1, 1),\n            sharding_axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n            query_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                          None),\n            key_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                        None),\n            value_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                          None),\n            bias_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), None, None,\n                                                                                         None),\n            attention_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\",\n                                                                                              \"tp\", None),\n            use_shard_map: bool = False,\n            input_shape: Sequence[int] = (1, 1),\n            backend: Optional[str] = None,\n            init_optimizer_state: bool = False,\n            free_optimizer_state: bool = True,\n            verbose: bool = True,\n            state_shard_fns: Optional[Mapping[str, Callable]] = None,\n            **kwargs\n    ) -&gt; \"EasyDelState\":\n\n        \"\"\"\n        The from_pretrained function is a helper function to quickly load a pretrained model and its associated configuration.\n        This method takes care of returning the correct model class instance based on the `model_type` property in the\n        config object, or when it's missing, falling back to using pattern matching on the\n         `pretrained_model_name_or_path` string:\n\n        :param cls: Refer to the class that is being defined\n        :param pretrained_model_name_or_path: str: Load the pretrained model\n        :param filename: Optional[str]: Specify the name of the file to download from huggingface hub\n        :param optimizer: AVAILABLE_OPTIMIZERS: Specify the optimizer used for training\n        :param scheduler: AVAILABLE_SCHEDULERS: Specify the name of the scheduler to use\n        :param tx_init: Optional[dict]: Pass the hyperparameters of the optimizer\n        :param device: Specify the device on which to run the model\n        :param dtype: jax.numpy.dtype: Specify the dtype of the model parameters\n        :param param_dtype: jax.numpy.dtype: Specify the data type of the parameters\n        :param precision: jax.lax.Precision: Control the precision of the calculation\n        :param sharding_axis_dims: Sequence[int]: Specify the dimension of each axis\n        :param sharding_axis_names: Sequence[str]: Specify the names of the axes in each shard\n        :param query_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the query matrix\n        :param key_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the key matrix\n        :param value_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the value tensor\n        :param bias_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the bias\n        :param attention_partition_spec: jax.sharding.PartitionSpec: Partition the attention weights\n        :param use_shard_map: bool: Determine whether to use shard_map or not\n        :param input_shape: Sequence[int]: Specify the shape of the input to be used for training\n        :param backend: Optional[str]: Specify the backend used for the model\n        :param init_optimizer_state: bool: Initialize the optimizer state\n        :param free_optimizer_state: bool: Free the optimizer state from memory\n        :param verbose: bool: Print the progress of loading the model\n        :param state_shard_fns: Optional[Mapping[str,Callable]]: Specify the function to use for sharding the state\n        :param kwargs: Pass keyword arguments to the function\n        :return: An `EasyDelState` object\n        \"\"\"\n        if free_optimizer_state and init_optimizer_state:\n            raise EasyDelRuntimeError(\n                \"You can't use `free_optimizer_state` and `init_optimizer_state` True at same Time\"\n            )\n\n        if filename is None:\n            from ..modules.auto_easydel_model import AutoEasyDelModelForCausalLM\n\n            model, params = AutoEasyDelModelForCausalLM.from_pretrained(\n                pretrained_model_name_or_path,\n                device=device,\n                dtype=dtype,\n                param_dtype=param_dtype,\n                precision=precision,\n                sharding_axis_dims=sharding_axis_dims,\n                sharding_axis_names=sharding_axis_names,\n                query_partition_spec=query_partition_spec,\n                key_partition_spec=key_partition_spec,\n                value_partition_spec=value_partition_spec,\n                bias_partition_spec=bias_partition_spec,\n                attention_partition_spec=attention_partition_spec,\n                use_shard_map=use_shard_map,\n                input_shape=input_shape,\n                backend=backend,\n                **kwargs\n            )\n            if tx_init is None:\n                tx_init = {}\n\n            tx_init[\"optimizer\"] = optimizer\n            tx_init[\"scheduler\"] = scheduler\n\n            state = cls.load(\n                apply_fn=model.__call__,\n                params=FrozenDict({'params': params}),\n                step=0,\n                opt_state=None,\n                tx_init=tx_init,\n                hyperparameters=None,\n                module=model,\n                module_config=model.config,\n                module_config_args=model.config.to_dict()\n            )\n        else:\n            with jax.default_device(device):\n                from huggingface_hub import hf_hub_download\n                checkpoint_path = hf_hub_download(\n                    repo_id=pretrained_model_name_or_path,\n                    filename=filename,\n                )\n                state = cls.load_state(\n                    checkpoint_path=checkpoint_path,\n                    init_optimizer_state=init_optimizer_state,\n                    verbose=verbose,\n                    state_shard_fns=state_shard_fns\n                )\n        if init_optimizer_state:\n            with jax.default_device(device):\n                state = state.init_opt_state()\n        if free_optimizer_state:\n            state = state.free_opt_state()\n        return state\n\n    def shard_params(\n            self,\n            fully_sharded_data_parallel: bool = True,\n            shard_fns: Optional[Mapping[str, Callable]] = None,\n            dtype: jax.numpy.dtype | str = \"bf16\",\n            mesh: Optional[jax.sharding.Mesh] = None,\n            rules: Optional[Sequence[Mapping[str, jax.sharding.PartitionSpec]]] = None\n    ):\n        dtype = fjformer.get_dtype(dtype)\n        if shard_fns is None and self.module_config is None and rules is None:\n            raise EasyDelRuntimeError(\n                \"the model doesn't carrying `module_config` you should pass `shard_fns` or `rules`\"\n            )\n        elif shard_fns is None and rules is not None or self.module_config is not None:\n            from fjformer import match_partition_rules, make_shard_and_gather_fns\n            rules = rules or self.module_config.get_partition_rules(fully_sharded_data_parallel)\n            partition_specs = match_partition_rules(\n                rules=rules, params=self.params\n            )\n            shard_fns, gather_fns = make_shard_and_gather_fns(\n                partition_specs=partition_specs,\n                dtype_specs=dtype\n            )\n        if mesh is None:\n            mesh = self.module_config.jax_mesh()\n        with mesh:\n            return self.replace(\n                params=jax.tree_util.tree_map(\n                    lambda f, p: f(p), shard_fns, self.params\n                )\n            )\n\n    @staticmethod\n    def create_hyperparameters(model_type: str):\n        \"\"\"\n        it's the only way we can dump xla compiler\n        \"\"\"\n        return {\n            STRING_REP.format(\n                type=\"str\",\n                key=\"model_type\",\n                value=model_type\n            ): DEFAULT_ES_VAL\n        }\n\n    @staticmethod\n    def safe_dict(dictionary: dict):\n        for k in list(dictionary.keys()):\n            val = dictionary.get(k)\n            if not isinstance(val, (int, bool)):\n                val = dictionary.pop(k)\n                string_value_format = STRING_REP.format(\n                    type=type(val).__name__,\n                    key=k,\n                    value=val\n                )\n                dictionary[string_value_format] = DEFAULT_ES_VAL\n        return dictionary\n\n    @staticmethod\n    def unsafe_dict(dictionary: dict):\n        result = {}\n        for k in list(dictionary.keys()):\n            v = dictionary[k]\n            key, value = break_format(key=k, value=v)\n            result[key] = value\n        return result\n\n    def __str__(self):\n\n        \"\"\"\n        The __str__ function is called when you call str(object) or print(object).\n        The __repr__ function is called when you type the object name in the interpreter.\n        If no __str__ method exists, Python will use __repr__ as a fallback.\n\n        :param self: Refer to the object itself\n        :return: string\n        \"\"\"\n        params_size = sum(getattr(n, \"size\", 0) for n in jax.tree_util.tree_flatten(self.params)[0])\n        opt_state_size = sum(getattr(n, \"size\", 0) for n in jax.tree_util.tree_flatten(self.opt_state)[0])\n\n        def make_depth(mdl=None):\n            if mdl is not None:\n                return mdl.__str__().replace(\n                    \"\\n\",\n                    \"\\n\\t\"\n                    \"\"\n                ) if hasattr(mdl, \"__str__\") else None\n\n            return mdl\n\n        optimizer = self.tx_init.get(\"optimizer\", None)\n        scheduler = self.tx_init.get(\"scheduler\", None)\n\n        if optimizer is None:\n            optimizer = self.find_key(\n                \"optimizer\",\n                self.tx_init\n            )\n        if scheduler is None:\n            scheduler = self.find_key(\n                \"scheduler\",\n                self.tx_init\n            )\n\n        string = (\n            f\"{self.__class__.__name__}(\"\n            f\"\\n\\tstep = {self.step}\"\n            f\"\\n\\tmodule = {make_depth(self.module)}\"\n            f\"\\n\\tmodule_config = {make_depth(self.module_config)}\"\n            f\"\\n\\tapply_fn: Callable = {make_depth(self.apply_fn)}\"\n            f\"\\n\\tparams : {params_size} Parameters\"\n            f\"\\n\\ttx = {optimizer} Optimizer with {scheduler} Scheduler\"\n            f\"\\n\\topt_state : {opt_state_size} Parameters\"\n            f\"\\n\\thyperparameters : {self.hyperparameters}\"\n            f\"\\n)\"\n        )\n        return string\n\n    @classmethod\n    def search(cls, key, dictionary: dict, default: Any = None):\n        req = dictionary.get(key, None)\n        if req is None:\n            req = cls.find_key(key, dictionary)\n        return req or default\n\n    @staticmethod\n    def find_key(key, dictionary: dict) -&gt; str | None:\n        result = None\n        for k, v in dictionary.items():\n            k_, v_ = break_format(key=k, value=v)\n            if k_ == key:\n                result = v_\n                break\n        return result\n\n    def __repr__(self):\n\n        \"\"\"\n        The __repr__ function is the &amp;quot;official&amp;quot; string representation of an object.\n        It's what you get when you type the object name at the Python prompt, or pass it to str().\n        The goal of __repr__ is to be unambiguous: if eval(repr(x)) == x, then __repr__ should return a string that\n        looks like a valid Python expression that could be used to recreate an object with the same value (\n        given an appropriate environment). If this is not possible, a string formatted using %s\n        formatting is also acceptable.\n\n        :param self: Represent the instance of the class\n        :return: A string that is a valid python expression\n        \"\"\"\n        return self.__str__()\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.__repr__","title":"<code>__repr__()</code>","text":"<p>The repr function is the \"official\" string representation of an object. It's what you get when you type the object name at the Python prompt, or pass it to str(). The goal of repr is to be unambiguous: if eval(repr(x)) == x, then repr should return a string that looks like a valid Python expression that could be used to recreate an object with the same value ( given an appropriate environment). If this is not possible, a string formatted using %s formatting is also acceptable.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A string that is a valid python expression</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>def __repr__(self):\n\n    \"\"\"\n    The __repr__ function is the &amp;quot;official&amp;quot; string representation of an object.\n    It's what you get when you type the object name at the Python prompt, or pass it to str().\n    The goal of __repr__ is to be unambiguous: if eval(repr(x)) == x, then __repr__ should return a string that\n    looks like a valid Python expression that could be used to recreate an object with the same value (\n    given an appropriate environment). If this is not possible, a string formatted using %s\n    formatting is also acceptable.\n\n    :param self: Represent the instance of the class\n    :return: A string that is a valid python expression\n    \"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.__str__","title":"<code>__str__()</code>","text":"<p>The str function is called when you call str(object) or print(object). The repr function is called when you type the object name in the interpreter. If no str method exists, Python will use repr as a fallback.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <p>Returns:</p> Type Description <p>string</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>def __str__(self):\n\n    \"\"\"\n    The __str__ function is called when you call str(object) or print(object).\n    The __repr__ function is called when you type the object name in the interpreter.\n    If no __str__ method exists, Python will use __repr__ as a fallback.\n\n    :param self: Refer to the object itself\n    :return: string\n    \"\"\"\n    params_size = sum(getattr(n, \"size\", 0) for n in jax.tree_util.tree_flatten(self.params)[0])\n    opt_state_size = sum(getattr(n, \"size\", 0) for n in jax.tree_util.tree_flatten(self.opt_state)[0])\n\n    def make_depth(mdl=None):\n        if mdl is not None:\n            return mdl.__str__().replace(\n                \"\\n\",\n                \"\\n\\t\"\n                \"\"\n            ) if hasattr(mdl, \"__str__\") else None\n\n        return mdl\n\n    optimizer = self.tx_init.get(\"optimizer\", None)\n    scheduler = self.tx_init.get(\"scheduler\", None)\n\n    if optimizer is None:\n        optimizer = self.find_key(\n            \"optimizer\",\n            self.tx_init\n        )\n    if scheduler is None:\n        scheduler = self.find_key(\n            \"scheduler\",\n            self.tx_init\n        )\n\n    string = (\n        f\"{self.__class__.__name__}(\"\n        f\"\\n\\tstep = {self.step}\"\n        f\"\\n\\tmodule = {make_depth(self.module)}\"\n        f\"\\n\\tmodule_config = {make_depth(self.module_config)}\"\n        f\"\\n\\tapply_fn: Callable = {make_depth(self.apply_fn)}\"\n        f\"\\n\\tparams : {params_size} Parameters\"\n        f\"\\n\\ttx = {optimizer} Optimizer with {scheduler} Scheduler\"\n        f\"\\n\\topt_state : {opt_state_size} Parameters\"\n        f\"\\n\\thyperparameters : {self.hyperparameters}\"\n        f\"\\n)\"\n    )\n    return string\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.apply_gradients","title":"<code>apply_gradients(*, grads, **kwargs)</code>","text":"<p>The apply_gradients function is the core of the optimizer. It takes in a dictionary of gradients, and returns an updated version of itself with new parameters and state. The function also updates the step count.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the current instance of the class</p> required <code>*</code> <p>Unpack the grads dictionary into positional arguments</p> required <code>grads</code> <p>Pass in the gradients of the loss function with respect to each parameter</p> required <code>kwargs</code> <p>Pass in additional arguments to the function</p> <code>{}</code> <p>Returns:</p> Type Description <p>A new State with the updated parameters and params</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>def apply_gradients(self, *, grads, **kwargs):\n\n    \"\"\"\n    The apply_gradients function is the core of the optimizer. It takes in a dictionary of gradients,\n    and returns an updated version of itself with new parameters and state. The function also updates\n    the step count.\n\n    :param self: Refer to the current instance of the class\n    :param *: Unpack the grads dictionary into positional arguments\n    :param grads: Pass in the gradients of the loss function with respect to each parameter\n    :param kwargs: Pass in additional arguments to the function\n    :return: A new State with the updated parameters and params\n    \"\"\"\n    if OVERWRITE_WITH_GRADIENT in grads:\n        grads_with_opt = grads['params']\n        params_with_opt = self.params['params']\n    else:\n        grads_with_opt = grads\n        params_with_opt = self.params\n\n    updates, new_opt_state = self.tx.update(\n        grads_with_opt, self.opt_state, params_with_opt\n    )\n    new_params_with_opt = optax.apply_updates(params_with_opt, updates)\n    if OVERWRITE_WITH_GRADIENT in grads:\n        new_params = {\n            'params': new_params_with_opt,\n            OVERWRITE_WITH_GRADIENT: grads[OVERWRITE_WITH_GRADIENT]\n        }\n    else:\n        new_params = new_params_with_opt\n    return self.replace(\n        step=self.step + 1,\n        params=new_params,\n        opt_state=new_opt_state,\n        **kwargs,\n    )\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.create","title":"<code>create(*, apply_fn, params, tx, tx_init=None, hyperparameters=None, module=None, module_config=None, module_config_args=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>The create function is used to create a new instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>Create a new instance of the class</p> required <code>*</code> <p>Pass a list of parameters to the function</p> required <code>apply_fn</code> <code>Callable</code> <p>Callable: Apply the model to a batch of data</p> required <code>params</code> <code>FrozenDict[str, Any] | Mapping[str, Any]</code> <p>core.FrozenDict[str,Any] | Mapping[str,Any]: Pass in the parameters of the model</p> required <code>tx</code> <code>GradientTransformation</code> <p>optax.GradientTransformation: Initialize the optimizer</p> required <code>tx_init</code> <code>Optional[dict]</code> <p>Optional[dict]: Initialize the optimizer</p> <code>None</code> <code>hyperparameters</code> <code>Optional[dict]</code> <p>Optional[dict]: Pass hyperparameters to the state for init</p> <code>None</code> <code>module</code> <code>Optional[EasyDelFlaxPretrainedModel]</code> <p>Optional[EasyDelFlaxPretrainedModel]: Pass the module to be used int state</p> <code>None</code> <code>module_config</code> <code>Optional[EasyDelPretrainedConfig]</code> <p>Optional[EasyDelPretrainedConfig]: Pass in the module config</p> <code>None</code> <code>module_config_args</code> <code>Optional[dict]</code> <p>Optional[dict]: Store the config args of the model</p> <code>None</code> <code>kwargs</code> <p>Pass in additional parameters to the</p> <code>{}</code> <p>Returns:</p> Type Description <p>A EasyDelState object</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>@classmethod\ndef create(\n        cls,\n        *,\n        apply_fn: Callable,\n        params: core.FrozenDict[str, Any] | Mapping[str, Any],\n        tx: optax.GradientTransformation,\n        tx_init: Optional[dict] = None,\n        hyperparameters: Optional[dict] = None,\n        module: Optional[EasyDelFlaxPretrainedModel] = None,\n        module_config: Optional[EasyDelPretrainedConfig] = None,\n        module_config_args: Optional[dict] = None,\n        **kwargs\n):\n\n    \"\"\"\n    The create function is used to create a new instance of the class.\n\n    :param cls: Create a new instance of the class\n    :param *: Pass a list of parameters to the function\n    :param apply_fn: Callable: Apply the model to a batch of data\n    :param params: core.FrozenDict[str,Any] | Mapping[str,Any]: Pass in the parameters of the model\n    :param tx: optax.GradientTransformation: Initialize the optimizer\n    :param tx_init: Optional[dict]: Initialize the optimizer\n    :param hyperparameters: Optional[dict]: Pass hyperparameters to the state for init\n    :param module: Optional[EasyDelFlaxPretrainedModel]: Pass the module to be used int state\n    :param module_config: Optional[EasyDelPretrainedConfig]: Pass in the module config\n    :param module_config_args: Optional[dict]: Store the config args of the model\n    :param kwargs: Pass in additional parameters to the\n    :return: A EasyDelState object\n    \"\"\"\n    if hyperparameters is None:\n        hyperparameters = {}\n    params_with_opt = (\n        params['params'] if OVERWRITE_WITH_GRADIENT in params else params\n    )\n    opt_state = tx.init(params_with_opt)\n    if module_config is not None:\n        module_config = copy.deepcopy(module_config)\n        cls.safe_dict(module_config.__dict__)\n    return cls(\n        step=0,\n        apply_fn=apply_fn,\n        module=module,\n        params=params,\n        tx=tx,\n        opt_state=opt_state,\n        tx_init=cls.safe_dict(tx_init),\n        hyperparameters=hyperparameters,\n        module_config=module_config,\n        module_config_args=None,\n        **kwargs,\n    )\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.create_hyperparameters","title":"<code>create_hyperparameters(model_type)</code>  <code>staticmethod</code>","text":"<p>it's the only way we can dump xla compiler</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>@staticmethod\ndef create_hyperparameters(model_type: str):\n    \"\"\"\n    it's the only way we can dump xla compiler\n    \"\"\"\n    return {\n        STRING_REP.format(\n            type=\"str\",\n            key=\"model_type\",\n            value=model_type\n        ): DEFAULT_ES_VAL\n    }\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.free_opt_state","title":"<code>free_opt_state()</code>","text":"<p>The free_opt_state function is used to free the memory allocated by a previous call to setopt. It should be called after all the options have been set, and before you perform any of the transfers.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <code>EasyDelState</code> <p>A new state with the opt_state field set to none</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>def free_opt_state(self) -&gt; \"EasyDelState\":\n\n    \"\"\"\n    The free_opt_state function is used to free the memory allocated by a previous call to setopt.\n    It should be called after all the options have been set, and before you perform any of the transfers.\n\n\n    :param self: Represent the instance of the class\n    :return: A new state with the opt_state field set to none\n    \"\"\"\n    return self.replace(\n        opt_state=None\n    )\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.from_pretrained","title":"<code>from_pretrained(pretrained_model_name_or_path, filename=None, optimizer='adamw', scheduler='none', tx_init=None, device=jax.devices('cpu')[0], dtype=jax.numpy.float32, param_dtype=jax.numpy.float32, precision=jax.lax.Precision('fastest'), sharding_axis_dims=(1, -1, 1, 1), sharding_axis_names=('dp', 'fsdp', 'tp', 'sp'), query_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), key_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), value_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), bias_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), None, None, None), attention_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), use_shard_map=False, input_shape=(1, 1), backend=None, init_optimizer_state=False, free_optimizer_state=True, verbose=True, state_shard_fns=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>The from_pretrained function is a helper function to quickly load a pretrained model and its associated configuration. This method takes care of returning the correct model class instance based on the <code>model_type</code> property in the config object, or when it's missing, falling back to using pattern matching on the  <code>pretrained_model_name_or_path</code> string:</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>Refer to the class that is being defined</p> required <code>pretrained_model_name_or_path</code> <code>str</code> <p>str: Load the pretrained model</p> required <code>filename</code> <code>Optional[str]</code> <p>Optional[str]: Specify the name of the file to download from huggingface hub</p> <code>None</code> <code>optimizer</code> <code>AVAILABLE_OPTIMIZERS</code> <p>AVAILABLE_OPTIMIZERS: Specify the optimizer used for training</p> <code>'adamw'</code> <code>scheduler</code> <code>AVAILABLE_SCHEDULERS</code> <p>AVAILABLE_SCHEDULERS: Specify the name of the scheduler to use</p> <code>'none'</code> <code>tx_init</code> <code>Optional[dict]</code> <p>Optional[dict]: Pass the hyperparameters of the optimizer</p> <code>None</code> <code>device</code> <p>Specify the device on which to run the model</p> <code>devices('cpu')[0]</code> <code>dtype</code> <code>dtype</code> <p>jax.numpy.dtype: Specify the dtype of the model parameters</p> <code>float32</code> <code>param_dtype</code> <code>dtype</code> <p>jax.numpy.dtype: Specify the data type of the parameters</p> <code>float32</code> <code>precision</code> <code>Optional[Precision]</code> <p>jax.lax.Precision: Control the precision of the calculation</p> <code>Precision('fastest')</code> <code>sharding_axis_dims</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the dimension of each axis</p> <code>(1, -1, 1, 1)</code> <code>sharding_axis_names</code> <code>Sequence[str]</code> <p>Sequence[str]: Specify the names of the axes in each shard</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>query_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the query matrix</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>key_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the key matrix</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>value_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the value tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>bias_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the bias</p> <code>PartitionSpec(('dp', 'fsdp'), None, None, None)</code> <code>attention_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Partition the attention weights</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>use_shard_map</code> <code>bool</code> <p>bool: Determine whether to use shard_map or not</p> <code>False</code> <code>input_shape</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the shape of the input to be used for training</p> <code>(1, 1)</code> <code>backend</code> <code>Optional[str]</code> <p>Optional[str]: Specify the backend used for the model</p> <code>None</code> <code>init_optimizer_state</code> <code>bool</code> <p>bool: Initialize the optimizer state</p> <code>False</code> <code>free_optimizer_state</code> <code>bool</code> <p>bool: Free the optimizer state from memory</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>bool: Print the progress of loading the model</p> <code>True</code> <code>state_shard_fns</code> <code>Optional[Mapping[str, Callable]]</code> <p>Optional[Mapping[str,Callable]]: Specify the function to use for sharding the state</p> <code>None</code> <code>kwargs</code> <p>Pass keyword arguments to the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>EasyDelState</code> <p>An <code>EasyDelState</code> object</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>@classmethod\ndef from_pretrained(\n        cls,\n        pretrained_model_name_or_path: str,\n        filename: Optional[str] = None,\n        optimizer: AVAILABLE_OPTIMIZERS = \"adamw\",\n        scheduler: AVAILABLE_SCHEDULERS = \"none\",\n        tx_init: Optional[dict] = None,\n        device=jax.devices('cpu')[0],\n        dtype: jax.numpy.dtype = jax.numpy.float32,\n        param_dtype: jax.numpy.dtype = jax.numpy.float32,\n        precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\"),\n        sharding_axis_dims: Sequence[int] = (1, -1, 1, 1),\n        sharding_axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n        query_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                      None),\n        key_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                    None),\n        value_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                      None),\n        bias_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), None, None,\n                                                                                     None),\n        attention_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\",\n                                                                                          \"tp\", None),\n        use_shard_map: bool = False,\n        input_shape: Sequence[int] = (1, 1),\n        backend: Optional[str] = None,\n        init_optimizer_state: bool = False,\n        free_optimizer_state: bool = True,\n        verbose: bool = True,\n        state_shard_fns: Optional[Mapping[str, Callable]] = None,\n        **kwargs\n) -&gt; \"EasyDelState\":\n\n    \"\"\"\n    The from_pretrained function is a helper function to quickly load a pretrained model and its associated configuration.\n    This method takes care of returning the correct model class instance based on the `model_type` property in the\n    config object, or when it's missing, falling back to using pattern matching on the\n     `pretrained_model_name_or_path` string:\n\n    :param cls: Refer to the class that is being defined\n    :param pretrained_model_name_or_path: str: Load the pretrained model\n    :param filename: Optional[str]: Specify the name of the file to download from huggingface hub\n    :param optimizer: AVAILABLE_OPTIMIZERS: Specify the optimizer used for training\n    :param scheduler: AVAILABLE_SCHEDULERS: Specify the name of the scheduler to use\n    :param tx_init: Optional[dict]: Pass the hyperparameters of the optimizer\n    :param device: Specify the device on which to run the model\n    :param dtype: jax.numpy.dtype: Specify the dtype of the model parameters\n    :param param_dtype: jax.numpy.dtype: Specify the data type of the parameters\n    :param precision: jax.lax.Precision: Control the precision of the calculation\n    :param sharding_axis_dims: Sequence[int]: Specify the dimension of each axis\n    :param sharding_axis_names: Sequence[str]: Specify the names of the axes in each shard\n    :param query_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the query matrix\n    :param key_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the key matrix\n    :param value_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the value tensor\n    :param bias_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the bias\n    :param attention_partition_spec: jax.sharding.PartitionSpec: Partition the attention weights\n    :param use_shard_map: bool: Determine whether to use shard_map or not\n    :param input_shape: Sequence[int]: Specify the shape of the input to be used for training\n    :param backend: Optional[str]: Specify the backend used for the model\n    :param init_optimizer_state: bool: Initialize the optimizer state\n    :param free_optimizer_state: bool: Free the optimizer state from memory\n    :param verbose: bool: Print the progress of loading the model\n    :param state_shard_fns: Optional[Mapping[str,Callable]]: Specify the function to use for sharding the state\n    :param kwargs: Pass keyword arguments to the function\n    :return: An `EasyDelState` object\n    \"\"\"\n    if free_optimizer_state and init_optimizer_state:\n        raise EasyDelRuntimeError(\n            \"You can't use `free_optimizer_state` and `init_optimizer_state` True at same Time\"\n        )\n\n    if filename is None:\n        from ..modules.auto_easydel_model import AutoEasyDelModelForCausalLM\n\n        model, params = AutoEasyDelModelForCausalLM.from_pretrained(\n            pretrained_model_name_or_path,\n            device=device,\n            dtype=dtype,\n            param_dtype=param_dtype,\n            precision=precision,\n            sharding_axis_dims=sharding_axis_dims,\n            sharding_axis_names=sharding_axis_names,\n            query_partition_spec=query_partition_spec,\n            key_partition_spec=key_partition_spec,\n            value_partition_spec=value_partition_spec,\n            bias_partition_spec=bias_partition_spec,\n            attention_partition_spec=attention_partition_spec,\n            use_shard_map=use_shard_map,\n            input_shape=input_shape,\n            backend=backend,\n            **kwargs\n        )\n        if tx_init is None:\n            tx_init = {}\n\n        tx_init[\"optimizer\"] = optimizer\n        tx_init[\"scheduler\"] = scheduler\n\n        state = cls.load(\n            apply_fn=model.__call__,\n            params=FrozenDict({'params': params}),\n            step=0,\n            opt_state=None,\n            tx_init=tx_init,\n            hyperparameters=None,\n            module=model,\n            module_config=model.config,\n            module_config_args=model.config.to_dict()\n        )\n    else:\n        with jax.default_device(device):\n            from huggingface_hub import hf_hub_download\n            checkpoint_path = hf_hub_download(\n                repo_id=pretrained_model_name_or_path,\n                filename=filename,\n            )\n            state = cls.load_state(\n                checkpoint_path=checkpoint_path,\n                init_optimizer_state=init_optimizer_state,\n                verbose=verbose,\n                state_shard_fns=state_shard_fns\n            )\n    if init_optimizer_state:\n        with jax.default_device(device):\n            state = state.init_opt_state()\n    if free_optimizer_state:\n        state = state.free_opt_state()\n    return state\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.init_opt_state","title":"<code>init_opt_state()</code>","text":"<p>The init_opt_state function initializes the optimizer state.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Make the object callable, and params is used to pass in a dictionary of parameters</p> required <p>Returns:</p> Type Description <code>EasyDelState</code> <p>A new instance of the class with opt_state initialized</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>def init_opt_state(self) -&gt; \"EasyDelState\":\n\n    \"\"\"\n    The init_opt_state function initializes the optimizer state.\n    :param self: Make the object callable, and params is used to pass in a dictionary of parameters\n    :return: A new instance of the class with opt_state initialized\n    \"\"\"\n    if self.opt_state is None:\n        params_with_opt = (\n            self.params['params'] if OVERWRITE_WITH_GRADIENT in self.params else self.params\n        )\n        opt_state = self.tx.init(params_with_opt)\n\n        return self.replace(\n            opt_state=opt_state\n        )\n    return self\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.load","title":"<code>load(*, apply_fn, params, step=0, opt_state=None, tx_init=None, hyperparameters=None, module=None, module_config=None, module_config_args=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>The load function is used to load a saved state of the Model and optimizer or Model Only.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>Make the function a class method</p> required <code>*</code> <p>Pass in a variable number of arguments</p> required <code>step</code> <code>int</code> <p>int: Keep track of the number of steps that have been taken</p> <code>0</code> <code>apply_fn</code> <code>Callable</code> <p>Callable: Apply the optimizer to the model</p> required <code>params</code> <code>FrozenDict[str, Any] | Mapping[str, Any]</code> <p>core.FrozenDict[str,Any] | Mapping[str,Any]: Pass in the parameters of the model</p> required <code>opt_state</code> <code>Optional[OptState]</code> <p>Optional[optax.OptState]: optimizer state</p> <code>None</code> <code>tx_init</code> <code>Optional[dict]</code> <p>Optional[dict]: Pass the hyperparameters to the optimizer</p> <code>None</code> <code>hyperparameters</code> <code>Optional[dict]</code> <p>Optional[dict]: Load hyperparameters from the state dict</p> <code>None</code> <code>module</code> <code>Optional[EasyDelFlaxPretrainedModel]</code> <p>Optional[EasyDelFlaxPretrainedModel]: Pass in the module</p> <code>None</code> <code>module_config</code> <code>Optional[EasyDelPretrainedConfig]</code> <p>Optional[EasyDelPretrainedConfig]: Pass the module config</p> <code>None</code> <code>module_config_args</code> <code>Optional[dict]</code> <p>Optional[dict]: Pass the config_args to the model</p> <code>None</code> <code>kwargs</code> <p>Pass in any additional parameters that may be needed for the model</p> <code>{}</code> <p>Returns:</p> Type Description <p>A new instance of the class</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>@classmethod\ndef load(\n        cls,\n        *,\n        apply_fn: Callable,\n        params: core.FrozenDict[str, Any] | Mapping[str, Any],\n        step: int = 0,\n        opt_state: Optional[optax.OptState] = None,\n        tx_init: Optional[dict] = None,\n        hyperparameters: Optional[dict] = None,\n        module: Optional[EasyDelFlaxPretrainedModel] = None,\n        module_config: Optional[EasyDelPretrainedConfig] = None,\n        module_config_args: Optional[dict] = None,\n        **kwargs\n):\n\n    \"\"\"\n    The load function is used to load a saved state of the Model and optimizer or Model Only.\n\n    :param cls: Make the function a class method\n    :param *: Pass in a variable number of arguments\n    :param step: int: Keep track of the number of steps that have been taken\n    :param apply_fn: Callable: Apply the optimizer to the model\n    :param params: core.FrozenDict[str,Any] | Mapping[str,Any]: Pass in the parameters of the model\n    :param opt_state: Optional[optax.OptState]: optimizer state\n    :param tx_init: Optional[dict]: Pass the hyperparameters to the optimizer\n    :param hyperparameters: Optional[dict]: Load hyperparameters from the state dict\n    :param module: Optional[EasyDelFlaxPretrainedModel]: Pass in the module\n    :param module_config: Optional[EasyDelPretrainedConfig]: Pass the module config\n    :param module_config_args: Optional[dict]: Pass the config_args to the model\n    :param kwargs: Pass in any additional parameters that may be needed for the model\n    :return: A new instance of the class\n    \"\"\"\n    if module_config is not None:\n        module_config = copy.deepcopy(module_config)\n\n    if tx_init is None:\n        tx_init = {}\n    tx_init = copy.deepcopy(tx_init)\n    tx_init = cls.unsafe_dict(tx_init)\n\n    tx_init[\"optimizer\"] = cls.search(\"optimizer\", tx_init, \"admaw\")\n    tx_init[\"scheduler\"] = cls.search(\"scheduler\", tx_init, \"none\")\n    tx_init[\"steps\"] = cls.search(\"steps\", tx_init, 1e6)\n    try:\n        tx, sc = get_optimizer_and_scheduler(\n            **tx_init\n        )\n    except TypeError:\n        termcolor.cprint(\n            \"Couldn't load past optimizer State initializing new one with default Optimizer and Scheduler\",\n            color=\"red\", force_color=True\n        )\n        tx, sc = get_optimizer_and_scheduler(\n            optimizer=\"adamw\",\n            scheduler=\"none\",\n            steps=10000,\n        )\n    if hyperparameters is None:\n        hyperparameters = {}\n\n    if module_config is not None:\n        hyperparameters = cls.create_hyperparameters(module_config.model_type)\n        cls.safe_dict(module_config.__dict__)\n\n    return cls(\n        step=step,\n        apply_fn=apply_fn,\n        params=params,\n        tx=tx,\n        opt_state=opt_state,\n        tx_init=cls.safe_dict(tx_init),\n        hyperparameters=hyperparameters,\n        module=module,\n        module_config=module_config,\n        module_config_args=None,\n        **kwargs,\n    )\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.load_state","title":"<code>load_state(checkpoint_path, init_optimizer_state=False, state_shard_fns=None, verbose=False)</code>  <code>classmethod</code>","text":"<p>The load_state function is a class method that loads the state of an EasyDelModel from a checkpoint.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>Create an instance of the class</p> required <code>checkpoint_path</code> <code>str | PathLike</code> <p>str | os.PathLike: Specify the path to the checkpoint file</p> required <code>init_optimizer_state</code> <code>bool</code> <p>bool: Initialize the optimizer if it's not Initialized yet (if it Initialized the option will be ignored )</p> <code>False</code> <code>state_shard_fns</code> <code>Optional[Mapping[str, Callable]]</code> <p>Optional[Mapping[str,Callable]]: Specify the function that will be used  to shard the loaded state</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>bool: Print out the progress of loading</p> <code>False</code> <p>Returns:</p> Type Description <p>A state object</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>@classmethod\ndef load_state(\n        cls,\n        checkpoint_path: str | os.PathLike,\n        init_optimizer_state: bool = False,\n        state_shard_fns: Optional[Mapping[str, Callable]] = None,\n        verbose: bool = False\n):\n\n    \"\"\"    \n    The load_state function is a class method that loads the state of an EasyDelModel from a checkpoint.\n\n    :param cls: Create an instance of the class\n    :param checkpoint_path: str | os.PathLike: Specify the path to the checkpoint file\n    :param init_optimizer_state: bool: Initialize the optimizer if it's not Initialized yet (if it Initialized the option\n    will be ignored )\n    :param state_shard_fns: Optional[Mapping[str,Callable]]: Specify the function that will be used \n    to shard the loaded state\n    :param verbose: bool: Print out the progress of loading\n    :return: A state object\n    \"\"\"\n    from ..modules.auto_easydel_model import get_modules_by_type\n\n    checkpoint = fjformer.CheckpointManager.load_checkpoint(\n        path=checkpoint_path,\n        shard_fns=state_shard_fns,\n        verbose=verbose,\n    )\n\n    hyperparameters = checkpoint.get(\"hyperparameters\")\n    cfg, module, convertor = get_modules_by_type(model_type=cls.get_model_type(hyperparameters))\n    module_config = checkpoint.pop(\"module_config\", None)\n    if checkpoint[\"module_config_args\"] is not None:\n        module_config = cfg.from_dict(checkpoint.get(\"module_config_args\", {}))\n\n    state = cls.load(\n        apply_fn=module.__call__,\n        module=module,\n        module_config=module_config,\n        **checkpoint\n    )\n    state = state.replace(\n        module_config_args=None  # removing because it's not needed anymore\n    )\n    if init_optimizer_state:\n        state = state.init_opt_state()\n    return state\n</code></pre>"},{"location":"generated-etils-easystate/#lib.python.EasyDel.etils.easystate.EasyDelState.save_state","title":"<code>save_state(filename, save_optimizer=False, checkpoint_dir=None, verbose=False, gather_fns=None, float_dtype=None)</code>","text":"<p>The save_state function saves the state of a model to disk.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Pass the object itself to the function</p> required <code>filename</code> <code>str | PathLike</code> <p>str | os.PathLike: Specify the name of the file to save</p> required <code>save_optimizer</code> <code>bool</code> <p>bool: Determine whether to save the optimizer state or not</p> <code>False</code> <code>checkpoint_dir</code> <code>Optional[str | PathLike]</code> <p>Optional[str | os.PathLike]: Specify the directory where the checkpoint is saved</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>bool: Print out the path of the saved file</p> <code>False</code> <code>gather_fns</code> <code>dict[Callable]</code> <p>dict[Callable]: Specify a dictionary of functions that can be used to gather</p> <code>None</code> <code>float_dtype</code> <code>str | dtype</code> <p>str | jax.numpy.dtype: Specify the precision of the saved model</p> <code>None</code> <code></code> <p>Save the optimizer state</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>lib/python/EasyDel/etils/easystate.py</code> <pre><code>def save_state(\n        self,\n        filename: str | os.PathLike,\n        save_optimizer: bool = False,\n        checkpoint_dir: Optional[str | os.PathLike] = None,\n        verbose: bool = False,\n        gather_fns: dict[Callable] = None,\n        float_dtype: str | jax.numpy.dtype = None,\n):\n\n    \"\"\"\n    The save_state function saves the state of a model to disk.\n\n    :param self: Pass the object itself to the function\n    :param filename: str | os.PathLike: Specify the name of the file to save\n    :param save_optimizer: bool: Determine whether to save the optimizer state or not\n    :param checkpoint_dir: Optional[str | os.PathLike]: Specify the directory where the checkpoint is saved\n    :param verbose: bool: Print out the path of the saved file\n    :param gather_fns: dict[Callable]: Specify a dictionary of functions that can be used to gather\n    :param float_dtype: str | jax.numpy.dtype: Specify the precision of the saved model\n    :param : Save the optimizer state\n    :return: None\n    \"\"\"\n    state = self\n    if not save_optimizer:\n        state = self.replace(\n            opt_state=None\n        )\n    fjformer.CheckpointManager.save_state_to_file(\n        state=state,\n        path=os.path.join(checkpoint_dir, filename) if checkpoint_dir is not None else filename,\n        verbose=verbose,\n        gather_fns=gather_fns,\n        float_dtype=float_dtype,\n    )\n</code></pre>"},{"location":"generated-etils-errors/","title":"etils.errors","text":""},{"location":"generated-etils-etils/","title":"etils.etils","text":""},{"location":"generated-etils-etils/#lib.python.EasyDel.etils.etils.EasyDelGradientCheckPointers","title":"<code>EasyDelGradientCheckPointers</code>  <code>dataclass</code>","text":"<p>The code snippet is defining a data class called <code>EasyDelGradientCheckPointers</code> using the <code>@dataclass</code> decorator. A data class is a class that is primarily used to store data, and it automatically generates special methods such as <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code> based on the class attributes.</p> Source code in <code>lib/python/EasyDel/etils/etils.py</code> <pre><code>@dataclass\nclass EasyDelGradientCheckPointers:\n    \"\"\"\n    The code snippet is defining a data class called `EasyDelGradientCheckPointers` using the `@dataclass`\n    decorator. A data class is a class that is primarily used to store data, and it automatically\n    generates special methods such as `__init__`, `__repr__`, and `__eq__` based on the class\n    attributes.\n    \"\"\"\n    EVERYTHING_SAVEABLE: Literal[\"everything_saveable\"] = \"everything_saveable\"  # Fix Pycharm Debugging Issue\n    NOTHING_SAVEABLE: Literal[\"nothing_saveable\"] = \"nothing_saveable\"  # Fix Pycharm Debugging Issue\n    CHECKPOINT_DOTS: Literal[\"checkpoint_dots\"] = \"checkpoint_dots\"  # Fix Pycharm Debugging Issue\n    CHECKPOINT_DOTS_WITH_NO_BATCH_DMIS: Literal[\"checkpoint_dots_with_no_batch_dims\"] = \\\n        \"checkpoint_dots_with_no_batch_dims\"  # Fix Pycharm Debugging Issue\n</code></pre>"},{"location":"generated-etils-etils/#lib.python.EasyDel.etils.etils.EasyDelOptimizers","title":"<code>EasyDelOptimizers</code>  <code>dataclass</code>","text":"<p>The code snippet is defining a data class called <code>EasyDelOptimizers</code> using the <code>@dataclass</code> decorator. A data class is a class that is primarily used to store data, and it automatically generates special methods such as <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code> based on the class attributes.</p> Source code in <code>lib/python/EasyDel/etils/etils.py</code> <pre><code>@dataclass\nclass EasyDelOptimizers:\n    \"\"\"\n    The code snippet is defining a data class called `EasyDelOptimizers` using the `@dataclass`\n    decorator. A data class is a class that is primarily used to store data, and it automatically\n    generates special methods such as `__init__`, `__repr__`, and `__eq__` based on the class\n    attributes.\n    \"\"\"\n    ADAFACTOR: Literal[\"adafactor\"] = \"adafactor\"  # Fix Pycharm Debugging Issue\n    LION: Literal[\"lion\"] = \"lion\"  # Fix Pycharm Debugging Issue\n    ADAMW: Literal[\"adamw\"] = 'adamw'  # Fix Pycharm Debugging Issue\n</code></pre>"},{"location":"generated-etils-etils/#lib.python.EasyDel.etils.etils.EasyDelSchedulers","title":"<code>EasyDelSchedulers</code>  <code>dataclass</code>","text":"<p>The code snippet is defining a data class called <code>EasyDelSchedulers</code> using the <code>@dataclass</code> decorator. A data class is a class that is primarily used to store data, and it automatically generates special methods such as <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code> based on the class attributes.</p> Source code in <code>lib/python/EasyDel/etils/etils.py</code> <pre><code>@dataclass\nclass EasyDelSchedulers:\n    \"\"\"\n    The code snippet is defining a data class called `EasyDelSchedulers` using the `@dataclass`\n    decorator. A data class is a class that is primarily used to store data, and it automatically\n    generates special methods such as `__init__`, `__repr__`, and `__eq__` based on the class\n    attributes.\n    \"\"\"\n    LINEAR: Literal[\"linear\"] = \"linear\"  # Fix Pycharm Debugging Issue\n    COSINE: Literal[\"cosine\"] = \"cosine\"  # Fix Pycharm Debugging Issue\n    NONE: Literal[\"none\"] = \"none\"  # Fix Pycharm Debugging Issue\n    WARM_UP_COSINE: Literal[\"warm_up_cosine\"] = \"warm_up_cosine\"  # Fix Pycharm Debugging Issue\n    WARM_UP_LINEAR: Literal[\"warm_up_linear\"] = \"warm_up_linear\"  # Fix Pycharm Debugging Issue\n</code></pre>"},{"location":"generated-eval-lm_eval/","title":"eval.lm_eval","text":""},{"location":"generated-eval-lm_eval/#lib.python.EasyDel.eval.lm_eval.evaluate","title":"<code>evaluate(model, task_list=None, write_out=True, limit=0, shots=5)</code>","text":"<p>The evaluate function takes a model and evaluates it on the tasks specified in task_list. The results are printed to stdout, and optionally written out to a file.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>Specify the model to be evaluated</p> required <code>task_list</code> <code>Optional[List[str]]</code> <p>Optional[List[str]]: Specify which tasks to evaluate on</p> <code>None</code> <code>write_out</code> <code>bool</code> <p>bool: Write the output to a file</p> <code>True</code> <code>limit</code> <code>int</code> <p>int: Limit the number of examples that are evaluated</p> <code>0</code> <code>shots</code> <code>int</code> <p>int: Specify how many times to run the model on a given task</p> <code>5</code> <p>Returns:</p> Type Description <p>A dictionary with the following keys</p> Source code in <code>lib/python/EasyDel/eval/lm_eval.py</code> <pre><code>def evaluate(model, task_list: Optional[List[str]] = None, write_out: bool = True, limit: int = 0, shots: int = 5):\n    \"\"\"\n    The evaluate function takes a model and evaluates it on the tasks specified in task_list.\n    The results are printed to stdout, and optionally written out to a file.\n\n\n    :param model: Specify the model to be evaluated\n    :param task_list: Optional[List[str]]: Specify which tasks to evaluate on\n    :param write_out: bool: Write the output to a file\n    :param limit: int: Limit the number of examples that are evaluated\n    :param shots: int: Specify how many times to run the model on a given task\n    :return: A dictionary with the following keys\n\n    \"\"\"\n    if task_list is None:\n        task_list = ['wsc', \"piqa\"]\n\n    for task in task_list:\n        assert task in AVAILABLE_TASKS, f'UnKnown Task {tasks} available tasks are {AVAILABLE_TASKS}'\n    results = evaluator.evaluate(\n        model, tasks.get_task_dict(task_list), False, shots,\n        limit=None if limit &lt;= 0 else limit,\n        write_out=write_out,\n    )\n    pprint.pprint(results)\n    return results\n</code></pre>"},{"location":"generated-linen-bits/","title":"linen.bits","text":""},{"location":"generated-linen-bits/#lib.python.EasyDel.linen.bits.Dense8Bit","title":"<code>Dense8Bit</code>","text":"<p>             Bases: <code>Dense</code></p> Source code in <code>lib/python/EasyDel/linen/bits.py</code> <pre><code>class Dense8Bit(Dense):\n    @compact\n    def __call__(self, inputs: jax.Array) -&gt; jax.Array:\n        \"\"\"Applies a linear transformation to the inputs along the last dimension.\n\n        Args:\n          inputs: The nd-array to be transformed.\n\n        Returns:\n          The transformed input.\n        \"\"\"\n        if inputs.dtype == jnp.int8:\n            inputs = array_from_8bit(inputs, self.dtype)\n        kernel = array_from_8bit(self.param(\n            'kernel',\n            self.kernel_init,\n            (jnp.shape(inputs)[-1], self.features),\n            self.param_dtype,\n        ), self.param_dtype)\n        if self.use_bias:\n            bias = array_from_8bit(self.param(\n                'bias', self.bias_init, (self.features,), self.param_dtype\n            ), self.param_dtype)\n        else:\n            bias = None\n        inputs, kernel, bias = promote_dtype(inputs, kernel, bias, dtype=self.dtype)\n\n        if self.dot_general_cls is not None:\n            dot_general = self.dot_general_cls()\n        elif self.dot_general is not None:\n            dot_general = self.dot_general\n        else:\n            dot_general = lax.dot_general\n        y = dot_general(\n            inputs,\n            kernel,\n            (((inputs.ndim - 1,), (0,)), ((), ())),\n            precision=self.precision,\n        )\n        if bias is not None:\n            y += jnp.reshape(bias, (1,) * (y.ndim - 1) + (-1,))\n        return array_to_bit8(y)\n</code></pre>"},{"location":"generated-linen-bits/#lib.python.EasyDel.linen.bits.Dense8Bit.__call__","title":"<code>__call__(inputs)</code>","text":"<p>Applies a linear transformation to the inputs along the last dimension.</p> <p>Args:   inputs: The nd-array to be transformed.</p> <p>Returns:   The transformed input.</p> Source code in <code>lib/python/EasyDel/linen/bits.py</code> <pre><code>@compact\ndef __call__(self, inputs: jax.Array) -&gt; jax.Array:\n    \"\"\"Applies a linear transformation to the inputs along the last dimension.\n\n    Args:\n      inputs: The nd-array to be transformed.\n\n    Returns:\n      The transformed input.\n    \"\"\"\n    if inputs.dtype == jnp.int8:\n        inputs = array_from_8bit(inputs, self.dtype)\n    kernel = array_from_8bit(self.param(\n        'kernel',\n        self.kernel_init,\n        (jnp.shape(inputs)[-1], self.features),\n        self.param_dtype,\n    ), self.param_dtype)\n    if self.use_bias:\n        bias = array_from_8bit(self.param(\n            'bias', self.bias_init, (self.features,), self.param_dtype\n        ), self.param_dtype)\n    else:\n        bias = None\n    inputs, kernel, bias = promote_dtype(inputs, kernel, bias, dtype=self.dtype)\n\n    if self.dot_general_cls is not None:\n        dot_general = self.dot_general_cls()\n    elif self.dot_general is not None:\n        dot_general = self.dot_general\n    else:\n        dot_general = lax.dot_general\n    y = dot_general(\n        inputs,\n        kernel,\n        (((inputs.ndim - 1,), (0,)), ((), ())),\n        precision=self.precision,\n    )\n    if bias is not None:\n        y += jnp.reshape(bias, (1,) * (y.ndim - 1) + (-1,))\n    return array_to_bit8(y)\n</code></pre>"},{"location":"generated-linen-bits/#lib.python.EasyDel.linen.bits.MatmulLtState","title":"<code>MatmulLtState</code>  <code>dataclass</code>","text":"Source code in <code>lib/python/EasyDel/linen/bits.py</code> <pre><code>@dataclass\nclass MatmulLtState:\n    _tile_indices: Optional[jax.Array] = None\n    force_no_igemmlt: bool = False\n    CB = None\n    CxB = None\n    SB = None\n    SCB = None\n\n    CxBt = None\n    SBt = None\n    CBt = None\n\n    subB = None\n\n    outlier_pool = None\n    has_accumulated_gradients = False\n    threshold = 0.0\n    idx = None\n    is_training = True\n    has_fp16_weights = True\n    memory_efficient_backward = False\n    use_pool = False\n    formatB = \"col_turing\"\n\n    def reset_grads(self):\n        \"\"\"\n        The reset_grads function is used to reset the gradients of all the parameters in our model.\n        This function is called after each iteration of training, and before we update our weights.\n        The reason for this is that if we don't reset these values, they will accumulate over time and\n        cause problems with our weight updates.\n\n        :param self: Represent the instance of the class\n        :return: Nothing\n\n        \"\"\"\n        self.CB = None\n        self.CxB = None\n        self.SB = None\n        self.SCB = None\n\n        self.CxBt = None\n        self.SBt = None\n        self.CBt = None\n\n    @property\n    def tile_indices(self):\n        if self._tile_indices is None:\n            self._tile_indices = get_tile_inds(self.formatB)\n        return self._tile_indices\n</code></pre>"},{"location":"generated-linen-bits/#lib.python.EasyDel.linen.bits.MatmulLtState.reset_grads","title":"<code>reset_grads()</code>","text":"<p>The reset_grads function is used to reset the gradients of all the parameters in our model. This function is called after each iteration of training, and before we update our weights. The reason for this is that if we don't reset these values, they will accumulate over time and cause problems with our weight updates.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>lib/python/EasyDel/linen/bits.py</code> <pre><code>def reset_grads(self):\n    \"\"\"\n    The reset_grads function is used to reset the gradients of all the parameters in our model.\n    This function is called after each iteration of training, and before we update our weights.\n    The reason for this is that if we don't reset these values, they will accumulate over time and\n    cause problems with our weight updates.\n\n    :param self: Represent the instance of the class\n    :return: Nothing\n\n    \"\"\"\n    self.CB = None\n    self.CxB = None\n    self.SB = None\n    self.SCB = None\n\n    self.CxBt = None\n    self.SBt = None\n    self.CBt = None\n</code></pre>"},{"location":"generated-linen-bits/#lib.python.EasyDel.linen.bits.aqt_matmul_int8","title":"<code>aqt_matmul_int8(a, w)</code>","text":"<p>The aqt_matmul_int8 function performs the following steps:</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>Scale the input tensor</p> required <code>w</code> <p>Store the weights of the model</p> required <p>Returns:</p> Type Description <p>A result that is close to the original matrix multiplication</p> Source code in <code>lib/python/EasyDel/linen/bits.py</code> <pre><code>def aqt_matmul_int8(a, w):\n    \"\"\"\n    The aqt_matmul_int8 function performs the following steps:\n\n    :param a: Scale the input tensor\n    :param w: Store the weights of the model\n    :return: A result that is close to the original matrix multiplication\n\n    \"\"\"\n    max_int8 = 127\n\n    # This function is customizable and injectable, i.e:\n    # users can inject custom quant code into an AQT config.\n    def quant_int8(x):\n        return jnp.clip(jnp.round(x), -max_int8, max_int8).astype(jnp.int8)\n\n    # Calibration. Calibration function is also customizable and injectable.\n    a_s = max_int8 / jnp.max(jnp.abs(a), axis=1, keepdims=True)\n    w_s = max_int8 / jnp.max(jnp.abs(w), axis=0, keepdims=True)\n\n    # int8 matmul with int32 accumulator\n    result = matmul_true_int8(quant_int8(a * a_s), quant_int8(w * w_s)) / (a_s * w_s)\n\n    return result\n</code></pre>"},{"location":"generated-linen-bits/#lib.python.EasyDel.linen.bits.get_tile_inds","title":"<code>get_tile_inds(format_)</code>","text":"<p>The get_tile_inds function is used to get the indices of a tile in a tensor.</p> <p>Parameters:</p> Name Type Description Default <code>format_</code> <p>Determine the shape of the tile_inds array</p> required <p>Returns:</p> Type Description <p>The indices of the tiles in a given format</p> Source code in <code>lib/python/EasyDel/linen/bits.py</code> <pre><code>def get_tile_inds(format_):\n    \"\"\"\n    The get_tile_inds function is used to get the indices of a tile in a tensor.\n\n    :param format_: Determine the shape of the tile_inds array\n    :return: The indices of the tiles in a given format\n\n    \"\"\"\n    transform = lambda x: lax.cond(\n        jnp.bitwise_and(jnp.array(format_), 1),\n        lambda _: lax.transpose(x),\n        lambda _: x,\n        operand=None,\n    )\n    inverse_transform = lambda x: lax.cond(\n        jnp.bitwise_and(jnp.array(format_), 1),\n        lambda _: lax.transpose(x),\n        lambda _: x,\n        operand=None,\n    )\n    tile_size = _get_tile_size(format_)\n    tile_inds = lax.broadcasted_iota(jnp.int32, [tile_size] * len(tile_size))\n    tile_inds = inverse_transform(tile_inds)\n    return tile_inds\n</code></pre>"},{"location":"generated-linen-utils/","title":"linen.utils","text":""},{"location":"generated-linen-utils/#lib.python.EasyDel.linen.utils.from_8bit","title":"<code>from_8bit(tree, dtype=jnp.float32)</code>","text":"<p>takes a pytree(unflatten) and convert that into original pytree</p> Source code in <code>lib/python/EasyDel/linen/utils.py</code> <pre><code>def from_8bit(tree: dict, dtype: jnp.dtype = jnp.float32):\n    \"\"\"\n    takes a pytree(unflatten) and convert that into original pytree\n    \"\"\"\n    tree = flatten_dict(tree)\n\n    for key, array in tree.items():\n        scale_factor = jnp.max(array)\n        array = (array / scale_factor).astype(dtype)\n        tree[key] = array\n    return unflatten_dict(tree)\n</code></pre>"},{"location":"generated-linen-utils/#lib.python.EasyDel.linen.utils.to_8bit","title":"<code>to_8bit(tree)</code>","text":"<p>takes a pytree(unflatten) and convert that into 8bit array pytree</p> Source code in <code>lib/python/EasyDel/linen/utils.py</code> <pre><code>def to_8bit(tree: dict):\n    \"\"\"\n    takes a pytree(unflatten) and convert that into 8bit array pytree\n    \"\"\"\n    tree = flatten_dict(tree)\n\n    for key, array in tree.items():\n        scale_factor = 127 / jnp.max(array)\n        array = (array * scale_factor).astype(jnp.int8)\n        tree[key] = array\n    return unflatten_dict(tree)\n</code></pre>"},{"location":"generated-modules-auto_easydel_model/","title":"modules.auto_easydel_model","text":""},{"location":"generated-modules-auto_easydel_model/#lib.python.EasyDel.modules.auto_easydel_model.AutoEasyDelConfig","title":"<code>AutoEasyDelConfig</code>","text":"Source code in <code>lib/python/EasyDel/modules/auto_easydel_model.py</code> <pre><code>class AutoEasyDelConfig:\n    @classmethod\n    def from_pretrained(\n            cls,\n            pretrained_model_name_or_path: str,\n            sharding_axis_dims: Sequence[int] = (1, -1, 1, 1),\n            sharding_axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n            query_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                          None),\n            key_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                        None),\n            value_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                          None),\n            bias_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), None, None,\n                                                                                         None),\n            attention_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\",\n                                                                                              \"tp\", None),\n            use_shard_map: bool = False,\n            backend: Optional[str] = None,\n            **kwargs\n    ) -&gt; EasyDelPretrainedConfig:\n        \"\"\"\n        The from_pretrained function is a helper function that allows you to instantiate a model from the pretrained\n        model repository. It takes as input the name of the model (e.g., 'bert-base-uncased') and returns an instance of\n        the class corresponding to your model, with all weights loaded from disk.\n\n        :param cls: Create an instance of the class that called this function\n        :param pretrained_model_name_or_path: str: Identify the model in the huggingface model hub\n        :param sharding_axis_dims: Sequence[int]: Specify the dimension of each axis in the sharded model\n        :param sharding_axis_names: Sequence[str]: Specify the order of sharding\n        :param query_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the query tensor\n        :param key_partition_spec: jax.sharding.PartitionSpec: Partition the key matrix\n        :param value_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the value tensor\n        :param bias_partition_spec: jax.sharding.PartitionSpec: Specify the Attention Bias partition spec\n        :param attention_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the attention weights\n        :param use_shard_map: bool: whenever to use shard_map for attention\n        :param backend: Optional[str]: backend to use for model\n        :param kwargs: Pass additional arguments to the model and config classes\n        :return: A Model Config\n\n        \"\"\"\n\n        config = AutoConfig.from_pretrained(pretrained_model_name_or_path)\n        model_type = config.model_type\n\n        cfg, module, trf = get_modules_by_type(model_type)\n        cfg = cfg.from_pretrained(pretrained_model_name_or_path)\n        if hasattr(cfg, 'add_jax_args'):\n            cfg.add_jax_args()\n        cfg.add_basic_configurations(\n            axis_dims=sharding_axis_dims,\n            axis_names=sharding_axis_names,\n            query_partition_spec=query_partition_spec,\n            key_partition_spec=key_partition_spec,\n            value_partition_spec=value_partition_spec,\n            bias_partition_spec=bias_partition_spec,\n            attention_partition_spec=attention_partition_spec,\n            backend=backend,\n            use_shard_map=use_shard_map,\n        )\n\n        return cfg\n</code></pre>"},{"location":"generated-modules-auto_easydel_model/#lib.python.EasyDel.modules.auto_easydel_model.AutoEasyDelConfig.from_pretrained","title":"<code>from_pretrained(pretrained_model_name_or_path, sharding_axis_dims=(1, -1, 1, 1), sharding_axis_names=('dp', 'fsdp', 'tp', 'sp'), query_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), key_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), value_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), bias_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), None, None, None), attention_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), use_shard_map=False, backend=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>The from_pretrained function is a helper function that allows you to instantiate a model from the pretrained model repository. It takes as input the name of the model (e.g., 'bert-base-uncased') and returns an instance of the class corresponding to your model, with all weights loaded from disk.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>Create an instance of the class that called this function</p> required <code>pretrained_model_name_or_path</code> <code>str</code> <p>str: Identify the model in the huggingface model hub</p> required <code>sharding_axis_dims</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the dimension of each axis in the sharded model</p> <code>(1, -1, 1, 1)</code> <code>sharding_axis_names</code> <code>Sequence[str]</code> <p>Sequence[str]: Specify the order of sharding</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>query_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the query tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>key_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Partition the key matrix</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>value_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the value tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>bias_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the Attention Bias partition spec</p> <code>PartitionSpec(('dp', 'fsdp'), None, None, None)</code> <code>attention_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the attention weights</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>use_shard_map</code> <code>bool</code> <p>bool: whenever to use shard_map for attention</p> <code>False</code> <code>backend</code> <code>Optional[str]</code> <p>Optional[str]: backend to use for model</p> <code>None</code> <code>kwargs</code> <p>Pass additional arguments to the model and config classes</p> <code>{}</code> <p>Returns:</p> Type Description <code>EasyDelPretrainedConfig</code> <p>A Model Config</p> Source code in <code>lib/python/EasyDel/modules/auto_easydel_model.py</code> <pre><code>@classmethod\ndef from_pretrained(\n        cls,\n        pretrained_model_name_or_path: str,\n        sharding_axis_dims: Sequence[int] = (1, -1, 1, 1),\n        sharding_axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n        query_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                      None),\n        key_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                    None),\n        value_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                      None),\n        bias_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), None, None,\n                                                                                     None),\n        attention_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\",\n                                                                                          \"tp\", None),\n        use_shard_map: bool = False,\n        backend: Optional[str] = None,\n        **kwargs\n) -&gt; EasyDelPretrainedConfig:\n    \"\"\"\n    The from_pretrained function is a helper function that allows you to instantiate a model from the pretrained\n    model repository. It takes as input the name of the model (e.g., 'bert-base-uncased') and returns an instance of\n    the class corresponding to your model, with all weights loaded from disk.\n\n    :param cls: Create an instance of the class that called this function\n    :param pretrained_model_name_or_path: str: Identify the model in the huggingface model hub\n    :param sharding_axis_dims: Sequence[int]: Specify the dimension of each axis in the sharded model\n    :param sharding_axis_names: Sequence[str]: Specify the order of sharding\n    :param query_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the query tensor\n    :param key_partition_spec: jax.sharding.PartitionSpec: Partition the key matrix\n    :param value_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the value tensor\n    :param bias_partition_spec: jax.sharding.PartitionSpec: Specify the Attention Bias partition spec\n    :param attention_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the attention weights\n    :param use_shard_map: bool: whenever to use shard_map for attention\n    :param backend: Optional[str]: backend to use for model\n    :param kwargs: Pass additional arguments to the model and config classes\n    :return: A Model Config\n\n    \"\"\"\n\n    config = AutoConfig.from_pretrained(pretrained_model_name_or_path)\n    model_type = config.model_type\n\n    cfg, module, trf = get_modules_by_type(model_type)\n    cfg = cfg.from_pretrained(pretrained_model_name_or_path)\n    if hasattr(cfg, 'add_jax_args'):\n        cfg.add_jax_args()\n    cfg.add_basic_configurations(\n        axis_dims=sharding_axis_dims,\n        axis_names=sharding_axis_names,\n        query_partition_spec=query_partition_spec,\n        key_partition_spec=key_partition_spec,\n        value_partition_spec=value_partition_spec,\n        bias_partition_spec=bias_partition_spec,\n        attention_partition_spec=attention_partition_spec,\n        backend=backend,\n        use_shard_map=use_shard_map,\n    )\n\n    return cfg\n</code></pre>"},{"location":"generated-modules-auto_easydel_model/#lib.python.EasyDel.modules.auto_easydel_model.AutoEasyDelModelForCausalLM","title":"<code>AutoEasyDelModelForCausalLM</code>","text":"Source code in <code>lib/python/EasyDel/modules/auto_easydel_model.py</code> <pre><code>class AutoEasyDelModelForCausalLM:\n    @classmethod\n    def from_pretrained(\n            cls,\n            pretrained_model_name_or_path: str,\n            device=jax.devices('cpu')[0],\n            dtype: jax.numpy.dtype = jax.numpy.float32,\n            param_dtype: jax.numpy.dtype = jax.numpy.float32,\n            precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\"),\n            sharding_axis_dims: Sequence[int] = (1, -1, 1, 1),\n            sharding_axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n            query_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                          None),\n            key_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                        None),\n            value_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                          None),\n            bias_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), None, None,\n                                                                                         None),\n            attention_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\",\n                                                                                              \"tp\", None),\n            use_shard_map: bool = False,\n            input_shape: Sequence[int] = (1, 1),\n            shard_fns: Optional[Mapping[tuple, Callable] | dict] = None,\n            backend: Optional[str] = None,\n            **kwargs\n    ) -&gt; Tuple[EasyDelFlaxPretrainedModel, dict]:\n        \"\"\"\n        The from_pretrained function is a helper function that allows you to instantiate a model from the pretrained\n        model repository. It takes as input the name of the model (e.g., 'bert-base-uncased') and returns an instance of\n        the class corresponding to your model, with all weights loaded from disk.\n\n        :param cls: Create an instance of the class that called this function\n        :param pretrained_model_name_or_path: str: Identify the model in the huggingface model hub\n        :param device: Specify the device on which to run the model\n        :param dtype: jax.numpy.dtype: Specify the data type of the model\n        :param param_dtype: jax.numpy.dtype: Specify the dtype of the parameters\n        :param precision: jax.lax.Precision: Control the precision of the model\n        :param sharding_axis_dims: typing.Sequence[int]: Specify the dimension of each axis in the sharded model\n        :param sharding_axis_names: typing.Sequence[str]: Specify the order of sharding\n        :param query_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the query tensor\n        :param key_partition_spec: jax.sharding.PartitionSpec: Partition the key matrix\n        :param value_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the value tensor\n        :param bias_partition_spec: jax.sharding.PartitionSpec: Specify the Attention Bias partition spec\n        :param attention_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the attention weights\n        :param use_shard_map: bool: whenever to use shard_map for attention\n        :param input_shape: typing.Sequence[int]: Specify the shape of the input to the model\n        :param shard_fns: Optional[Mapping[tuple, Callable]]: Sharding Function to be used to shard model\n        :param backend: typing.Optional[str]: backend to use for model\n        :param kwargs: Pass additional arguments to the model and config classes\n        :return: A model and parameters\n\n        \"\"\"\n\n        config = AutoConfig.from_pretrained(pretrained_model_name_or_path)\n        model_type = config.model_type\n\n        cfg, module, trf = get_modules_by_type(model_type)\n\n        model = AutoModelForCausalLM.from_pretrained(pretrained_model_name_or_path, **kwargs)\n        cfg = cfg.from_pretrained(pretrained_model_name_or_path)\n        if hasattr(cfg, 'add_jax_args'):\n            cfg.add_jax_args()\n        cfg.add_basic_configurations(\n            axis_dims=sharding_axis_dims,\n            axis_names=sharding_axis_names,\n            query_partition_spec=query_partition_spec,\n            key_partition_spec=key_partition_spec,\n            value_partition_spec=value_partition_spec,\n            bias_partition_spec=bias_partition_spec,\n            attention_partition_spec=attention_partition_spec,\n            backend=backend,\n            use_shard_map=use_shard_map,\n        )\n        ed_model = module(\n            config=cfg,\n            _do_init=False,\n            dtype=dtype,\n            param_dtype=param_dtype,\n            precision=precision,\n            input_shape=input_shape\n        )\n        if shard_fns is not None:\n            if not is_flatten(shard_fns):\n                shard_fns = flax.traverse_util.flatten_dict(shard_fns)\n        with cfg.jax_mesh():\n            params = trf(model.state_dict(), config=config, device=device, shard_fns=shard_fns)\n        del model,\n        gc.collect()\n\n        if is_flatten(params):\n            params = unflatten_dict(params)\n\n        return ed_model, params\n</code></pre>"},{"location":"generated-modules-auto_easydel_model/#lib.python.EasyDel.modules.auto_easydel_model.AutoEasyDelModelForCausalLM.from_pretrained","title":"<code>from_pretrained(pretrained_model_name_or_path, device=jax.devices('cpu')[0], dtype=jax.numpy.float32, param_dtype=jax.numpy.float32, precision=jax.lax.Precision('fastest'), sharding_axis_dims=(1, -1, 1, 1), sharding_axis_names=('dp', 'fsdp', 'tp', 'sp'), query_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), key_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), value_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), bias_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), None, None, None), attention_partition_spec=jax.sharding.PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), use_shard_map=False, input_shape=(1, 1), shard_fns=None, backend=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>The from_pretrained function is a helper function that allows you to instantiate a model from the pretrained model repository. It takes as input the name of the model (e.g., 'bert-base-uncased') and returns an instance of the class corresponding to your model, with all weights loaded from disk.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>Create an instance of the class that called this function</p> required <code>pretrained_model_name_or_path</code> <code>str</code> <p>str: Identify the model in the huggingface model hub</p> required <code>device</code> <p>Specify the device on which to run the model</p> <code>devices('cpu')[0]</code> <code>dtype</code> <code>dtype</code> <p>jax.numpy.dtype: Specify the data type of the model</p> <code>float32</code> <code>param_dtype</code> <code>dtype</code> <p>jax.numpy.dtype: Specify the dtype of the parameters</p> <code>float32</code> <code>precision</code> <code>Optional[Precision]</code> <p>jax.lax.Precision: Control the precision of the model</p> <code>Precision('fastest')</code> <code>sharding_axis_dims</code> <code>Sequence[int]</code> <p>typing.Sequence[int]: Specify the dimension of each axis in the sharded model</p> <code>(1, -1, 1, 1)</code> <code>sharding_axis_names</code> <code>Sequence[str]</code> <p>typing.Sequence[str]: Specify the order of sharding</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>query_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the query tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>key_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Partition the key matrix</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>value_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the value tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>bias_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the Attention Bias partition spec</p> <code>PartitionSpec(('dp', 'fsdp'), None, None, None)</code> <code>attention_partition_spec</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec: Specify the partitioning of the attention weights</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>use_shard_map</code> <code>bool</code> <p>bool: whenever to use shard_map for attention</p> <code>False</code> <code>input_shape</code> <code>Sequence[int]</code> <p>typing.Sequence[int]: Specify the shape of the input to the model</p> <code>(1, 1)</code> <code>shard_fns</code> <code>Optional[Mapping[tuple, Callable] | dict]</code> <p>Optional[Mapping[tuple, Callable]]: Sharding Function to be used to shard model</p> <code>None</code> <code>backend</code> <code>Optional[str]</code> <p>typing.Optional[str]: backend to use for model</p> <code>None</code> <code>kwargs</code> <p>Pass additional arguments to the model and config classes</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[EasyDelFlaxPretrainedModel, dict]</code> <p>A model and parameters</p> Source code in <code>lib/python/EasyDel/modules/auto_easydel_model.py</code> <pre><code>@classmethod\ndef from_pretrained(\n        cls,\n        pretrained_model_name_or_path: str,\n        device=jax.devices('cpu')[0],\n        dtype: jax.numpy.dtype = jax.numpy.float32,\n        param_dtype: jax.numpy.dtype = jax.numpy.float32,\n        precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\"),\n        sharding_axis_dims: Sequence[int] = (1, -1, 1, 1),\n        sharding_axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n        query_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                      None),\n        key_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                    None),\n        value_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\",\n                                                                                      None),\n        bias_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), None, None,\n                                                                                     None),\n        attention_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\",\n                                                                                          \"tp\", None),\n        use_shard_map: bool = False,\n        input_shape: Sequence[int] = (1, 1),\n        shard_fns: Optional[Mapping[tuple, Callable] | dict] = None,\n        backend: Optional[str] = None,\n        **kwargs\n) -&gt; Tuple[EasyDelFlaxPretrainedModel, dict]:\n    \"\"\"\n    The from_pretrained function is a helper function that allows you to instantiate a model from the pretrained\n    model repository. It takes as input the name of the model (e.g., 'bert-base-uncased') and returns an instance of\n    the class corresponding to your model, with all weights loaded from disk.\n\n    :param cls: Create an instance of the class that called this function\n    :param pretrained_model_name_or_path: str: Identify the model in the huggingface model hub\n    :param device: Specify the device on which to run the model\n    :param dtype: jax.numpy.dtype: Specify the data type of the model\n    :param param_dtype: jax.numpy.dtype: Specify the dtype of the parameters\n    :param precision: jax.lax.Precision: Control the precision of the model\n    :param sharding_axis_dims: typing.Sequence[int]: Specify the dimension of each axis in the sharded model\n    :param sharding_axis_names: typing.Sequence[str]: Specify the order of sharding\n    :param query_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the query tensor\n    :param key_partition_spec: jax.sharding.PartitionSpec: Partition the key matrix\n    :param value_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the value tensor\n    :param bias_partition_spec: jax.sharding.PartitionSpec: Specify the Attention Bias partition spec\n    :param attention_partition_spec: jax.sharding.PartitionSpec: Specify the partitioning of the attention weights\n    :param use_shard_map: bool: whenever to use shard_map for attention\n    :param input_shape: typing.Sequence[int]: Specify the shape of the input to the model\n    :param shard_fns: Optional[Mapping[tuple, Callable]]: Sharding Function to be used to shard model\n    :param backend: typing.Optional[str]: backend to use for model\n    :param kwargs: Pass additional arguments to the model and config classes\n    :return: A model and parameters\n\n    \"\"\"\n\n    config = AutoConfig.from_pretrained(pretrained_model_name_or_path)\n    model_type = config.model_type\n\n    cfg, module, trf = get_modules_by_type(model_type)\n\n    model = AutoModelForCausalLM.from_pretrained(pretrained_model_name_or_path, **kwargs)\n    cfg = cfg.from_pretrained(pretrained_model_name_or_path)\n    if hasattr(cfg, 'add_jax_args'):\n        cfg.add_jax_args()\n    cfg.add_basic_configurations(\n        axis_dims=sharding_axis_dims,\n        axis_names=sharding_axis_names,\n        query_partition_spec=query_partition_spec,\n        key_partition_spec=key_partition_spec,\n        value_partition_spec=value_partition_spec,\n        bias_partition_spec=bias_partition_spec,\n        attention_partition_spec=attention_partition_spec,\n        backend=backend,\n        use_shard_map=use_shard_map,\n    )\n    ed_model = module(\n        config=cfg,\n        _do_init=False,\n        dtype=dtype,\n        param_dtype=param_dtype,\n        precision=precision,\n        input_shape=input_shape\n    )\n    if shard_fns is not None:\n        if not is_flatten(shard_fns):\n            shard_fns = flax.traverse_util.flatten_dict(shard_fns)\n    with cfg.jax_mesh():\n        params = trf(model.state_dict(), config=config, device=device, shard_fns=shard_fns)\n    del model,\n    gc.collect()\n\n    if is_flatten(params):\n        params = unflatten_dict(params)\n\n    return ed_model, params\n</code></pre>"},{"location":"generated-modules-auto_easydel_model/#lib.python.EasyDel.modules.auto_easydel_model.get_modules_by_type","title":"<code>get_modules_by_type(model_type)</code>","text":"<p>The get_modules_by_type function is a helper function that returns the following:     1. The config class for the model type specified (e.g., LlamaConfig, FalconConfig)     2. The Flax Model class for the model type specified (e.g., FlaxLlamaForCausalLM, FlaxFalconForCausalLM)     3. A function to convert a HuggingFace pretrained checkpoint into an EasyDel checkpoint</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>str: Determine which model to use</p> required <p>Returns:</p> Type Description <code>Tuple[Type[EasyDelPretrainedConfig], Type[EasyDelFlaxPretrainedModel], Callable]</code> <p>A tuple of three elements (BaseConfig,BaseModel,Func To Transform Model from Torch to EasyDeL)</p> Source code in <code>lib/python/EasyDel/modules/auto_easydel_model.py</code> <pre><code>def get_modules_by_type(model_type: str) -&gt; Tuple[\n    Type[EasyDelPretrainedConfig],\n    Type[EasyDelFlaxPretrainedModel],\n    Callable\n]:\n    \"\"\"\n    The get_modules_by_type function is a helper function that returns the following:\n        1. The config class for the model type specified (e.g., LlamaConfig, FalconConfig)\n        2. The Flax Model class for the model type specified (e.g., FlaxLlamaForCausalLM, FlaxFalconForCausalLM)\n        3. A function to convert a HuggingFace pretrained checkpoint into an EasyDel checkpoint\n\n    :param model_type: str: Determine which model to use\n    :return: A tuple of three elements (BaseConfig,BaseModel,Func To Transform Model from Torch to EasyDeL)\n\n    \"\"\"\n    if model_type == \"llama\":\n        from .llama import LlamaConfig as _LlamaConfig\n        from .llama import FlaxLlamaForCausalLM as _FlaxLlamaForCausalLM\n        return (\n            _LlamaConfig,\n            _FlaxLlamaForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=[\"embed_tokens\"])\n        )\n    elif model_type == \"falcon\":\n        from .falcon import FlaxFalconForCausalLM as _FlaxFalconForCausalLM\n        from .falcon import FalconConfig as _FalconConfig\n        return (\n            _FalconConfig,\n            _FlaxFalconForCausalLM,\n            functools.partial(\n                huggingface_to_easydel,\n                embedding_layer_names=[\"word_embeddings\"],\n                layer_norm_names=[\n                    \"input_layernorm\",\n                    \"ln_f\",\n                    \"ln_attn\",\n                    \"ln_mlp\",\n                    \"post_attention_layernorm\"\n                ]\n            )\n        )\n    elif model_type == \"mpt\":\n        from .mosaic_mpt import FlaxMptForCausalLM as _FlaxMptForCausalLM\n        from .mosaic_mpt import MptConfig as _MptConfig\n        return (\n            _MptConfig,\n            _FlaxMptForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=\"wte\")\n        )\n\n    elif model_type == \"mistral\":\n        from .mistral import FlaxMistralForCausalLM as _FlaxMistralForCausalLM\n        from .mistral import MistralConfig as _MistralConfig\n        return (\n            _MistralConfig,\n            _FlaxMistralForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=[\"embed_tokens\"])\n        )\n    elif model_type == \"gptj\":\n        from .gpt_j import FlaxGPTJForCausalLM as _FlaxGPTJForCausalLM\n        from .gpt_j import GPTJConfig as _GPTJConfig\n        return (\n            _GPTJConfig,\n            _FlaxGPTJForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=\"wte\")\n        )\n\n    elif model_type == \"gpt_neox\":\n        from .gpt_neo_x import FlaxGPTNeoXForCausalLM as _FlaxGPTNeoXForCausalLM\n        from .gpt_neo_x import GPTNeoXConfig as _GPTNeoXConfig\n\n        return (\n            _GPTNeoXConfig,\n            _FlaxGPTNeoXForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=\"wte\")\n        )\n    elif model_type == \"palm\":\n        from .palm import FlaxPalmForCausalLM as _FlaxPalmForCausalLM\n        from .palm import PalmConfig as _PalmConfig\n        return (\n            _PalmConfig,\n            _FlaxPalmForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=\"wte\")\n        )\n    elif model_type == \"lt\":\n        from .lucid_transformer import FlaxLTForCausalLM as _FlaxLTForCausalLM\n        from .lucid_transformer import FlaxLTConfig as _FlaxLTConfig\n\n        return (\n            _FlaxLTConfig,\n            _FlaxLTForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=\"wte\")\n        )\n    elif model_type == \"gpt2\":\n        from .gpt2 import FlaxGPT2LMHeadModel as _FlaxGPT2LMHeadModel\n        from .gpt2 import GPT2Config as _GPT2Config\n\n        return (\n            _GPT2Config,\n            _FlaxGPT2LMHeadModel,\n            functools.partial(\n                huggingface_to_easydel,\n                embedding_layer_names=[\"wte\", \"wpe\"],\n                layer_norm_names=[\n                    \"ln_1\", \"ln_2\", \"ln_f\"\n                ]\n            )\n        )\n\n    elif model_type == \"mixtral\":\n        from .mixtral import FlaxMixtralForCausalLM as _FlaxMixtralForCausalLM\n        from .mixtral import MixtralConfig as _MixtralConfig\n        return (\n            _MixtralConfig,\n            _FlaxMixtralForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=[\"embed_tokens\"])\n        )\n    elif model_type == \"phi\":\n        from .phi import FlaxPhiForCausalLM as _FlaxPhiForCausalLM\n        from .phi import PhiConfig as _PhiConfig\n        return (\n            _PhiConfig,\n            _FlaxPhiForCausalLM,\n            functools.partial(\n                huggingface_to_easydel,\n                embedding_layer_names=[\"embed_tokens\"],\n                layer_norm_names=[\n                    \"input_layernorm\",\n                    \"final_layernorm\",\n                    \"q_layernorm\",\n                    \"k_layernorm\"\n                ])\n        )\n    if model_type == \"qwen\":\n        from .qwen1 import Qwen1Config as _Qwen1Config\n        from .qwen1 import FlaxQwenForCausalLM as _FlaxQwen1ForCausalLM\n        return (\n            _Qwen1Config,\n            _FlaxQwen1ForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=[\"wte\"])\n        )\n\n    if model_type == \"qwen2\":\n        from .qwen2 import Qwen2Config as _Qwen2Config\n        from .qwen2 import FlaxQwen2ForCausalLM as _FlaxQwen2ForCausalLM\n        return (\n            _Qwen2Config,\n            _FlaxQwen2ForCausalLM,\n            functools.partial(huggingface_to_easydel, embedding_layer_names=[\"embed_tokens\"])\n        )\n    else:\n        raise EasyDelRuntimeError(f'Model Type ({model_type}) is not supported or is not found')\n</code></pre>"},{"location":"generated-modules-auto_easydel_model/#lib.python.EasyDel.modules.auto_easydel_model.is_flatten","title":"<code>is_flatten(pytree)</code>","text":"<p>The is_flatten function checks if the pytree is flattened.     If it is, then the first key in the dictionary will be a tuple of (mpl, mpl_id).     Otherwise, it will be an integer representing mpl_id.</p> <p>Parameters:</p> Name Type Description Default <code>pytree</code> <code>dict</code> <p>dict: Pass the pytree to the function</p> required <p>Returns:</p> Type Description <p>True if the pytree is a flattened tree, and false otherwise</p> Source code in <code>lib/python/EasyDel/modules/auto_easydel_model.py</code> <pre><code>def is_flatten(pytree: dict):\n    \"\"\"\n    The is_flatten function checks if the pytree is flattened.\n        If it is, then the first key in the dictionary will be a tuple of (mpl, mpl_id).\n        Otherwise, it will be an integer representing mpl_id.\n\n    :param pytree: dict: Pass the pytree to the function\n    :return: True if the pytree is a flattened tree, and false otherwise\n\n    \"\"\"\n    mpl = [k for k in pytree.keys()][0]\n    return True if isinstance(mpl, tuple) else False\n</code></pre>"},{"location":"generated-modules-easy_attention/","title":"modules.easy_attention","text":""},{"location":"generated-modules-easy_attention/#lib.python.EasyDel.modules.easy_attention.get_flash_attention","title":"<code>get_flash_attention()</code>","text":"<p>return: FlashAttention FN, Upcast Needed to float32,do_shard_map</p> Source code in <code>lib/python/EasyDel/modules/easy_attention.py</code> <pre><code>def get_flash_attention() -&gt; Tuple[Callable, bool, bool]:\n    \"\"\"\n    return: FlashAttention FN, Upcast Needed to float32,do_shard_map\n    \"\"\"\n    platform = jax.lib.xla_bridge.get_backend().platform\n    if platform == \"gpu\":\n        float32_logits = False\n        ring_attention_fn = flash_attn_gpu.mha\n        do_shard_map = True\n    elif platform == \"tpu\":\n        float32_logits = True\n        ring_attention_fn = flash_attn_tpu.flash_attention\n        do_shard_map = False\n    else:\n        raise ValueError(f\"Unsupported platform {platform}\")\n\n    return ring_attention_fn, float32_logits, do_shard_map\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/","title":"modules.easydel_modelling_utils","text":""},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel","title":"<code>EasyDelFlaxPretrainedModel</code>","text":"<p>             Bases: <code>FlaxPreTrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>class EasyDelFlaxPretrainedModel(FlaxPreTrainedModel):\n\n    def get_input_embeddings(self):\n        \"\"\"\n        The get_input_embeddings function returns the embedding layer of the model.\n\n        :param self: Refer to the current object\n        :return: The embedding layer of the model\n        \"\"\"\n        raise NotImplementedError()\n\n    def set_input_embeddings(self, value):\n        \"\"\"\n        The set_input_embeddings function is used to set the embedding module of the model.\n\n        :param self: Represent the instance of the class\n        :param value: Set the embeddings of the model\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_output_embeddings(self):\n        \"\"\"\n        The get_output_embeddings function returns the output embeddings of a model.\n\n        :param self: Represent the instance of the class\n        :return: The output embeddings of the model\n        \"\"\"\n        raise NotImplementedError()\n\n    def set_output_embeddings(self, new_embeddings):\n        \"\"\"\n        The set_output_embeddings function is used to set the output embeddings of a model.\n        This function can be used to change the output embedding layer of a pretrained model in order to finetune it\n        to some downstream task. Changing this layer has an effect only if the model has already been fine-tuned on some\n        task (e.g., for classification). If you are training your own language models, you should call this function before\n        you start training.\n\n        :param self: Represent the instance of the class\n        :param new_embeddings: Set the embeddings of the output layer\n        :return: A new embedding layer\n        \"\"\"\n        raise NotImplementedError()\n\n    def set_decoder(self, decoder):\n        \"\"\"\n        The set_decoder function is used to set the decoder for a given encoder.\n\n        :param self: Refer to the object itself\n        :param decoder: Set the decoder for a given encoder\n        :return: A decoder\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_decoder(self):\n        \"\"\"\n        The get_decoder function is used to create a decoder object.\n\n        :param self: Represent the instance of the class\n        :return: A decoder object\n        \"\"\"\n        raise NotImplementedError()\n\n    def init_cache(self, batch_size: int, max_length: int):\n        raise NotImplementedError(\"init_cache is not Implemented Yet!\")\n\n    def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n        \"\"\"\n        The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.\n\n        :param self: Access variables that belong to the class\n        :param input_ids: Pass in the input tokens\n        :param max_length: Set the length of the sequence to be generated\n        :param attention_mask: Optional[chex.Array]: Mask the attention weights\n        :return: A dictionary of the past_key_values, attention_mask and position ids\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n\n        past_key_values = self.init_cache(batch_size, max_length)\n        extended_attention_mask = jnp.ones(\n            (batch_size, max_length), dtype=\"i4\")\n        if attention_mask is not None:\n            position_ids = attention_mask.cumsum(axis=-1) - 1\n            extended_attention_mask = jax.lax.dynamic_update_slice(\n                extended_attention_mask, attention_mask, (0, 0))\n        else:\n            position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[\n                                            None, :], (batch_size, seq_length))\n\n        return {\n            \"past_key_values\": past_key_values,\n            \"attention_mask\": extended_attention_mask,\n            \"position_ids\": position_ids,\n        }\n\n    def update_inputs_for_generation(self, model_outputs, model_kwargs):\n        model_kwargs[\"past_key_values\"] = model_outputs.past_key_values\n        model_kwargs[\"position_ids\"] = model_kwargs[\"position_ids\"][:, -1:] + 1\n        return model_kwargs\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array = None,\n            position_ids: chex.Array = None,\n            params: dict = None,\n            past_key_values: dict = None,\n            dropout_rng: jax.random.PRNGKey = None,\n            train: bool = False,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            return_dict: Optional[bool] = None,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None,\n            add_params_field: bool = False,\n            **kwargs\n    ):\n        raise NotImplementedError(\"Not Implemented Yet\")\n\n    def __repr__(self):\n\n        \"\"\"\n        The __repr__ function is used to generate a string representation of an object.\n        This function should return a string that can be parsed by the Python interpreter\n        to recreate the object. The __repr__ function is called when you use print() on an\n        object, or when you type its name in the REPL.\n\n        :param self: Refer to the instance of the class\n        :return: A string representation of the object\n        \"\"\"\n        string = f\"{self.__class__.__name__}(\\n\"\n        for k, v in self.__dict__.items():\n            if not k.startswith(\"_\"):\n                try:\n                    repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n                    string += repr_src if len(repr_src) &lt; 500 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n                except TypeError:\n                    pass\n        return string + \")\"\n\n    def __str__(self):\n\n        \"\"\"\n        The __str__ function is called when you use the print function or when str() is used.\n        It should return a string representation of the object.\n\n        :param self: Refer to the instance of the class\n        :return: The object's string representation\n        \"\"\"\n        return self.__repr__()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.__repr__","title":"<code>__repr__()</code>","text":"<p>The repr function is used to generate a string representation of an object. This function should return a string that can be parsed by the Python interpreter to recreate the object. The repr function is called when you use print() on an object, or when you type its name in the REPL.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>A string representation of the object</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def __repr__(self):\n\n    \"\"\"\n    The __repr__ function is used to generate a string representation of an object.\n    This function should return a string that can be parsed by the Python interpreter\n    to recreate the object. The __repr__ function is called when you use print() on an\n    object, or when you type its name in the REPL.\n\n    :param self: Refer to the instance of the class\n    :return: A string representation of the object\n    \"\"\"\n    string = f\"{self.__class__.__name__}(\\n\"\n    for k, v in self.__dict__.items():\n        if not k.startswith(\"_\"):\n            try:\n                repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n                string += repr_src if len(repr_src) &lt; 500 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n            except TypeError:\n                pass\n    return string + \")\"\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.__str__","title":"<code>__str__()</code>","text":"<p>The str function is called when you use the print function or when str() is used. It should return a string representation of the object.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>The object's string representation</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def __str__(self):\n\n    \"\"\"\n    The __str__ function is called when you use the print function or when str() is used.\n    It should return a string representation of the object.\n\n    :param self: Refer to the instance of the class\n    :return: The object's string representation\n    \"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.get_decoder","title":"<code>get_decoder()</code>","text":"<p>The get_decoder function is used to create a decoder object.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A decoder object</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def get_decoder(self):\n    \"\"\"\n    The get_decoder function is used to create a decoder object.\n\n    :param self: Represent the instance of the class\n    :return: A decoder object\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.get_input_embeddings","title":"<code>get_input_embeddings()</code>","text":"<p>The get_input_embeddings function returns the embedding layer of the model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the current object</p> required <p>Returns:</p> Type Description <p>The embedding layer of the model</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def get_input_embeddings(self):\n    \"\"\"\n    The get_input_embeddings function returns the embedding layer of the model.\n\n    :param self: Refer to the current object\n    :return: The embedding layer of the model\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.get_output_embeddings","title":"<code>get_output_embeddings()</code>","text":"<p>The get_output_embeddings function returns the output embeddings of a model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>The output embeddings of the model</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def get_output_embeddings(self):\n    \"\"\"\n    The get_output_embeddings function returns the output embeddings of a model.\n\n    :param self: Represent the instance of the class\n    :return: The output embeddings of the model\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.prepare_inputs_for_generation","title":"<code>prepare_inputs_for_generation(input_ids, max_length, attention_mask=None)</code>","text":"<p>The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>input_ids</code> <p>Pass in the input tokens</p> required <code>max_length</code> <p>Set the length of the sequence to be generated</p> required <code>attention_mask</code> <code>Optional[Array]</code> <p>Optional[chex.Array]: Mask the attention weights</p> <code>None</code> <p>Returns:</p> Type Description <p>A dictionary of the past_key_values, attention_mask and position ids</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n    \"\"\"\n    The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.\n\n    :param self: Access variables that belong to the class\n    :param input_ids: Pass in the input tokens\n    :param max_length: Set the length of the sequence to be generated\n    :param attention_mask: Optional[chex.Array]: Mask the attention weights\n    :return: A dictionary of the past_key_values, attention_mask and position ids\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n\n    past_key_values = self.init_cache(batch_size, max_length)\n    extended_attention_mask = jnp.ones(\n        (batch_size, max_length), dtype=\"i4\")\n    if attention_mask is not None:\n        position_ids = attention_mask.cumsum(axis=-1) - 1\n        extended_attention_mask = jax.lax.dynamic_update_slice(\n            extended_attention_mask, attention_mask, (0, 0))\n    else:\n        position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[\n                                        None, :], (batch_size, seq_length))\n\n    return {\n        \"past_key_values\": past_key_values,\n        \"attention_mask\": extended_attention_mask,\n        \"position_ids\": position_ids,\n    }\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.set_decoder","title":"<code>set_decoder(decoder)</code>","text":"<p>The set_decoder function is used to set the decoder for a given encoder.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>decoder</code> <p>Set the decoder for a given encoder</p> required <p>Returns:</p> Type Description <p>A decoder</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def set_decoder(self, decoder):\n    \"\"\"\n    The set_decoder function is used to set the decoder for a given encoder.\n\n    :param self: Refer to the object itself\n    :param decoder: Set the decoder for a given encoder\n    :return: A decoder\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.set_input_embeddings","title":"<code>set_input_embeddings(value)</code>","text":"<p>The set_input_embeddings function is used to set the embedding module of the model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>value</code> <p>Set the embeddings of the model</p> required Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def set_input_embeddings(self, value):\n    \"\"\"\n    The set_input_embeddings function is used to set the embedding module of the model.\n\n    :param self: Represent the instance of the class\n    :param value: Set the embeddings of the model\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelFlaxPretrainedModel.set_output_embeddings","title":"<code>set_output_embeddings(new_embeddings)</code>","text":"<p>The set_output_embeddings function is used to set the output embeddings of a model. This function can be used to change the output embedding layer of a pretrained model in order to finetune it to some downstream task. Changing this layer has an effect only if the model has already been fine-tuned on some task (e.g., for classification). If you are training your own language models, you should call this function before you start training.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>new_embeddings</code> <p>Set the embeddings of the output layer</p> required <p>Returns:</p> Type Description <p>A new embedding layer</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def set_output_embeddings(self, new_embeddings):\n    \"\"\"\n    The set_output_embeddings function is used to set the output embeddings of a model.\n    This function can be used to change the output embedding layer of a pretrained model in order to finetune it\n    to some downstream task. Changing this layer has an effect only if the model has already been fine-tuned on some\n    task (e.g., for classification). If you are training your own language models, you should call this function before\n    you start training.\n\n    :param self: Represent the instance of the class\n    :param new_embeddings: Set the embeddings of the output layer\n    :return: A new embedding layer\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig","title":"<code>EasyDelPretrainedConfig</code>","text":"<p>             Bases: <code>PretrainedConfig</code></p> <p>It initializes all the attributes of an object, and it's called when you create a new instance of that class.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <code>axis_dims</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the number of dimensions for each axis</p> <code>(1, -1, 1, 1)</code> <code>axis_names</code> <code>Sequence[str]</code> <p>Sequence[str]: Set the names of the axes</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>attn_mechanism</code> <code>Literal['normal', 'flash', 'splash']</code> <p>Literal[\"normal\", \"flash\", \"splash\"]: attention mechanism to use</p> <code>'normal'</code> <code>block_k</code> <code>int</code> <p>int: block size of key_states</p> <code>128</code> <code>block_q</code> <code>int</code> <p>int: block size of query_states</p> <code>128</code> <code>block_b</code> <code>int</code> <p>int: block size of bias</p> <code>1</code> <code>block_q_major_dkv</code> <code>int | None</code> <p>int: block size of block_q_major_dkv</p> <code>None</code> <code>block_k_major_dkv</code> <code>int | None</code> <p>int: block size of block_k_major_dkv</p> <code>None</code> <code>block_k_dkv</code> <code>int | None</code> <p>int: block size of block_k_dkv</p> <code>None</code> <code>block_q_dkv</code> <code>int | None</code> <p>int: block size of block_q_dkv</p> <code>None</code> <code>block_k_major_dq</code> <code>int | None</code> <p>int: block size of block_k_major_dq</p> <code>None</code> <code>block_k_dq</code> <code>int | None</code> <p>int: block size of block_k_dq</p> <code>None</code> <code>block_q_dq</code> <code>int | None</code> <p>int: block size of block_q_dq</p> <code>None</code> <code>query_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Specify the partitioning of the query tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>key_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Partition the key matrix</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>value_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Specify the partitioning of the value tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>bias_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Specify the Attention Bias partition spec</p> <code>PartitionSpec(('dp', 'fsdp'), None, None, None)</code> <code>attention_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Specify the partitioning of the attention weights</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>use_shard_map</code> <code>bool</code> <p>bool: whenever to use shard_map for attention</p> <code>False</code> <code>backend</code> <code>Optional[None]</code> <p>Optional[None]: Specify the backend to use</p> <code>default_backend()</code> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>class EasyDelPretrainedConfig(PretrainedConfig):\n    \"\"\"\n    It initializes all the attributes of an object, and it's called when you create a new instance of that class.\n    :param self: Refer to the instance of the class\n    :param axis_dims: Sequence[int]: Specify the number of dimensions for each axis\n    :param axis_names: Sequence[str]: Set the names of the axes\n    :param attn_mechanism: Literal[\"normal\", \"flash\", \"splash\"]: attention mechanism to use\n    :param block_k: int: block size of key_states\n    :param block_q: int: block size of query_states\n    :param block_b: int: block size of bias\n    :param block_q_major_dkv: int: block size of block_q_major_dkv\n    :param block_k_major_dkv: int: block size of block_k_major_dkv\n    :param block_k_dkv: int: block size of block_k_dkv\n    :param block_q_dkv: int: block size of block_q_dkv\n    :param block_k_major_dq: int: block size of block_k_major_dq\n    :param block_k_dq: int: block size of block_k_dq\n    :param block_q_dq: int: block size of block_q_dq\n    :param query_partition_spec: PartitionSpec: Specify the partitioning of the query tensor\n    :param key_partition_spec: PartitionSpec: Partition the key matrix\n    :param value_partition_spec: PartitionSpec: Specify the partitioning of the value tensor\n    :param bias_partition_spec: PartitionSpec: Specify the Attention Bias partition spec\n    :param attention_partition_spec: PartitionSpec: Specify the partitioning of the attention weights\n    :param use_shard_map: bool: whenever to use shard_map for attention\n    :param backend: Optional[None]: Specify the backend to use\n    \"\"\"\n\n    def __init__(\n            self,\n            axis_dims: Sequence[int] = (1, -1, 1, 1),\n            axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n            attn_mechanism: Literal[\"normal\", \"flash\", \"splash\"] = \"normal\",\n            block_k: int = 128,\n            block_q: int = 128,\n            block_b: int = 1,\n            block_k_major: int = 128,\n            block_q_major_dkv: int | None = None,\n            block_k_major_dkv: int | None = None,\n            block_k_dkv: int | None = None,\n            block_q_dkv: int | None = None,\n            block_k_major_dq: int | None = None,\n            block_k_dq: int | None = None,\n            block_q_dq: int | None = None,\n            query_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n            ),\n            key_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n            ),\n            value_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n            ),\n            bias_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), None, None, None\n            ),\n            attention_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n            ),\n            use_shard_map: bool = False,\n            backend: Optional[None] = jax.default_backend(),\n            easy_method: Literal[\"train\", \"serve\", \"convert\"] = EasyMethod.TRAIN,\n            bits: Optional[int] = None,\n            **kwargs\n    ):\n        self.query_partition_spec = query_partition_spec\n        self.key_partition_spec = key_partition_spec\n        self.value_partition_spec = value_partition_spec\n        self.bias_partition_spec = bias_partition_spec\n        self.attention_partition_spec = attention_partition_spec\n        self.use_shard_map = use_shard_map\n        self.axis_dims = axis_dims\n        self.axis_names = axis_names\n        self.backend = backend if backend is not None else \"\"\n        self.easy_method = easy_method\n        self.attn_mechanism = attn_mechanism\n        self.block_b = block_b\n        self.block_k = block_k\n        self.block_q = block_q\n        self.block_k_major = block_k_major\n        self.block_q_major_dkv = block_q_major_dkv or block_q\n        self.block_k_major_dkv = block_k_major_dkv or block_k\n        self.block_k_dkv = block_k_dkv or block_k\n        self.block_q_dkv = block_q_dkv or block_q\n        self.block_k_major_dq = block_k_major_dq or block_k\n        self.block_k_dq = block_k_dq or block_k\n        self.block_q_dq = block_q_dq or block_q\n        self.bits = bits\n        super().__init__(**kwargs)\n\n    @staticmethod\n    def create_mesh(\n            axis_dims: Sequence[int] = (1, -1, 1, 1), axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"), backend=\"\"\n    ):\n        \"\"\"\n        The create_mesh function creates a mesh object that can be used to shard arrays.\n\n        :param axis_dims: Sequence[int]: Specify the dimensions of the mesh\n        :param axis_names: Sequence[str]: Name the axes of the mesh\n        :param backend: Specify the backend to use\n        :return: A mesh object\n\n        \"\"\"\n        array_devices = jax.numpy.ones(\n            (len(jax.devices() if backend == \"\" else jax.devices(backend)), 1))\n        resh = array_devices.reshape(axis_dims).shape\n\n        return Mesh(\n            create_device_mesh(resh), axis_names\n        )\n\n    def jax_mesh(self) -&gt; Mesh:\n        \"\"\"\n        The jax_mesh function is a helper function that creates a Mesh object from the\n        axis_dims and axis_names attributes of an object, which are assumed to be lists of integers and strings, respectively.\n        The backend attribute is also used if it exists.\n\n        :param self: Refer to the object itself\n        :return: A jaxMesh\n\n        \"\"\"\n        return self.create_mesh(\n            axis_dims=[v for k, v in self.axis_dims.items()] if isinstance(self.axis_dims, dict) else self.axis_dims,\n            axis_names=[v for k, v in self.axis_names.items()] if isinstance(self.axis_names,\n                                                                             dict) else self.axis_names,\n            backend=(self.backend if self.backend is not None else \"\") if hasattr(\n                self, 'backend') else \"\"\n        )\n\n    def get_partition_rules(self, fully_sharded_data_parallel: bool = True):\n\n        \"\"\"\n        The get_partition_rules function is used to specify how the parameters of a model are partitioned across devices.\n\n        :param self: Access the attributes of the class\n        :param fully_sharded_data_parallel: bool: Determine whether the model is fully sharded or not\n        :return: A tuple of tuples\n        \"\"\"\n        if not fully_sharded_data_parallel:\n            raise NotImplementedError()\n        else:\n            return (\n                ('.*', PartitionSpec((\"fsdp\", \"sp\")))\n            )\n\n    def get_axis_dims(self) -&gt; Sequence[int]:\n        \"\"\"\n        The get_axis_dims function returns a sequence of integers representing the dimensions of each axis.\n\n        :param self: Represent the instance of the class\n        :return: The dimensions of the axes\n\n        \"\"\"\n        return self.axis_dims\n\n    def get_axis_names(self) -&gt; Sequence[str]:\n        \"\"\"\n        The get_axis_names function returns a list of the names of the axes.\n\n        :param self: Represent the instance of the class\n        :return: A list of the names of all axes\n\n        \"\"\"\n        return self.axis_names\n\n    def get_backend(self) -&gt; str:\n        \"\"\"\n        The get_backend function returns the backend that is currently being used.\n        If no backend has been set, it will return the default JAX backend.\n\n        :param self: Bind the method to an object\n        :return: The backend platform\n\n        \"\"\"\n        return self.backend if not self.backend == \"\" else jax.lib.xla_bridge.get_backend().platform\n\n    def add_basic_configurations(\n            self,\n            axis_dims: Sequence[int] = (1, -1, 1, 1),\n            axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n            attn_mechanism: Literal[\"normal\", \"flash\", \"splash\"] = \"normal\",\n            block_k: int = 128,\n            block_q: int = 128,\n            block_b: int = 1,\n            block_k_major: int = 128,\n            block_q_major_dkv: int | None = None,\n            block_k_major_dkv: int | None = None,\n            block_k_dkv: int | None = None,\n            block_q_dkv: int | None = None,\n            block_k_major_dq: int | None = None,\n            block_k_dq: int | None = None,\n            block_q_dq: int | None = None,\n            query_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n            ),\n            key_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n            ),\n            value_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n            ),\n            bias_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), None, None, None\n            ),\n            attention_partition_spec: PartitionSpec = PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n            ),\n            use_shard_map: bool = False,\n            backend: Optional[None] = jax.default_backend(),\n            easy_method: Literal[\"train\", \"serve\", \"convert\"] = EasyMethod.TRAIN,\n            bits: Optional[int] = None,\n    ):\n        \"\"\"\n            It initializes all the attributes of an object, and it's called when you create a new instance of that class.\n            :param self: Refer to the instance of the class\n            :param axis_dims: Sequence[int]: Specify the number of dimensions for each axis\n            :param axis_names: Sequence[str]: Set the names of the axes\n            :param attn_mechanism: Literal[\"normal\", \"flash\", \"splash\"]: attention mechanism to use\n            :param block_k: int: block size of key_states\n            :param block_q: int: block size of query_states\n            :param block_b: int: block size of bias\n            :param block_q_major_dkv: int: block size of block_q_major_dkv\n            :param block_k_major_dkv: int: block size of block_k_major_dkv\n            :param block_k_dkv: int: block size of block_k_dkv\n            :param block_q_dkv: int: block size of block_q_dkv\n            :param block_k_major_dq: int: block size of block_k_major_dq\n            :param block_k_dq: int: block size of block_k_dq\n            :param block_q_dq: int: block size of block_q_dq\n            :param query_partition_spec: PartitionSpec: Specify the partitioning of the query tensor\n            :param key_partition_spec: PartitionSpec: Partition the key matrix\n            :param value_partition_spec: PartitionSpec: Specify the partitioning of the value tensor\n            :param bias_partition_spec: PartitionSpec: Specify the Attention Bias partition spec\n            :param attention_partition_spec: PartitionSpec: Specify the partitioning of the attention weights\n            :param use_shard_map: bool: whenever to use shard_map for attention\n            :param backend: Optional[None]: Specify the backend to use\n            :param easy_method: Literal[\"train\", \"serve\", \"convert\"]: EasyDel Quantization Method to be applied for\n            :param bits: Optional[int]: Model bits for quantization\n        \"\"\"\n        self.axis_dims = axis_dims\n        self.axis_names = axis_names\n        self.query_partition_spec = query_partition_spec\n        self.key_partition_spec = key_partition_spec\n        self.value_partition_spec = value_partition_spec\n        self.bias_partition_spec = bias_partition_spec\n        self.attention_partition_spec = attention_partition_spec\n        self.backend = backend\n        self.use_shard_map = use_shard_map\n        self.attn_mechanism = attn_mechanism\n        self.block_b = block_b\n        self.block_k = block_k\n        self.block_q = block_q\n        self.block_k_major = block_k_major\n        self.block_q_major_dkv = block_q_major_dkv or block_q\n        self.block_k_major_dkv = block_k_major_dkv or block_k\n        self.block_k_dkv = block_k_dkv or block_k\n        self.block_q_dkv = block_q_dkv or block_q\n        self.block_k_major_dq = block_k_major_dq or block_k\n        self.block_k_dq = block_k_dq or block_k\n        self.block_q_dq = block_q_dq or block_q\n        self.easy_method = easy_method\n        self.bits = bits\n\n    def __repr__(self):\n\n        \"\"\"\n        The __repr__ function is used to generate a string representation of an object.\n        This function should return a string that can be parsed by the Python interpreter\n        to recreate the object. The __repr__ function is called when you use print() on an\n        object, or when you type its name in the REPL.\n\n        :param self: Refer to the instance of the class\n        :return: A string representation of the object\n        \"\"\"\n        string = f\"{self.__class__.__name__}(\\n\"\n        for k, v in self.__dict__.items():\n            if not k.startswith(\"_\"):\n                try:\n                    repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n                    string += repr_src if len(repr_src) &lt; 500 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n                except TypeError:\n                    pass\n        return string + \")\"\n\n    def __str__(self):\n\n        \"\"\"\n        The __str__ function is called when you use the print function or when str() is used.\n        It should return a string representation of the object.\n\n        :param self: Refer to the instance of the class\n        :return: The object's string representation\n        \"\"\"\n        return self.__repr__()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.__repr__","title":"<code>__repr__()</code>","text":"<p>The repr function is used to generate a string representation of an object. This function should return a string that can be parsed by the Python interpreter to recreate the object. The repr function is called when you use print() on an object, or when you type its name in the REPL.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>A string representation of the object</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def __repr__(self):\n\n    \"\"\"\n    The __repr__ function is used to generate a string representation of an object.\n    This function should return a string that can be parsed by the Python interpreter\n    to recreate the object. The __repr__ function is called when you use print() on an\n    object, or when you type its name in the REPL.\n\n    :param self: Refer to the instance of the class\n    :return: A string representation of the object\n    \"\"\"\n    string = f\"{self.__class__.__name__}(\\n\"\n    for k, v in self.__dict__.items():\n        if not k.startswith(\"_\"):\n            try:\n                repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n                string += repr_src if len(repr_src) &lt; 500 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n            except TypeError:\n                pass\n    return string + \")\"\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.__str__","title":"<code>__str__()</code>","text":"<p>The str function is called when you use the print function or when str() is used. It should return a string representation of the object.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>The object's string representation</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def __str__(self):\n\n    \"\"\"\n    The __str__ function is called when you use the print function or when str() is used.\n    It should return a string representation of the object.\n\n    :param self: Refer to the instance of the class\n    :return: The object's string representation\n    \"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.add_basic_configurations","title":"<code>add_basic_configurations(axis_dims=(1, -1, 1, 1), axis_names=('dp', 'fsdp', 'tp', 'sp'), attn_mechanism='normal', block_k=128, block_q=128, block_b=1, block_k_major=128, block_q_major_dkv=None, block_k_major_dkv=None, block_k_dkv=None, block_q_dkv=None, block_k_major_dq=None, block_k_dq=None, block_q_dq=None, query_partition_spec=PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), key_partition_spec=PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), value_partition_spec=PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), bias_partition_spec=PartitionSpec(('dp', 'fsdp'), None, None, None), attention_partition_spec=PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None), use_shard_map=False, backend=jax.default_backend(), easy_method=EasyMethod.TRAIN, bits=None)</code>","text":"<p>It initializes all the attributes of an object, and it's called when you create a new instance of that class.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <code>axis_dims</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the number of dimensions for each axis</p> <code>(1, -1, 1, 1)</code> <code>axis_names</code> <code>Sequence[str]</code> <p>Sequence[str]: Set the names of the axes</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>attn_mechanism</code> <code>Literal['normal', 'flash', 'splash']</code> <p>Literal[\"normal\", \"flash\", \"splash\"]: attention mechanism to use</p> <code>'normal'</code> <code>block_k</code> <code>int</code> <p>int: block size of key_states</p> <code>128</code> <code>block_q</code> <code>int</code> <p>int: block size of query_states</p> <code>128</code> <code>block_b</code> <code>int</code> <p>int: block size of bias</p> <code>1</code> <code>block_q_major_dkv</code> <code>int | None</code> <p>int: block size of block_q_major_dkv</p> <code>None</code> <code>block_k_major_dkv</code> <code>int | None</code> <p>int: block size of block_k_major_dkv</p> <code>None</code> <code>block_k_dkv</code> <code>int | None</code> <p>int: block size of block_k_dkv</p> <code>None</code> <code>block_q_dkv</code> <code>int | None</code> <p>int: block size of block_q_dkv</p> <code>None</code> <code>block_k_major_dq</code> <code>int | None</code> <p>int: block size of block_k_major_dq</p> <code>None</code> <code>block_k_dq</code> <code>int | None</code> <p>int: block size of block_k_dq</p> <code>None</code> <code>block_q_dq</code> <code>int | None</code> <p>int: block size of block_q_dq</p> <code>None</code> <code>query_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Specify the partitioning of the query tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>key_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Partition the key matrix</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>value_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Specify the partitioning of the value tensor</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>bias_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Specify the Attention Bias partition spec</p> <code>PartitionSpec(('dp', 'fsdp'), None, None, None)</code> <code>attention_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Specify the partitioning of the attention weights</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp', 'tp', None)</code> <code>use_shard_map</code> <code>bool</code> <p>bool: whenever to use shard_map for attention</p> <code>False</code> <code>backend</code> <code>Optional[None]</code> <p>Optional[None]: Specify the backend to use</p> <code>default_backend()</code> <code>easy_method</code> <code>Literal['train', 'serve', 'convert']</code> <p>Literal[\"train\", \"serve\", \"convert\"]: EasyDel Quantization Method to be applied for</p> <code>TRAIN</code> <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Model bits for quantization</p> <code>None</code> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def add_basic_configurations(\n        self,\n        axis_dims: Sequence[int] = (1, -1, 1, 1),\n        axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n        attn_mechanism: Literal[\"normal\", \"flash\", \"splash\"] = \"normal\",\n        block_k: int = 128,\n        block_q: int = 128,\n        block_b: int = 1,\n        block_k_major: int = 128,\n        block_q_major_dkv: int | None = None,\n        block_k_major_dkv: int | None = None,\n        block_k_dkv: int | None = None,\n        block_q_dkv: int | None = None,\n        block_k_major_dq: int | None = None,\n        block_k_dq: int | None = None,\n        block_q_dq: int | None = None,\n        query_partition_spec: PartitionSpec = PartitionSpec(\n            (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n        ),\n        key_partition_spec: PartitionSpec = PartitionSpec(\n            (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n        ),\n        value_partition_spec: PartitionSpec = PartitionSpec(\n            (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n        ),\n        bias_partition_spec: PartitionSpec = PartitionSpec(\n            (\"dp\", \"fsdp\"), None, None, None\n        ),\n        attention_partition_spec: PartitionSpec = PartitionSpec(\n            (\"dp\", \"fsdp\"), \"sp\", \"tp\", None\n        ),\n        use_shard_map: bool = False,\n        backend: Optional[None] = jax.default_backend(),\n        easy_method: Literal[\"train\", \"serve\", \"convert\"] = EasyMethod.TRAIN,\n        bits: Optional[int] = None,\n):\n    \"\"\"\n        It initializes all the attributes of an object, and it's called when you create a new instance of that class.\n        :param self: Refer to the instance of the class\n        :param axis_dims: Sequence[int]: Specify the number of dimensions for each axis\n        :param axis_names: Sequence[str]: Set the names of the axes\n        :param attn_mechanism: Literal[\"normal\", \"flash\", \"splash\"]: attention mechanism to use\n        :param block_k: int: block size of key_states\n        :param block_q: int: block size of query_states\n        :param block_b: int: block size of bias\n        :param block_q_major_dkv: int: block size of block_q_major_dkv\n        :param block_k_major_dkv: int: block size of block_k_major_dkv\n        :param block_k_dkv: int: block size of block_k_dkv\n        :param block_q_dkv: int: block size of block_q_dkv\n        :param block_k_major_dq: int: block size of block_k_major_dq\n        :param block_k_dq: int: block size of block_k_dq\n        :param block_q_dq: int: block size of block_q_dq\n        :param query_partition_spec: PartitionSpec: Specify the partitioning of the query tensor\n        :param key_partition_spec: PartitionSpec: Partition the key matrix\n        :param value_partition_spec: PartitionSpec: Specify the partitioning of the value tensor\n        :param bias_partition_spec: PartitionSpec: Specify the Attention Bias partition spec\n        :param attention_partition_spec: PartitionSpec: Specify the partitioning of the attention weights\n        :param use_shard_map: bool: whenever to use shard_map for attention\n        :param backend: Optional[None]: Specify the backend to use\n        :param easy_method: Literal[\"train\", \"serve\", \"convert\"]: EasyDel Quantization Method to be applied for\n        :param bits: Optional[int]: Model bits for quantization\n    \"\"\"\n    self.axis_dims = axis_dims\n    self.axis_names = axis_names\n    self.query_partition_spec = query_partition_spec\n    self.key_partition_spec = key_partition_spec\n    self.value_partition_spec = value_partition_spec\n    self.bias_partition_spec = bias_partition_spec\n    self.attention_partition_spec = attention_partition_spec\n    self.backend = backend\n    self.use_shard_map = use_shard_map\n    self.attn_mechanism = attn_mechanism\n    self.block_b = block_b\n    self.block_k = block_k\n    self.block_q = block_q\n    self.block_k_major = block_k_major\n    self.block_q_major_dkv = block_q_major_dkv or block_q\n    self.block_k_major_dkv = block_k_major_dkv or block_k\n    self.block_k_dkv = block_k_dkv or block_k\n    self.block_q_dkv = block_q_dkv or block_q\n    self.block_k_major_dq = block_k_major_dq or block_k\n    self.block_k_dq = block_k_dq or block_k\n    self.block_q_dq = block_q_dq or block_q\n    self.easy_method = easy_method\n    self.bits = bits\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.create_mesh","title":"<code>create_mesh(axis_dims=(1, -1, 1, 1), axis_names=('dp', 'fsdp', 'tp', 'sp'), backend='')</code>  <code>staticmethod</code>","text":"<p>The create_mesh function creates a mesh object that can be used to shard arrays.</p> <p>Parameters:</p> Name Type Description Default <code>axis_dims</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the dimensions of the mesh</p> <code>(1, -1, 1, 1)</code> <code>axis_names</code> <code>Sequence[str]</code> <p>Sequence[str]: Name the axes of the mesh</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>backend</code> <p>Specify the backend to use</p> <code>''</code> <p>Returns:</p> Type Description <p>A mesh object</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>@staticmethod\ndef create_mesh(\n        axis_dims: Sequence[int] = (1, -1, 1, 1), axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"), backend=\"\"\n):\n    \"\"\"\n    The create_mesh function creates a mesh object that can be used to shard arrays.\n\n    :param axis_dims: Sequence[int]: Specify the dimensions of the mesh\n    :param axis_names: Sequence[str]: Name the axes of the mesh\n    :param backend: Specify the backend to use\n    :return: A mesh object\n\n    \"\"\"\n    array_devices = jax.numpy.ones(\n        (len(jax.devices() if backend == \"\" else jax.devices(backend)), 1))\n    resh = array_devices.reshape(axis_dims).shape\n\n    return Mesh(\n        create_device_mesh(resh), axis_names\n    )\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.get_axis_dims","title":"<code>get_axis_dims()</code>","text":"<p>The get_axis_dims function returns a sequence of integers representing the dimensions of each axis.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <code>Sequence[int]</code> <p>The dimensions of the axes</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def get_axis_dims(self) -&gt; Sequence[int]:\n    \"\"\"\n    The get_axis_dims function returns a sequence of integers representing the dimensions of each axis.\n\n    :param self: Represent the instance of the class\n    :return: The dimensions of the axes\n\n    \"\"\"\n    return self.axis_dims\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.get_axis_names","title":"<code>get_axis_names()</code>","text":"<p>The get_axis_names function returns a list of the names of the axes.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <code>Sequence[str]</code> <p>A list of the names of all axes</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def get_axis_names(self) -&gt; Sequence[str]:\n    \"\"\"\n    The get_axis_names function returns a list of the names of the axes.\n\n    :param self: Represent the instance of the class\n    :return: A list of the names of all axes\n\n    \"\"\"\n    return self.axis_names\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.get_backend","title":"<code>get_backend()</code>","text":"<p>The get_backend function returns the backend that is currently being used. If no backend has been set, it will return the default JAX backend.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Bind the method to an object</p> required <p>Returns:</p> Type Description <code>str</code> <p>The backend platform</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def get_backend(self) -&gt; str:\n    \"\"\"\n    The get_backend function returns the backend that is currently being used.\n    If no backend has been set, it will return the default JAX backend.\n\n    :param self: Bind the method to an object\n    :return: The backend platform\n\n    \"\"\"\n    return self.backend if not self.backend == \"\" else jax.lib.xla_bridge.get_backend().platform\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.get_partition_rules","title":"<code>get_partition_rules(fully_sharded_data_parallel=True)</code>","text":"<p>The get_partition_rules function is used to specify how the parameters of a model are partitioned across devices.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the attributes of the class</p> required <code>fully_sharded_data_parallel</code> <code>bool</code> <p>bool: Determine whether the model is fully sharded or not</p> <code>True</code> <p>Returns:</p> Type Description <p>A tuple of tuples</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def get_partition_rules(self, fully_sharded_data_parallel: bool = True):\n\n    \"\"\"\n    The get_partition_rules function is used to specify how the parameters of a model are partitioned across devices.\n\n    :param self: Access the attributes of the class\n    :param fully_sharded_data_parallel: bool: Determine whether the model is fully sharded or not\n    :return: A tuple of tuples\n    \"\"\"\n    if not fully_sharded_data_parallel:\n        raise NotImplementedError()\n    else:\n        return (\n            ('.*', PartitionSpec((\"fsdp\", \"sp\")))\n        )\n</code></pre>"},{"location":"generated-modules-easydel_modelling_utils/#lib.python.EasyDel.modules.easydel_modelling_utils.EasyDelPretrainedConfig.jax_mesh","title":"<code>jax_mesh()</code>","text":"<p>The jax_mesh function is a helper function that creates a Mesh object from the axis_dims and axis_names attributes of an object, which are assumed to be lists of integers and strings, respectively. The backend attribute is also used if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <p>Returns:</p> Type Description <code>Mesh</code> <p>A jaxMesh</p> Source code in <code>lib/python/EasyDel/modules/easydel_modelling_utils.py</code> <pre><code>def jax_mesh(self) -&gt; Mesh:\n    \"\"\"\n    The jax_mesh function is a helper function that creates a Mesh object from the\n    axis_dims and axis_names attributes of an object, which are assumed to be lists of integers and strings, respectively.\n    The backend attribute is also used if it exists.\n\n    :param self: Refer to the object itself\n    :return: A jaxMesh\n\n    \"\"\"\n    return self.create_mesh(\n        axis_dims=[v for k, v in self.axis_dims.items()] if isinstance(self.axis_dims, dict) else self.axis_dims,\n        axis_names=[v for k, v in self.axis_names.items()] if isinstance(self.axis_names,\n                                                                         dict) else self.axis_names,\n        backend=(self.backend if self.backend is not None else \"\") if hasattr(\n            self, 'backend') else \"\"\n    )\n</code></pre>"},{"location":"generated-modules-falcon-falcon_configuration/","title":"modules.falcon.falcon_configuration","text":""},{"location":"generated-modules-falcon-modelling_falcon_flax/","title":"modules.falcon.modelling_falcon_flax","text":""},{"location":"generated-modules-falcon-modelling_falcon_flax/#lib.python.EasyDel.modules.falcon.modelling_falcon_flax.FlaxFalconPretrainedModel","title":"<code>FlaxFalconPretrainedModel</code>","text":"<p>             Bases: <code>EasyDelFlaxPretrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/falcon/modelling_falcon_flax.py</code> <pre><code>class FlaxFalconPretrainedModel(EasyDelFlaxPretrainedModel):\n    module_class: nn.Module = None\n    config_class = FalconConfig\n\n    def __init__(self, config,\n                 _do_init=False,\n                 dtype: jnp.dtype = jnp.float32,\n                 param_dtype: jnp.dtype = jnp.float32,\n                 input_shape: Tuple = (1, 1),\n                 precision: Optional[Union[None, jax.lax.Precision]] = jax.lax.Precision(\"fastest\")\n                 ):\n        module = self.module_class(config=config, dtype=dtype, param_dtype=param_dtype, precision=precision)\n        super().__init__(_do_init=_do_init, module=module, config=config, dtype=dtype, input_shape=input_shape)\n\n    def init_weights(self, rng: jax.random.PRNGKey, input_shape: Tuple, params: FrozenDict = None) -&gt; FrozenDict:\n        \"\"\"\n        The init_weights function is used to initialize the weights of a model.\n\n        :param self: Access variables that belong to the class\n        :param rng: jax.random.PRNGKey: Initialize the weights of the model\n        :param input_shape: Tuple: Specify the shape of the input tensor\n        :param params: FrozenDict: Pass in the parameters of a pre-trained model\n        :return: A frozendict of parameters\n\n        \"\"\"\n        input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(\n            jnp.atleast_2d(input_ids).shape[-1]), input_shape)\n        params_rng, dropout_rng = jax.random.split(rng)\n        rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n        if self.config.add_cross_attention:\n            encoder_hidden_states = jnp.zeros(\n                input_shape + (self.config.hidden_size,))\n            encoder_attention_mask = attention_mask\n            module_init_outputs = self.module.init(\n                rngs,\n                input_ids,\n                attention_mask,\n                position_ids,\n                encoder_hidden_states,\n                encoder_attention_mask,\n                return_dict=False,\n            )\n        else:\n            module_init_outputs = self.module.init(\n                rngs,\n                input_ids,\n                attention_mask,\n                position_ids,\n                return_dict=False\n            )\n\n        random_params = module_init_outputs[\"params\"]\n\n        if params is not None:\n            random_params = flatten_dict(unfreeze(random_params))\n            params = flatten_dict(unfreeze(params))\n            for missing_key in self._missing_keys:\n                params[missing_key] = random_params[missing_key]\n            self._missing_keys = set()\n            return freeze(unflatten_dict(params))\n        else:\n            return random_params\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: Optional[chex.Array] = None,\n            position_ids: Optional[chex.Array] = None,\n            past_key_values: Optional[nn.Module] = None,\n            output_attentions: bool = False,\n            train: bool = True,\n            return_dict: Optional[bool] = True,\n            params: FrozenDict = None,\n            add_params_field: bool = False,\n            **kwargs\n    ):\n        input_ids = jnp.asarray(input_ids, dtype=jnp.int32)\n        inputs = {'params': params or self.params} if add_params_field else params or self.params\n        if past_key_values:\n            inputs[\"cache\"] = past_key_values\n            mutable = [\"cache\"]\n        else:\n            mutable = False\n\n        if position_ids is None:\n            if past_key_values is not None:\n                raise ValueError(\"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n            position_ids = jnp.broadcast_to(jnp.arange(input_ids.shape[1])[None, :],\n                                            (input_ids.shape[0], input_ids.shape[1]))\n        rngs = {}\n        if self.config.bits is not None:\n            rngs['params'] = jax.random.key(0)\n        if attention_mask is None:\n            attention_mask = jnp.ones((input_ids.shape[0], input_ids.shape[1]))\n\n        outputs = self.module.apply(\n            inputs,\n            jnp.array(input_ids, dtype=\"i4\"),\n            jnp.array(attention_mask, dtype=\"i4\"),\n            jnp.array(position_ids, dtype=\"i4\"),\n            output_attentions,\n            not train,\n            False,\n            return_dict,\n            mutable=mutable,\n            rngs=rngs\n        )\n\n        if past_key_values is not None and return_dict:\n            outputs, past_key_values = outputs\n            outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n            return outputs\n        elif past_key_values is not None and not return_dict:\n            outputs, past_key_values = outputs\n            outputs = outputs[:1] + (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n        return outputs\n\n    def init_cache(self, batch_size, max_length):\n\n        input_ids = jnp.ones((batch_size, max_length))\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(jnp.atleast_2d(input_ids).shape[-1]), input_ids.shape)\n\n        init_variables = self.module.init(\n            jax.random.PRNGKey(0), input_ids, attention_mask, position_ids, return_dict=False, init_cache=True\n        )\n        return init_variables[\"cache\"]\n\n    def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n        batch_size, seq_length = input_ids.shape\n\n        past_key_values = self.init_cache(batch_size, max_length)\n        extended_attention_mask = jnp.ones((batch_size, max_length), dtype=\"i4\")\n        if attention_mask is not None:\n            position_ids = attention_mask.cumsum(axis=-1) - 1\n            extended_attention_mask = lax.dynamic_update_slice(extended_attention_mask, attention_mask, (0, 0))\n        else:\n            position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[None, :], (batch_size, seq_length))\n\n        return {\n            \"past_key_values\": past_key_values,\n            \"attention_mask\": extended_attention_mask,\n            \"position_ids\": position_ids,\n        }\n\n    @staticmethod\n    def update_inputs_for_generation(model_outputs, model_kwargs):\n        model_kwargs[\"past_key_values\"] = model_outputs.past_key_values\n        model_kwargs[\"position_ids\"] = model_kwargs[\"position_ids\"][:, -1:] + 1\n        return model_kwargs\n</code></pre>"},{"location":"generated-modules-falcon-modelling_falcon_flax/#lib.python.EasyDel.modules.falcon.modelling_falcon_flax.FlaxFalconPretrainedModel.init_weights","title":"<code>init_weights(rng, input_shape, params=None)</code>","text":"<p>The init_weights function is used to initialize the weights of a model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Initialize the weights of the model</p> required <code>input_shape</code> <code>Tuple</code> <p>Tuple: Specify the shape of the input tensor</p> required <code>params</code> <code>FrozenDict</code> <p>FrozenDict: Pass in the parameters of a pre-trained model</p> <code>None</code> <p>Returns:</p> Type Description <code>FrozenDict</code> <p>A frozendict of parameters</p> Source code in <code>lib/python/EasyDel/modules/falcon/modelling_falcon_flax.py</code> <pre><code>def init_weights(self, rng: jax.random.PRNGKey, input_shape: Tuple, params: FrozenDict = None) -&gt; FrozenDict:\n    \"\"\"\n    The init_weights function is used to initialize the weights of a model.\n\n    :param self: Access variables that belong to the class\n    :param rng: jax.random.PRNGKey: Initialize the weights of the model\n    :param input_shape: Tuple: Specify the shape of the input tensor\n    :param params: FrozenDict: Pass in the parameters of a pre-trained model\n    :return: A frozendict of parameters\n\n    \"\"\"\n    input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n    attention_mask = jnp.ones_like(input_ids)\n    position_ids = jnp.broadcast_to(jnp.arange(\n        jnp.atleast_2d(input_ids).shape[-1]), input_shape)\n    params_rng, dropout_rng = jax.random.split(rng)\n    rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n    if self.config.add_cross_attention:\n        encoder_hidden_states = jnp.zeros(\n            input_shape + (self.config.hidden_size,))\n        encoder_attention_mask = attention_mask\n        module_init_outputs = self.module.init(\n            rngs,\n            input_ids,\n            attention_mask,\n            position_ids,\n            encoder_hidden_states,\n            encoder_attention_mask,\n            return_dict=False,\n        )\n    else:\n        module_init_outputs = self.module.init(\n            rngs,\n            input_ids,\n            attention_mask,\n            position_ids,\n            return_dict=False\n        )\n\n    random_params = module_init_outputs[\"params\"]\n\n    if params is not None:\n        random_params = flatten_dict(unfreeze(random_params))\n        params = flatten_dict(unfreeze(params))\n        for missing_key in self._missing_keys:\n            params[missing_key] = random_params[missing_key]\n        self._missing_keys = set()\n        return freeze(unflatten_dict(params))\n    else:\n        return random_params\n</code></pre>"},{"location":"generated-modules-falcon-modelling_falcon_flax/#lib.python.EasyDel.modules.falcon.modelling_falcon_flax.apply_rotary_pos_embedding","title":"<code>apply_rotary_pos_embedding(tensor, sin_, cos_)</code>","text":"<p>The apply_rotary_pos_embedding function applies a rotary positional embedding to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <p>Pass in the tensor that we want to apply the positional embedding to</p> required <code>sin_</code> <p>Rotate the tensor by half of its length</p> required <code>cos_</code> <p>Multiply the tensor and cosine of the angle</p> required <p>Returns:</p> Type Description <p>A tensor with the same shape as its input,</p> Source code in <code>lib/python/EasyDel/modules/falcon/modelling_falcon_flax.py</code> <pre><code>def apply_rotary_pos_embedding(tensor, sin_, cos_):\n    \"\"\"\n    The apply_rotary_pos_embedding function applies a rotary positional embedding to the input tensor.\n\n    :param tensor: Pass in the tensor that we want to apply the positional embedding to\n    :param sin_: Rotate the tensor by half of its length\n    :param cos_: Multiply the tensor and cosine of the angle\n    :return: A tensor with the same shape as its input,\n\n    \"\"\"\n    return (tensor * cos_) + (_rotate_half(tensor) * sin_)\n</code></pre>"},{"location":"generated-modules-falcon-modelling_falcon_flax/#lib.python.EasyDel.modules.falcon.modelling_falcon_flax.built_bloom_alibi","title":"<code>built_bloom_alibi(attention_mask, num_attention_heads)</code>","text":"<p>The built_bloom_alibi function is used to create a bloom alibi for the attention mask. The bloom alibi is used in the Bloom Attention layer to ensure that each token has a unique attention vector, even if it's masked out. This ensures that all tokens have an equal chance of being selected as the most important token in the sequence, which helps with training stability and performance.</p> <p>Parameters:</p> Name Type Description Default <code>attention_mask</code> <p>Mask out the padding tokens in the input sequence</p> required <code>num_attention_heads</code> <p>Determine the number of attention heads in the model</p> required <p>Returns:</p> Type Description <p>A tensor of shape (batch_size, num_attention_heads, 1, sequence_length)</p> Source code in <code>lib/python/EasyDel/modules/falcon/modelling_falcon_flax.py</code> <pre><code>def built_bloom_alibi(attention_mask, num_attention_heads):\n    \"\"\"\n    The built_bloom_alibi function is used to create a bloom alibi for the attention mask.\n    The bloom alibi is used in the Bloom Attention layer to ensure that each token has a unique\n    attention vector, even if it's masked out. This ensures that all tokens have an equal chance of being selected as\n    the most important token in the sequence, which helps with training stability and performance.\n\n    :param attention_mask: Mask out the padding tokens in the input sequence\n    :param num_attention_heads: Determine the number of attention heads in the model\n    :return: A tensor of shape (batch_size, num_attention_heads, 1, sequence_length)\n\n    \"\"\"\n    batch_size, sequence_length = attention_mask.shape\n    cp2 = 2 ** math.floor(math.log2(num_attention_heads))\n    base = jnp.asarray(\n        2 ** (- (2 ** -(math.log2(cp2) - 3))), dtype=jnp.float32\n    )\n    powers = jnp.arange(1, 1 + cp2, dtype=jnp.float32)\n    slops = jnp.power(base, powers)\n    if cp2 != num_attention_heads:\n        extra_base = jnp.asarray(\n            2 ** (-(2 ** -(math.log2(2 * cp2) - 3))), dtype=jnp.float32\n        )\n        num_rem_heads = min(cp2, num_attention_heads - cp2)\n        extra_power = jnp.arange(1, 1 + 2 * num_rem_heads, 2, dtype=jnp.dtype)\n        slops = jnp.concatenate([slops, jnp.power(extra_base, extra_power)], axis=0)\n    arange_tensor = (((jnp.cumsum(attention_mask, axis=-1)) - 1) * attention_mask)[:, jnp.newaxis, :]\n    alibi = slops[..., jnp.newaxis].astype(jnp.bfloat16) * arange_tensor\n    return alibi.reshape(batch_size, num_attention_heads, 1, sequence_length)\n</code></pre>"},{"location":"generated-modules-falcon-modelling_falcon_flax/#lib.python.EasyDel.modules.falcon.modelling_falcon_flax.dropout_add","title":"<code>dropout_add(linen_drop, x, residual, deterministic)</code>","text":"<p>The dropout_add function is a helper function that adds the residual to the output of the dropout layer. This is necessary because we want to use deterministic=True when we are evaluating our model, but we still need to add in the residual. The reason for this is that during training, we have two paths through our network: one with dropout and one without. The path without dropout (residual) allows us to backpropagate gradients through both paths at once.</p> <p>Parameters:</p> Name Type Description Default <code>linen_drop</code> <code>Dropout</code> <p>nn.Dropout: Specify the dropout layer</p> required <code>x</code> <code>Array</code> <p>chex.Array: Pass in the input to the dropout layer</p> required <code>residual</code> <code>Array</code> <p>chex.Array: Add the residual to the output of dropout_add</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether the dropout layer is active or not</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A tensor that is the sum of the residual and a dropout layer</p> Source code in <code>lib/python/EasyDel/modules/falcon/modelling_falcon_flax.py</code> <pre><code>def dropout_add(linen_drop: nn.Dropout, x: chex.Array, residual: chex.Array, deterministic: bool) -&gt; chex.Array:\n    \"\"\"\n    The dropout_add function is a helper function that adds the residual to the output of\n    the dropout layer. This is necessary because we want to use deterministic=True when\n    we are evaluating our model, but we still need to add in the residual. The reason for this\n    is that during training, we have two paths through our network: one with dropout and one without.\n    The path without dropout (residual) allows us to backpropagate gradients through both paths at once.\n\n    :param linen_drop: nn.Dropout: Specify the dropout layer\n    :param x: chex.Array: Pass in the input to the dropout layer\n    :param residual: chex.Array: Add the residual to the output of dropout_add\n    :param deterministic: bool: Determine whether the dropout layer is active or not\n    :return: A tensor that is the sum of the residual and a dropout layer\n\n    \"\"\"\n    out = linen_drop(inputs=x, deterministic=deterministic)\n    out = residual + out\n    return out\n</code></pre>"},{"location":"generated-modules-falcon-modelling_falcon_flax/#lib.python.EasyDel.modules.falcon.modelling_falcon_flax.precompute_falcon_freq_cis","title":"<code>precompute_falcon_freq_cis(max_position_embedding, head_dim, theta=10000)</code>","text":"<p>The precompute_falcon_freq_cis function is used to precompute the sinusoidal frequencies for the FALCON model. The function takes in three arguments: max_position_embedding, head_dim, and theta. The first two are self-explanatory; the third is a hyperparameter that controls how quickly the frequency increases with position (i.e., how many times higher it will be at position i than at position 0). The default value of 10000 was chosen because it worked well on the tasks we tested.</p> <p>Parameters:</p> Name Type Description Default <code>max_position_embedding</code> <code>int</code> <p>int: Set the maximum length of the sequence</p> required <code>head_dim</code> <code>int</code> <p>int: Determine the size of the positional embedding</p> required <code>theta</code> <code>float</code> <p>float: Adjust the frequency of the sinusoid</p> <code>10000</code> <p>Returns:</p> Type Description <p>A tuple of two arrays</p> Source code in <code>lib/python/EasyDel/modules/falcon/modelling_falcon_flax.py</code> <pre><code>def precompute_falcon_freq_cis(max_position_embedding: int, head_dim: int, theta: float = 10000):\n    \"\"\"\n    The precompute_falcon_freq_cis function is used to precompute the sinusoidal frequencies for the FALCON model.\n    The function takes in three arguments: max_position_embedding, head_dim, and theta. The first two are self-explanatory;\n    the third is a hyperparameter that controls how quickly the frequency increases with position (i.e., how many times\n    higher it will be at position i than at position 0). The default value of 10000 was chosen because it worked well on\n    the tasks we tested.\n\n    :param max_position_embedding: int: Set the maximum length of the sequence\n    :param head_dim: int: Determine the size of the positional embedding\n    :param theta: float: Adjust the frequency of the sinusoid\n    :return: A tuple of two arrays\n\n    \"\"\"\n    inv_freq_cis = 1.0 / (theta ** (jnp.arange(0, head_dim, 2, dtype=jnp.float32) / head_dim))\n    freq = jnp.einsum(\"i , j -&gt; i j\", jnp.arange(max_position_embedding), inv_freq_cis).astype(\"float32\")\n\n    embed = jnp.concatenate((freq, freq), axis=-1)\n    return jnp.sin(embed)[:, :], jnp.cos(embed)[:, :]\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/","title":"modules.flax_modelling_utils","text":""},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.add_start_docstrings","title":"<code>add_start_docstrings(*docstr)</code>","text":"<p>The add_start_docstrings function is a decorator that adds the docstrings to the beginning of a function. The add_start_docstrings function takes in an arbitrary number of strings and returns a decorator. The returned decorator takes in one argument, fn, which is assumed to be a function. The docstring for fn is set equal to the concatenation of all the strings passed into add_start_docstrings plus (if it exists) the original docstring for fn.</p> <p>Parameters:</p> Name Type Description Default <code>docstr</code> <p>Pass in a variable number of arguments to the function</p> <code>()</code> <p>Returns:</p> Type Description <p>A decorator that adds the docstrings to the function</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def add_start_docstrings(*docstr):\n    \"\"\"\n    The add_start_docstrings function is a decorator that adds the docstrings to the beginning of a function.\n    The add_start_docstrings function takes in an arbitrary number of strings and returns a decorator.\n    The returned decorator takes in one argument, fn, which is assumed to be a function. The docstring for fn is set equal to\n    the concatenation of all the strings passed into add_start_docstrings plus (if it exists) the original docstring for fn.\n\n    :param docstr: Pass in a variable number of arguments to the function\n    :return: A decorator that adds the docstrings to the function\n\n    \"\"\"\n\n    def docstring_decorator(fn):\n        fn.__doc__ = \"\".join(docstr) + \\\n                     (fn.__doc__ if fn.__doc__ is not None else \"\")\n        return fn\n\n    return docstring_decorator\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.apply_rotary_pos_emb","title":"<code>apply_rotary_pos_emb(tensor, sin_, cos_)</code>","text":"<p>The apply_rotary_pos_emb function applies a rotary positional embedding to the input tensor. b,h,s,d or pytorch style</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <p>Store the tensor that is passed into the function</p> required <code>sin_</code> <p>Rotate the tensor by pi/2</p> required <code>cos_</code> <p>Apply the cosine function to the tensor</p> required <p>Returns:</p> Type Description <p>A tensor with the same shape as the input tensor</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def apply_rotary_pos_emb(tensor, sin_, cos_):\n    \"\"\"\n    The apply_rotary_pos_emb function applies a rotary positional embedding to the input tensor.\n    b,h,s,d or pytorch style\n\n    :param tensor: Store the tensor that is passed into the function\n    :param sin_: Rotate the tensor by pi/2\n    :param cos_: Apply the cosine function to the tensor\n    :return: A tensor with the same shape as the input tensor\n\n    \"\"\"\n    b, h, s, d = tensor.shape\n    return (tensor * cos_[:, :, :s, :]) + (rotate_half(tensor) * sin_[:, :, :s, :])\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.canonicalize_dtype","title":"<code>canonicalize_dtype(*args, dtype=None, inexact=True)</code>","text":"<p>Canonicalize an optional dtype to the definitive dtype.</p> <p>If the <code>dtype</code> is None this function will infer the dtype. If it is not None it will be returned unmodified or an exceptions is raised if the dtype is invalid. from the input arguments using <code>jnp.result_type</code>.</p> <p>Args:   args: JAX array compatible values. None values     are ignored.   dtype: Optional dtype override. If specified the arguments are cast to     the specified dtype instead and dtype inference is disabled.   inexact: When True, the output dtype must be a subdtype   of <code>jnp.inexact</code>. Inexact dtypes are real or complex floating points. This   is useful when you want to apply operations that don't work directly on   integers like taking a mean for example. Returns:   The dtype that args should be cast to.</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def canonicalize_dtype(\n        *args, dtype: Optional[chex.ArrayDType] = None, inexact: bool = True\n) -&gt; chex.ArrayDType:\n    \"\"\"Canonicalize an optional dtype to the definitive dtype.\n\n    If the ``dtype`` is None this function will infer the dtype. If it is not\n    None it will be returned unmodified or an exceptions is raised if the dtype\n    is invalid.\n    from the input arguments using ``jnp.result_type``.\n\n    Args:\n      *args: JAX array compatible values. None values\n        are ignored.\n      dtype: Optional dtype override. If specified the arguments are cast to\n        the specified dtype instead and dtype inference is disabled.\n      inexact: When True, the output dtype must be a subdtype\n      of `jnp.inexact`. Inexact dtypes are real or complex floating points. This\n      is useful when you want to apply operations that don't work directly on\n      integers like taking a mean for example.\n    Returns:\n      The dtype that *args should be cast to.\n    \"\"\"\n    if dtype is None:\n        args_filtered = [jax.numpy.asarray(x) for x in args if x is not None]\n        dtype = jax.numpy.result_type(*args_filtered)\n        if inexact and not jax.numpy.issubdtype(dtype, jax.numpy.inexact):\n            dtype = jax.numpy.promote_types(jax.numpy.float32, dtype)\n    if inexact and not jax.numpy.issubdtype(dtype, jax.numpy.inexact):\n        raise ValueError(f'Dtype must be inexact: {dtype}')\n    return dtype\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.create_mesh","title":"<code>create_mesh(axis_dims=(1, -1, 1, 1), axis_names=('dp', 'fsdp', 'tp', 'sp'), backend='')</code>","text":"<p>The create_mesh function creates a mesh object that can be used to shard arrays.</p> <p>Parameters:</p> Name Type Description Default <code>axis_dims</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the dimensions of the mesh</p> <code>(1, -1, 1, 1)</code> <code>axis_names</code> <code>Sequence[str]</code> <p>Sequence[str]: Name the axes of the mesh</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>backend</code> <p>Specify the backend to use</p> <code>''</code> <p>Returns:</p> Type Description <p>A mesh object</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def create_mesh(\n        axis_dims: Sequence[int] = (1, -1, 1, 1), axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"), backend=\"\"\n):\n    \"\"\"\n    The create_mesh function creates a mesh object that can be used to shard arrays.\n\n    :param axis_dims: Sequence[int]: Specify the dimensions of the mesh\n    :param axis_names: Sequence[str]: Name the axes of the mesh\n    :param backend: Specify the backend to use\n    :return: A mesh object\n\n    \"\"\"\n    array_devices = jax.numpy.ones(\n        (len(jax.devices() if backend == \"\" else jax.devices(backend)), 1))\n    resh = array_devices.reshape(axis_dims).shape\n\n    return jax.sharding.Mesh(\n        create_device_mesh(resh), axis_names\n    )\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.get_dot_general_by_bits","title":"<code>get_dot_general_by_bits(bits=None, mode=EasyMethod.TRAIN)</code>","text":"<p>The get_general_dot function is a helper function that returns a q_flax.QDotGeneral object with the specified number of bits for forward and backward passes. If no bits are specified, the function returns None.</p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Specify the number of bits for quantization</p> <code>None</code> <code>mode</code> <code>Literal['train', 'serve', 'convert']</code> <p>EasyMethod: Specify the use of model to init the QDot Method for (e.q TRAIN,SERVE,...)</p> <code>TRAIN</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dict that contain dot_general_cls</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def get_dot_general_by_bits(\n        bits: Optional[int] = None,\n        mode: Literal[\"train\", \"serve\", \"convert\"] = EasyMethod.TRAIN\n) -&gt; dict:\n    \"\"\"\n    The get_general_dot function is a helper function that returns a q_flax.QDotGeneral object\n    with the specified number of bits for forward and backward passes. If no bits are specified,\n    the function returns None.\n\n    :param bits: Optional[int]: Specify the number of bits for quantization\n    :param mode: EasyMethod: Specify the use of model to init the QDot Method for (e.q TRAIN,SERVE,...)\n    :return: A dict that contain dot_general_cls\n    \"\"\"\n    if mode == EasyMethod.TRAIN:\n        rhs_quant_mode = q_flax.QuantMode.TRAIN\n    elif mode == EasyMethod.EVAL or mode == EasyMethod.SERVE:\n        rhs_quant_mode = q_flax.QuantMode.SERVE\n    elif mode == EasyMethod.CONVERT:\n        rhs_quant_mode = q_flax.QuantMode.CONVERT\n    else:\n        raise ValueError(\"Unknown Quant Method for EasyMethod\")\n    if bits is not None:\n        return {\n            \"dot_general_cls\": functools.partial(\n                q_flax.QDotGeneral,\n                q_config.fully_quantized(\n                    fwd_bits=bits,\n                    bwd_bits=bits\n                ),\n                rhs_quant_mode=rhs_quant_mode\n            )\n        }\n    return {}  # empty just in case of not getting any error\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.get_gradient_checkpoint_policy","title":"<code>get_gradient_checkpoint_policy(name)</code>","text":"<p>The get_gradient_checkpoint_policy function is a helper function that returns the gradient checkpoint policy     specified by the name parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Select the checkpoint policy from the dictionary</p> required <p>Returns:</p> Type Description <p>A function that is used in the jax</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def get_gradient_checkpoint_policy(name):\n    \"\"\"\n    The get_gradient_checkpoint_policy function is a helper function that returns the gradient checkpoint policy\n        specified by the name parameter.\n\n    :param name: Select the checkpoint policy from the dictionary\n    :return: A function that is used in the jax\n\n    \"\"\"\n    gradients = dict(\n        everything_saveable=jax.checkpoint_policies.everything_saveable,\n        nothing_saveable=jax.checkpoint_policies.nothing_saveable,\n        dots_saveable=jax.checkpoint_policies.dots_saveable,\n        checkpoint_dots=jax.checkpoint_policies.checkpoint_dots,\n        dots_with_no_batch_dims_saveable=jax.checkpoint_policies.dots_with_no_batch_dims_saveable,\n        checkpoint_dots_with_no_batch_dims=jax.checkpoint_policies.checkpoint_dots_with_no_batch_dims,\n        save_anything_except_these_names=jax.checkpoint_policies.save_anything_except_these_names,\n        save_any_names_but_these=jax.checkpoint_policies.save_any_names_but_these,\n        save_only_these_names=jax.checkpoint_policies.save_only_these_names,\n        save_from_both_policies=jax.checkpoint_policies.save_from_both_policies\n    )\n    return gradients[name]\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.get_names_from_partition_spec","title":"<code>get_names_from_partition_spec(partition_specs)</code>","text":"<p>The get_names_from_partition_spec function takes a partition_specs argument, which is either a dictionary or list. If it's a dictionary, the function converts it to a list of values. Then for each item in the partition_specs list:     If the item is None, continue (do nothing) and move on to next iteration of loop.     If the item is an instance of str (i.e., if it's just one string), add that string to names set and move     on to next iteration of loop.     Otherwise, (if not None or str), call get_names_from_partition_spec recurs</p> <p>Parameters:</p> Name Type Description Default <code>partition_specs</code> <p>Define the partitioning of a table</p> required <p>Returns:</p> Type Description <p>A list of the names of all partitions</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def get_names_from_partition_spec(partition_specs):\n    \"\"\"\n    The get_names_from_partition_spec function takes a partition_specs argument, which is either a dictionary or list.\n    If it's a dictionary, the function converts it to a list of values. Then for each item in the partition_specs list:\n        If the item is None, continue (do nothing) and move on to next iteration of loop.\n        If the item is an instance of str (i.e., if it's just one string), add that string to names set and move\n        on to next iteration of loop.\n        Otherwise, (if not None or str), call get_names_from_partition_spec recurs\n\n    :param partition_specs: Define the partitioning of a table\n    :return: A list of the names of all partitions\n\n    \"\"\"\n    names = set()\n    if isinstance(partition_specs, dict):\n        partition_specs = partition_specs.values()\n    for item in partition_specs:\n        if item is None:\n            continue\n        elif isinstance(item, str):\n            names.add(item)\n        else:\n            names.update(get_names_from_partition_spec(item))\n\n    return list(names)\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.get_ranks_and_size","title":"<code>get_ranks_and_size(mesh)</code>","text":"<p>The get_ranks_and_size function is used to determine the number of MPI processes (<code>mp_node_size</code>) and the number of devices per process (<code>dp_node_size</code>). The <code>mesh.shape[mp]</code> determines how many MPI processes are needed, and then we divide that by the local device count to get <code>`mp_node_size = max( 1, mp / jax.local )</code>. This means that if there are more than enough devices for all MPI ranks on a node, each rank will only use one device; otherwise it will use</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <p>Get the shape of the mesh</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys:</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def get_ranks_and_size(mesh):\n    \"\"\"\n    The get_ranks_and_size function is used to determine the number of MPI processes\n    (``mp_node_size``) and the number of devices per process (``dp_node_size``).\n    The ``mesh.shape[mp]`` determines how many MPI processes are needed,\n    and then we divide that by the local device count to get ``mp_node_size = max( 1, mp / jax.local )`.\n    This means that if there are more than enough devices for all MPI ranks on a node, each rank will only use one device; otherwise it will use\n\n    :param mesh: Get the shape of the mesh\n    :return: A dictionary with the following keys:\n\n    \"\"\"\n    out = dict(mesh=mesh)\n    total_process_size = mesh.shape[\"tp\"] * mesh.shape[\"sp\"]\n    mp_node_size = max(1, total_process_size // jax.local_device_count())\n    dp_node_size = jax.process_count() // mp_node_size\n    out.update(mp_node_size=mp_node_size,\n               dp_node_size=dp_node_size)\n\n    dp_node_rank = jax.process_index() // mp_node_size\n    mp_node_rank = jax.process_index() % mp_node_size\n    out.update(dp_node_rank=dp_node_rank,\n               mp_node_rank=mp_node_rank)\n    return out\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.names_in_mesh","title":"<code>names_in_mesh(*names)</code>","text":"<p>The names_in_mesh function is a decorator that can be used to check whether the names of the axes passed into a function are valid.  It will raise an exception if any of the axis names are not in the physical mesh.  For example, if you have a function that takes two axes as arguments, and you want to make sure they're both in your mesh:</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <p>Collect all the names passed to the function into a tuple</p> <code>()</code> <p>Returns:</p> Type Description <p>A boolean indicating whether all the given</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def names_in_mesh(*names):\n    \"\"\"\n    The names_in_mesh function is a decorator that can be used to check whether\n    the names of the axes passed into a function are valid.  It will raise an\n    exception if any of the axis names are not in the physical mesh.  For example,\n    if you have a function that takes two axes as arguments, and you want to make sure they're both in your mesh:\n\n    :param names: Collect all the names passed to the function into a tuple\n    :return: A boolean indicating whether all the given\n\n    \"\"\"\n    return set(names) &lt;= set(pxla.thread_resources.env.physical_mesh.axis_names)\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.repeat_kv_bnsh","title":"<code>repeat_kv_bnsh(x, n_rep)</code>","text":"<p>The repeat_kv_bnsh function is used to repeat the key and value vectors for each head in a multi-head attention module. This function takes as input an array of shape (batch_size, n_heads, sequence_length, head_dim) and returns an array of shape (batch_size, n_heads * nrep, sequence length, head dim). The reason this is necessary is because the attention module expects keys/values/queries to be repeated across heads but not across batches. However we want our keys/values/queries to be repeated both across heads AND batches so that we can use them</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>chex.Array: Pass in the input to the function</p> required <code>n_rep</code> <code>int</code> <p>int: Repeat the key and value heads</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A new array with the same shape as x, except for the second dimension which is n_kv_heads * n_rep</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def repeat_kv_bnsh(x: chex.Array, n_rep: int) -&gt; chex.Array:\n    \"\"\"\n    The repeat_kv_bnsh function is used to repeat the key and value vectors for each head in a multi-head attention\n    module. This function takes as input an array of shape (batch_size, n_heads, sequence_length, head_dim) and returns\n    an array of shape (batch_size, n_heads * nrep, sequence length, head dim). The reason this is necessary is because the\n    attention module expects keys/values/queries to be repeated across heads but not across batches. However we want our\n    keys/values/queries to be repeated both across heads AND batches so that we can use them\n\n    :param x: chex.Array: Pass in the input to the function\n    :param n_rep: int: Repeat the key and value heads\n    :return: A new array with the same shape as x, except for the second dimension which is n_kv_heads * n_rep\n\n    \"\"\"\n    bs, n_kv_heads, s, head_dim = x.shape\n    if n_rep == 1:\n        return x\n    x = x[:, :, jax.numpy.newaxis, :, :]\n    x = jax.numpy.repeat(x, n_rep, axis=2)\n\n    return x.reshape(bs, n_kv_heads * n_rep, s, head_dim)\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.repeat_kv_bsnh","title":"<code>repeat_kv_bsnh(x, n_rep)</code>","text":"<p>The repeat_kv_bsnh function is used to repeat the key and value vectors for each head.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>chex.Array: Specify the input array</p> required <code>n_rep</code> <code>int</code> <p>int: Repeat the key-value attention heads n_rep times</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A new array with the same batch size, sequence length, and head dimension as the input array</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def repeat_kv_bsnh(x: chex.Array, n_rep: int) -&gt; chex.Array:\n    \"\"\"\n    The repeat_kv_bsnh function is used to repeat the key and value vectors for each head.\n\n    :param x: chex.Array: Specify the input array\n    :param n_rep: int: Repeat the key-value attention heads n_rep times\n    :return: A new array with the same batch size, sequence length, and head dimension as the input array\n\n    \"\"\"\n    bs, s, n_kv_heads, head_dim = x.shape\n    x = x.transpose(0, 2, 1, 3)\n    if n_rep == 1:\n        return x\n    x = x[:, :, jax.numpy.newaxis, :, :]\n    x = jax.numpy.repeat(x, n_rep, axis=2)\n\n    x = x.transpose(0, 2, 1, 3)\n\n    return x.reshape(bs, s, n_kv_heads * n_rep, head_dim)\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.rotate_half","title":"<code>rotate_half(x)</code>","text":"<p>The rotate_half function takes a complex-valued array and rotates the phase of its second half by 180 degrees. This is equivalent to multiplying the second half by -i, or equivalently rotating it 90 degrees counterclockwise.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Specify the input array</p> required <p>Returns:</p> Type Description <p>A new array that is the same as the input</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def rotate_half(x):\n    \"\"\"\n    The rotate_half function takes a complex-valued array and rotates the\n    phase of its second half by 180 degrees. This is equivalent to multiplying\n    the second half by -i, or equivalently rotating it 90 degrees counterclockwise.\n\n\n    :param x: Specify the input array\n    :return: A new array that is the same as the input\n\n    \"\"\"\n    x1 = x[..., : x.shape[-1] // 2]\n    x2 = x[..., x.shape[-1] // 2:]\n    return jax.numpy.concatenate((-x2, x1), axis=-1)\n</code></pre>"},{"location":"generated-modules-flax_modelling_utils/#lib.python.EasyDel.modules.flax_modelling_utils.with_sharding_constraint","title":"<code>with_sharding_constraint(x, partition_specs)</code>","text":"<p>The with_sharding_constraint function is used to ensure that the sharding of a tensor is consistent with the sharding of its inputs.  This function should be called on any tensor which has been created by an operation which does not automatically handle this, such as tf.concat or tf.split.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Define the tensor that will be sharded</p> required <code>partition_specs</code> <p>Specify the partitioning of the data</p> required <p>Returns:</p> Type Description <p>The same tensor with the</p> Source code in <code>lib/python/EasyDel/modules/flax_modelling_utils.py</code> <pre><code>def with_sharding_constraint(x, partition_specs):\n    \"\"\"\n    The with_sharding_constraint function is used to ensure that the sharding of a tensor\n    is consistent with the sharding of its inputs.  This function should be called on any\n    tensor which has been created by an operation which does not automatically handle this,\n    such as tf.concat or tf.split.\n\n    :param x: Define the tensor that will be sharded\n    :param partition_specs: Specify the partitioning of the data\n    :return: The same tensor with the\n\n    \"\"\"\n    axis_names = get_names_from_partition_spec(partition_specs)\n    if names_in_mesh(*axis_names):\n        x = wsc(x, partition_specs)\n    return x\n</code></pre>"},{"location":"generated-modules-gpt2-gpt2_configuration/","title":"modules.gpt2.gpt2_configuration","text":""},{"location":"generated-modules-gpt2-modelling_gpt2_flax/","title":"modules.gpt2.modelling_gpt2_flax","text":""},{"location":"generated-modules-gpt_j-gpt_j_configuration/","title":"modules.gpt_j.gpt_j_configuration","text":""},{"location":"generated-modules-gpt_j-modelling_gpt_j_flax/","title":"modules.gpt_j.modelling_gpt_j_flax","text":"<p>GPT-J model configuration</p>"},{"location":"generated-modules-gpt_neo_x-gpt_neo_x_configuration/","title":"modules.gpt_neo_x.gpt_neo_x_configuration","text":""},{"location":"generated-modules-gpt_neo_x-modelling_gpt_neo_x_flax/","title":"modules.gpt_neo_x.modelling_gpt_neo_x_flax","text":""},{"location":"generated-modules-llama-llama_configuration/","title":"modules.llama.llama_configuration","text":""},{"location":"generated-modules-llama-llama_configuration/#lib.python.EasyDel.modules.llama.llama_configuration.LlamaConfig","title":"<code>LlamaConfig</code>","text":"<p>             Bases: <code>EasyDelPretrainedConfig</code></p> Source code in <code>lib/python/EasyDel/modules/llama/llama_configuration.py</code> <pre><code>class LlamaConfig(EasyDelPretrainedConfig):\n    model_type = \"llama\"\n\n    def __init__(\n            self,\n            vocab_size: int = 32000,\n            hidden_size: int = 4096,\n            intermediate_size: int = 11008,\n            num_hidden_layers: int = 32,\n            num_attention_heads: int = 32,\n            number_rep_kv: int = 1,\n            num_key_value_heads: Optional[int] = None,\n            max_position_embeddings: int = 2048,\n            rms_norm_eps: float = 1e-6,\n            initializer_range: float = 0.02,\n            use_cache: bool = True,\n            bos_token_id: int = 0,\n            eos_token_id: int = 1,\n            resid_pdrop: float = 0.0,\n            embd_pdrop: float = 0.0,\n            attention_dropout: float = 0.0,\n            rope_theta: float = 10000.,\n            attention_bias: bool = False,\n            tie_word_embeddings: bool = False,\n            gradient_checkpointing: str = \"nothing_saveable\",\n            fcm_min_ratio: float = -1,\n            fcm_max_ratio: float = -1,\n            use_pjit_attention_force: bool = False,\n            rope_scaling: Dict[str, Union[str, float]] = None,\n            use_sacn_mlp: bool = False,\n            scan_mlp_chunk_size: int = 1024,\n            bits: Optional[int] = None,\n            hidden_act: str = 'silu',\n            pretraining_tp: int = 1,\n            scan_layers: bool = False,\n            use_shard_map: bool = False,\n            **kwargs,\n    ):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the attributes of an object, which are sometimes called fields or properties.\n        The __init__ function can accept arguments, but self must be the first one.\n\n        :param self: Refer to the object itself\n        :param vocab_size: int: Set the size of the vocabulary\n        :param hidden_size: int: Set the size of the hidden layers in each transformer block\n        :param intermediate_size: int: Set the size of the intermediate layer\n        :param num_hidden_layers: int: Determine the number of layers in the transformer\n        :param num_attention_heads: int: Determine the number of attention heads\n        :param number_rep_kv: int: Set the number of times to repeat the key and value vectors\n        :param num_key_value_heads: Optional[int]: Define the number of key-value heads\n        :param max_position_embeddings: int: Set the maximum length of a sequence\n        :param rms_norm_eps: float: Prevent division by zero in the rms normalization\n        :param initializer_range: float: Initialize the weights of the model\n        :param use_cache: bool: Determine whether the attention layer should use a cache for faster computation\n        :param bos_token_id: int: Set the beginning of sequence token\n        :param eos_token_id: int: Specify the end of sentence token\n        :param resid_pdrop: float: Set the dropout rate for residual connections\n        :param embd_pdrop: float: Dropout the embedding layer\n        :param attention_dropout: float: Dropout the attention weights\n        :param tie_word_embeddings: bool: Tie the word embeddings and output layer weights\n        :param gradient_checkpointing: str: Specify how to checkpoint the gradients\n        :param fcm_min_ratio: float: Set the minimum ratio of the number of elements in a tensor to be processed by flash\n        :param fcm_max_ratio: float: Determine the maximum ratio of\n        :param use_pjit_attention_force: bool: Determine whether to use the pytorch jit compiler\n        :param rope_scaling: Dict[str: Define the scaling of the rope\n        :param Union[str: Specify the type of the parameter\n        :param float]]: Specify the type of the parameter\n        :param use_shard_map: bool: when ever to use shard_map for attention\n        :param use_sacn_mlp: bool: Determine whether to use scan_mlp or not\n        :param scan_mlp_chunk_size: int: Specify the chunk size of the scan_mlp\n        :param bits: Optional[int]: Specify the number of bits used to quantize the weights\n        :param rope_theta: float : rope_theta for compute rope\n        :param attention_bias: bool : whenever to use attention bias or no\n        :param hidden_act: str : hidden_act for mlp\n        :param axis_dims: Sequence[int]: Specify the dimensions of each axis\n        :param axis_names: Sequence[str]: Specify the names of the axes in a tensor\n        :param scan_layers: bool: Determine whether to use the scan_layers or not\n        :param kwargs: Pass a variable number of keyword arguments to a function\n        :param : Define the number of layers in the model\n        :return: Nothing\n\n        \"\"\"\n        num_key_value_heads = num_key_value_heads or number_rep_kv * num_attention_heads\n        self.num_key_value_heads = num_key_value_heads\n        self.vocab_size = vocab_size\n\n        self.number_rep_kv = number_rep_kv\n        self.hidden_size = hidden_size\n        self.initializer_range = initializer_range\n        self.intermediate_size = intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.rope_theta = rope_theta\n        self.attention_bias = attention_bias\n        self.num_attention_heads = num_attention_heads\n        self.max_position_embeddings = max_position_embeddings\n        self.rms_norm_eps = rms_norm_eps\n        self.use_cache = use_cache\n        self.pretraining_tp = pretraining_tp\n        self.resid_pdrop = resid_pdrop\n        self.embd_pdrop = embd_pdrop\n        self.attention_dropout = attention_dropout\n        self.gradient_checkpointing = gradient_checkpointing\n        self.use_pjit_attention_force = use_pjit_attention_force\n        self.fcm_min_ratio = fcm_min_ratio\n        self.hidden_act = hidden_act\n        self.fcm_max_ratio = fcm_max_ratio\n        self.rope_scaling = rope_scaling\n        self.use_sacn_mlp = use_sacn_mlp\n        self.scan_mlp_chunk_size = scan_mlp_chunk_size\n        self.bits = bits\n        self.use_sacn_mlp = use_shard_map\n        self.scan_layers = scan_layers\n        super().__init__(\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs,\n        )\n\n    def get_partition_rules(self, fully_sharded_data_parallel: bool = True):\n        \"\"\"\n        The get_partition_rules function is used to define the partitioning scheme for a model.\n        It returns a list of tuples, where each tuple contains two elements:\n            1) A regex string that matches the name of one or more parameters in the model.\n            2) A PartitionScheme object that defines how those parameters should be partitioned across devices.\n\n        :param fully_sharded_data_parallel: bool: Determine whether to partition the model fully or not\n        :return: A list of tuples\n\n        \"\"\"\n        return (\n\n            (\"model/embed_tokens/embedding\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n            (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n            (\"self_attn/o_proj/kernel\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n            (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n            (\"mlp/down_proj/kernel\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n            (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n\n            (\"input_layernorm/kernel\", PartitionSpec(None)),\n            (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n            (\"model/norm/kernel\", PartitionSpec(None)),\n            (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n            (\".*\", PartitionSpec(None)),\n        ) if not fully_sharded_data_parallel else (\n\n            (\"model/embed_tokens/embedding\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"self_attn/o_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/down_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"input_layernorm/kernel\", PartitionSpec(None)),\n            (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n            (\"model/norm/kernel\", PartitionSpec(None)),\n            (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\".*\", PartitionSpec((\"fsdp\", \"sp\"))),\n        )\n\n    def add_jax_args(\n            self,\n            resid_pdrop: float = 0.0,\n            embd_pdrop: float = 0.0,\n            attention_dropout: float = 0.0,\n            tie_word_embeddings: bool = False,\n            gradient_checkpointing: str = 'nothing_saveable',\n            fcm_min_ratio: float = 0.0,\n            fcm_max_ratio: float = 0.0,\n            use_pjit_attention_force: bool = False,\n            use_sacn_mlp: bool = False,\n            scan_mlp_chunk_size: int = 1024,\n            number_rep_kv: int = 1,\n            bits: Optional[int] = None,\n            rope_theta: float = 10000.,\n            attention_bias: bool = False,\n            hidden_act: str = 'silu',\n            scan_layers: bool = True,\n            **kwargs,\n    ):\n        \"\"\"\n        The add_jax_args function adds the following arguments to the Transformer class:\n\n        :param self: Refer to the current object\n        :param resid_pdrop: float: Set the dropout rate for residual connections\n        :param embd_pdrop: float: Set the probability of dropping an embedding\n        :param attention_dropout: float: Set the probability of dropping out the attention layer\n        :param tie_word_embeddings: bool: Tie the word embeddings to the decoder\n        :param gradient_checkpointing: str: Control the amount of memory used by jax\n        :param fcm_min_ratio: float: Control the minimum ratio of the number of chunks to be used in flash-based computation\n        :param fcm_max_ratio: float: Set the maximum ratio of the number of input tokens to output tokens\n        :param use_pjit_attention_force: bool: Determine if the attention force is used\n        :param use_sacn_mlp: bool: Determine whether to use the scan_mlp function or not\n        :param scan_mlp_chunk_size: int: Set the chunk size for scan_mlp\n        :param number_rep_kv: int: Determine how many times the key and value vectors are repeated\n        :param bits: Optional[int]: Determine the number of bits used in the quantization\n        :param rope_theta: float : rope_theta for compute rope\n        :param attention_bias: bool : whenever to use attention bias or no\n        :param hidden_act: str : hidden_act for mlp\n        :param scan_layers: bool: Determine whether to use scan layers or not\n        :return: The following:\n\n        \"\"\"\n        self.scan_layers = scan_layers\n        self.embd_pdrop = embd_pdrop\n        self.number_rep_kv = number_rep_kv\n        self.resid_pdrop = resid_pdrop\n        self.rope_theta = rope_theta\n        self.attention_bias = attention_bias\n        self.attention_dropout = attention_dropout\n        self.hidden_act = hidden_act\n        self.tie_word_embeddings = tie_word_embeddings\n        self.gradient_checkpointing = gradient_checkpointing\n        self.fcm_min_ratio = fcm_min_ratio\n        self.fcm_max_ratio = fcm_max_ratio\n        self.use_pjit_attention_force = use_pjit_attention_force\n\n        self.use_sacn_mlp = use_sacn_mlp\n        self.scan_mlp_chunk_size = scan_mlp_chunk_size\n        self.bits = bits\n\n    @staticmethod\n    def get_weight_decay_exclusions():\n        return tuple()\n\n    @staticmethod\n    def rng_keys():\n        return 'params', 'dropout', 'fcm'\n</code></pre>"},{"location":"generated-modules-llama-llama_configuration/#lib.python.EasyDel.modules.llama.llama_configuration.LlamaConfig.__init__","title":"<code>__init__(vocab_size=32000, hidden_size=4096, intermediate_size=11008, num_hidden_layers=32, num_attention_heads=32, number_rep_kv=1, num_key_value_heads=None, max_position_embeddings=2048, rms_norm_eps=1e-06, initializer_range=0.02, use_cache=True, bos_token_id=0, eos_token_id=1, resid_pdrop=0.0, embd_pdrop=0.0, attention_dropout=0.0, rope_theta=10000.0, attention_bias=False, tie_word_embeddings=False, gradient_checkpointing='nothing_saveable', fcm_min_ratio=-1, fcm_max_ratio=-1, use_pjit_attention_force=False, rope_scaling=None, use_sacn_mlp=False, scan_mlp_chunk_size=1024, bits=None, hidden_act='silu', pretraining_tp=1, scan_layers=False, use_shard_map=False, **kwargs)</code>","text":"<p>The init function is called when the class is instantiated. It sets up the attributes of an object, which are sometimes called fields or properties. The init function can accept arguments, but self must be the first one.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>vocab_size</code> <code>int</code> <p>int: Set the size of the vocabulary</p> <code>32000</code> <code>hidden_size</code> <code>int</code> <p>int: Set the size of the hidden layers in each transformer block</p> <code>4096</code> <code>intermediate_size</code> <code>int</code> <p>int: Set the size of the intermediate layer</p> <code>11008</code> <code>num_hidden_layers</code> <code>int</code> <p>int: Determine the number of layers in the transformer</p> <code>32</code> <code>num_attention_heads</code> <code>int</code> <p>int: Determine the number of attention heads</p> <code>32</code> <code>number_rep_kv</code> <code>int</code> <p>int: Set the number of times to repeat the key and value vectors</p> <code>1</code> <code>num_key_value_heads</code> <code>Optional[int]</code> <p>Optional[int]: Define the number of key-value heads</p> <code>None</code> <code>max_position_embeddings</code> <code>int</code> <p>int: Set the maximum length of a sequence</p> <code>2048</code> <code>rms_norm_eps</code> <code>float</code> <p>float: Prevent division by zero in the rms normalization</p> <code>1e-06</code> <code>initializer_range</code> <code>float</code> <p>float: Initialize the weights of the model</p> <code>0.02</code> <code>use_cache</code> <code>bool</code> <p>bool: Determine whether the attention layer should use a cache for faster computation</p> <code>True</code> <code>bos_token_id</code> <code>int</code> <p>int: Set the beginning of sequence token</p> <code>0</code> <code>eos_token_id</code> <code>int</code> <p>int: Specify the end of sentence token</p> <code>1</code> <code>resid_pdrop</code> <code>float</code> <p>float: Set the dropout rate for residual connections</p> <code>0.0</code> <code>embd_pdrop</code> <code>float</code> <p>float: Dropout the embedding layer</p> <code>0.0</code> <code>attention_dropout</code> <code>float</code> <p>float: Dropout the attention weights</p> <code>0.0</code> <code>tie_word_embeddings</code> <code>bool</code> <p>bool: Tie the word embeddings and output layer weights</p> <code>False</code> <code>gradient_checkpointing</code> <code>str</code> <p>str: Specify how to checkpoint the gradients</p> <code>'nothing_saveable'</code> <code>fcm_min_ratio</code> <code>float</code> <p>float: Set the minimum ratio of the number of elements in a tensor to be processed by flash</p> <code>-1</code> <code>fcm_max_ratio</code> <code>float</code> <p>float: Determine the maximum ratio of</p> <code>-1</code> <code>use_pjit_attention_force</code> <code>bool</code> <p>bool: Determine whether to use the pytorch jit compiler</p> <code>False</code> <code>rope_scaling</code> <code>Dict[str, Union[str, float]]</code> <p>Dict[str: Define the scaling of the rope</p> <code>None</code> <code>Union[str</code> <p>Specify the type of the parameter</p> required <code>float]]</code> <p>Specify the type of the parameter</p> required <code>use_shard_map</code> <code>bool</code> <p>bool: when ever to use shard_map for attention</p> <code>False</code> <code>use_sacn_mlp</code> <code>bool</code> <p>bool: Determine whether to use scan_mlp or not</p> <code>False</code> <code>scan_mlp_chunk_size</code> <code>int</code> <p>int: Specify the chunk size of the scan_mlp</p> <code>1024</code> <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Specify the number of bits used to quantize the weights</p> <code>None</code> <code>rope_theta</code> <code>float</code> <p>float : rope_theta for compute rope</p> <code>10000.0</code> <code>attention_bias</code> <code>bool</code> <p>bool : whenever to use attention bias or no</p> <code>False</code> <code>hidden_act</code> <code>str</code> <p>str : hidden_act for mlp</p> <code>'silu'</code> <code>axis_dims</code> <p>Sequence[int]: Specify the dimensions of each axis</p> required <code>axis_names</code> <p>Sequence[str]: Specify the names of the axes in a tensor</p> required <code>scan_layers</code> <code>bool</code> <p>bool: Determine whether to use the scan_layers or not</p> <code>False</code> <code>kwargs</code> <p>Pass a variable number of keyword arguments to a function</p> <code>{}</code> <code></code> <p>Define the number of layers in the model</p> required <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>lib/python/EasyDel/modules/llama/llama_configuration.py</code> <pre><code>def __init__(\n        self,\n        vocab_size: int = 32000,\n        hidden_size: int = 4096,\n        intermediate_size: int = 11008,\n        num_hidden_layers: int = 32,\n        num_attention_heads: int = 32,\n        number_rep_kv: int = 1,\n        num_key_value_heads: Optional[int] = None,\n        max_position_embeddings: int = 2048,\n        rms_norm_eps: float = 1e-6,\n        initializer_range: float = 0.02,\n        use_cache: bool = True,\n        bos_token_id: int = 0,\n        eos_token_id: int = 1,\n        resid_pdrop: float = 0.0,\n        embd_pdrop: float = 0.0,\n        attention_dropout: float = 0.0,\n        rope_theta: float = 10000.,\n        attention_bias: bool = False,\n        tie_word_embeddings: bool = False,\n        gradient_checkpointing: str = \"nothing_saveable\",\n        fcm_min_ratio: float = -1,\n        fcm_max_ratio: float = -1,\n        use_pjit_attention_force: bool = False,\n        rope_scaling: Dict[str, Union[str, float]] = None,\n        use_sacn_mlp: bool = False,\n        scan_mlp_chunk_size: int = 1024,\n        bits: Optional[int] = None,\n        hidden_act: str = 'silu',\n        pretraining_tp: int = 1,\n        scan_layers: bool = False,\n        use_shard_map: bool = False,\n        **kwargs,\n):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up the attributes of an object, which are sometimes called fields or properties.\n    The __init__ function can accept arguments, but self must be the first one.\n\n    :param self: Refer to the object itself\n    :param vocab_size: int: Set the size of the vocabulary\n    :param hidden_size: int: Set the size of the hidden layers in each transformer block\n    :param intermediate_size: int: Set the size of the intermediate layer\n    :param num_hidden_layers: int: Determine the number of layers in the transformer\n    :param num_attention_heads: int: Determine the number of attention heads\n    :param number_rep_kv: int: Set the number of times to repeat the key and value vectors\n    :param num_key_value_heads: Optional[int]: Define the number of key-value heads\n    :param max_position_embeddings: int: Set the maximum length of a sequence\n    :param rms_norm_eps: float: Prevent division by zero in the rms normalization\n    :param initializer_range: float: Initialize the weights of the model\n    :param use_cache: bool: Determine whether the attention layer should use a cache for faster computation\n    :param bos_token_id: int: Set the beginning of sequence token\n    :param eos_token_id: int: Specify the end of sentence token\n    :param resid_pdrop: float: Set the dropout rate for residual connections\n    :param embd_pdrop: float: Dropout the embedding layer\n    :param attention_dropout: float: Dropout the attention weights\n    :param tie_word_embeddings: bool: Tie the word embeddings and output layer weights\n    :param gradient_checkpointing: str: Specify how to checkpoint the gradients\n    :param fcm_min_ratio: float: Set the minimum ratio of the number of elements in a tensor to be processed by flash\n    :param fcm_max_ratio: float: Determine the maximum ratio of\n    :param use_pjit_attention_force: bool: Determine whether to use the pytorch jit compiler\n    :param rope_scaling: Dict[str: Define the scaling of the rope\n    :param Union[str: Specify the type of the parameter\n    :param float]]: Specify the type of the parameter\n    :param use_shard_map: bool: when ever to use shard_map for attention\n    :param use_sacn_mlp: bool: Determine whether to use scan_mlp or not\n    :param scan_mlp_chunk_size: int: Specify the chunk size of the scan_mlp\n    :param bits: Optional[int]: Specify the number of bits used to quantize the weights\n    :param rope_theta: float : rope_theta for compute rope\n    :param attention_bias: bool : whenever to use attention bias or no\n    :param hidden_act: str : hidden_act for mlp\n    :param axis_dims: Sequence[int]: Specify the dimensions of each axis\n    :param axis_names: Sequence[str]: Specify the names of the axes in a tensor\n    :param scan_layers: bool: Determine whether to use the scan_layers or not\n    :param kwargs: Pass a variable number of keyword arguments to a function\n    :param : Define the number of layers in the model\n    :return: Nothing\n\n    \"\"\"\n    num_key_value_heads = num_key_value_heads or number_rep_kv * num_attention_heads\n    self.num_key_value_heads = num_key_value_heads\n    self.vocab_size = vocab_size\n\n    self.number_rep_kv = number_rep_kv\n    self.hidden_size = hidden_size\n    self.initializer_range = initializer_range\n    self.intermediate_size = intermediate_size\n    self.num_hidden_layers = num_hidden_layers\n    self.rope_theta = rope_theta\n    self.attention_bias = attention_bias\n    self.num_attention_heads = num_attention_heads\n    self.max_position_embeddings = max_position_embeddings\n    self.rms_norm_eps = rms_norm_eps\n    self.use_cache = use_cache\n    self.pretraining_tp = pretraining_tp\n    self.resid_pdrop = resid_pdrop\n    self.embd_pdrop = embd_pdrop\n    self.attention_dropout = attention_dropout\n    self.gradient_checkpointing = gradient_checkpointing\n    self.use_pjit_attention_force = use_pjit_attention_force\n    self.fcm_min_ratio = fcm_min_ratio\n    self.hidden_act = hidden_act\n    self.fcm_max_ratio = fcm_max_ratio\n    self.rope_scaling = rope_scaling\n    self.use_sacn_mlp = use_sacn_mlp\n    self.scan_mlp_chunk_size = scan_mlp_chunk_size\n    self.bits = bits\n    self.use_sacn_mlp = use_shard_map\n    self.scan_layers = scan_layers\n    super().__init__(\n        bos_token_id=bos_token_id,\n        eos_token_id=eos_token_id,\n        tie_word_embeddings=tie_word_embeddings,\n        **kwargs,\n    )\n</code></pre>"},{"location":"generated-modules-llama-llama_configuration/#lib.python.EasyDel.modules.llama.llama_configuration.LlamaConfig.add_jax_args","title":"<code>add_jax_args(resid_pdrop=0.0, embd_pdrop=0.0, attention_dropout=0.0, tie_word_embeddings=False, gradient_checkpointing='nothing_saveable', fcm_min_ratio=0.0, fcm_max_ratio=0.0, use_pjit_attention_force=False, use_sacn_mlp=False, scan_mlp_chunk_size=1024, number_rep_kv=1, bits=None, rope_theta=10000.0, attention_bias=False, hidden_act='silu', scan_layers=True, **kwargs)</code>","text":"<p>The add_jax_args function adds the following arguments to the Transformer class:</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the current object</p> required <code>resid_pdrop</code> <code>float</code> <p>float: Set the dropout rate for residual connections</p> <code>0.0</code> <code>embd_pdrop</code> <code>float</code> <p>float: Set the probability of dropping an embedding</p> <code>0.0</code> <code>attention_dropout</code> <code>float</code> <p>float: Set the probability of dropping out the attention layer</p> <code>0.0</code> <code>tie_word_embeddings</code> <code>bool</code> <p>bool: Tie the word embeddings to the decoder</p> <code>False</code> <code>gradient_checkpointing</code> <code>str</code> <p>str: Control the amount of memory used by jax</p> <code>'nothing_saveable'</code> <code>fcm_min_ratio</code> <code>float</code> <p>float: Control the minimum ratio of the number of chunks to be used in flash-based computation</p> <code>0.0</code> <code>fcm_max_ratio</code> <code>float</code> <p>float: Set the maximum ratio of the number of input tokens to output tokens</p> <code>0.0</code> <code>use_pjit_attention_force</code> <code>bool</code> <p>bool: Determine if the attention force is used</p> <code>False</code> <code>use_sacn_mlp</code> <code>bool</code> <p>bool: Determine whether to use the scan_mlp function or not</p> <code>False</code> <code>scan_mlp_chunk_size</code> <code>int</code> <p>int: Set the chunk size for scan_mlp</p> <code>1024</code> <code>number_rep_kv</code> <code>int</code> <p>int: Determine how many times the key and value vectors are repeated</p> <code>1</code> <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Determine the number of bits used in the quantization</p> <code>None</code> <code>rope_theta</code> <code>float</code> <p>float : rope_theta for compute rope</p> <code>10000.0</code> <code>attention_bias</code> <code>bool</code> <p>bool : whenever to use attention bias or no</p> <code>False</code> <code>hidden_act</code> <code>str</code> <p>str : hidden_act for mlp</p> <code>'silu'</code> <code>scan_layers</code> <code>bool</code> <p>bool: Determine whether to use scan layers or not</p> <code>True</code> <p>Returns:</p> Type Description <p>The following:</p> Source code in <code>lib/python/EasyDel/modules/llama/llama_configuration.py</code> <pre><code>def add_jax_args(\n        self,\n        resid_pdrop: float = 0.0,\n        embd_pdrop: float = 0.0,\n        attention_dropout: float = 0.0,\n        tie_word_embeddings: bool = False,\n        gradient_checkpointing: str = 'nothing_saveable',\n        fcm_min_ratio: float = 0.0,\n        fcm_max_ratio: float = 0.0,\n        use_pjit_attention_force: bool = False,\n        use_sacn_mlp: bool = False,\n        scan_mlp_chunk_size: int = 1024,\n        number_rep_kv: int = 1,\n        bits: Optional[int] = None,\n        rope_theta: float = 10000.,\n        attention_bias: bool = False,\n        hidden_act: str = 'silu',\n        scan_layers: bool = True,\n        **kwargs,\n):\n    \"\"\"\n    The add_jax_args function adds the following arguments to the Transformer class:\n\n    :param self: Refer to the current object\n    :param resid_pdrop: float: Set the dropout rate for residual connections\n    :param embd_pdrop: float: Set the probability of dropping an embedding\n    :param attention_dropout: float: Set the probability of dropping out the attention layer\n    :param tie_word_embeddings: bool: Tie the word embeddings to the decoder\n    :param gradient_checkpointing: str: Control the amount of memory used by jax\n    :param fcm_min_ratio: float: Control the minimum ratio of the number of chunks to be used in flash-based computation\n    :param fcm_max_ratio: float: Set the maximum ratio of the number of input tokens to output tokens\n    :param use_pjit_attention_force: bool: Determine if the attention force is used\n    :param use_sacn_mlp: bool: Determine whether to use the scan_mlp function or not\n    :param scan_mlp_chunk_size: int: Set the chunk size for scan_mlp\n    :param number_rep_kv: int: Determine how many times the key and value vectors are repeated\n    :param bits: Optional[int]: Determine the number of bits used in the quantization\n    :param rope_theta: float : rope_theta for compute rope\n    :param attention_bias: bool : whenever to use attention bias or no\n    :param hidden_act: str : hidden_act for mlp\n    :param scan_layers: bool: Determine whether to use scan layers or not\n    :return: The following:\n\n    \"\"\"\n    self.scan_layers = scan_layers\n    self.embd_pdrop = embd_pdrop\n    self.number_rep_kv = number_rep_kv\n    self.resid_pdrop = resid_pdrop\n    self.rope_theta = rope_theta\n    self.attention_bias = attention_bias\n    self.attention_dropout = attention_dropout\n    self.hidden_act = hidden_act\n    self.tie_word_embeddings = tie_word_embeddings\n    self.gradient_checkpointing = gradient_checkpointing\n    self.fcm_min_ratio = fcm_min_ratio\n    self.fcm_max_ratio = fcm_max_ratio\n    self.use_pjit_attention_force = use_pjit_attention_force\n\n    self.use_sacn_mlp = use_sacn_mlp\n    self.scan_mlp_chunk_size = scan_mlp_chunk_size\n    self.bits = bits\n</code></pre>"},{"location":"generated-modules-llama-llama_configuration/#lib.python.EasyDel.modules.llama.llama_configuration.LlamaConfig.get_partition_rules","title":"<code>get_partition_rules(fully_sharded_data_parallel=True)</code>","text":"<p>The get_partition_rules function is used to define the partitioning scheme for a model. It returns a list of tuples, where each tuple contains two elements:     1) A regex string that matches the name of one or more parameters in the model.     2) A PartitionScheme object that defines how those parameters should be partitioned across devices.</p> <p>Parameters:</p> Name Type Description Default <code>fully_sharded_data_parallel</code> <code>bool</code> <p>bool: Determine whether to partition the model fully or not</p> <code>True</code> <p>Returns:</p> Type Description <p>A list of tuples</p> Source code in <code>lib/python/EasyDel/modules/llama/llama_configuration.py</code> <pre><code>def get_partition_rules(self, fully_sharded_data_parallel: bool = True):\n    \"\"\"\n    The get_partition_rules function is used to define the partitioning scheme for a model.\n    It returns a list of tuples, where each tuple contains two elements:\n        1) A regex string that matches the name of one or more parameters in the model.\n        2) A PartitionScheme object that defines how those parameters should be partitioned across devices.\n\n    :param fully_sharded_data_parallel: bool: Determine whether to partition the model fully or not\n    :return: A list of tuples\n\n    \"\"\"\n    return (\n\n        (\"model/embed_tokens/embedding\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n        (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n        (\"self_attn/o_proj/kernel\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n        (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n        (\"mlp/down_proj/kernel\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n        (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n\n        (\"input_layernorm/kernel\", PartitionSpec(None)),\n        (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n        (\"model/norm/kernel\", PartitionSpec(None)),\n        (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n        (\".*\", PartitionSpec(None)),\n    ) if not fully_sharded_data_parallel else (\n\n        (\"model/embed_tokens/embedding\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"self_attn/o_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/down_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"input_layernorm/kernel\", PartitionSpec(None)),\n        (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n        (\"model/norm/kernel\", PartitionSpec(None)),\n        (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\".*\", PartitionSpec((\"fsdp\", \"sp\"))),\n    )\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/","title":"modules.llama.modelling_llama_flax","text":""},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaAttention","title":"<code>FlaxLlamaAttention</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaAttention(nn.Module):\n    config: LlamaConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        config = self.config\n        self.hidden_size = config.hidden_size\n        self.head_dim = self.config.hidden_size // self.config.num_attention_heads\n        self.num_key_value_groups = self.config.num_attention_heads // self.config.num_key_value_heads\n\n        if self.num_key_value_groups == 1:\n            assert self.config.num_attention_heads == self.config.num_key_value_heads\n        self.q_proj = nn.Dense(\n            config.num_attention_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=self.config.attention_bias,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.k_proj = nn.Dense(\n            config.num_key_value_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=self.config.attention_bias,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.v_proj = nn.Dense(\n            config.num_key_value_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=self.config.attention_bias,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.o_proj = nn.Dense(\n            config.hidden_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n\n        self.rotary = FlaxLlamaEmbedding(self.dtype)\n        self.attention_performer = EasyAttention(\n            attn_type=\"normal\",\n            block_k_major=self.config.block_k_major,\n            block_b=self.config.block_b,\n            block_q=self.config.block_q,\n            block_k=self.config.block_k,\n            block_q_major_dkv=self.config.block_q_major_dkv,\n            block_k_major_dkv=self.config.block_k_major_dkv,\n            block_k_major_dq=self.config.block_k_major_dq,\n            block_k_dkv=self.config.block_k_dkv,\n            block_q_dkv=self.config.block_q_dkv,\n            block_q_dq=self.config.block_q_dq,\n            block_k_dq=self.config.block_k_dq,\n            num_attention_heads=self.config.num_attention_heads,\n            attention_dropout=self.config.attention_dropout,\n            head_dims=self.head_dim,\n            attention_partition_spec=self.config.attention_partition_spec,\n            use_shard_map=self.config.use_shard_map,\n            precision=self.precision,\n            force_float32_tpu=True,\n            attn_mechanism=self.config.attn_mechanism,\n            dtype=self.dtype,\n            bias_partition_spec=self.config.bias_partition_spec,\n            key_partition_spec=self.config.key_partition_spec,\n            query_partition_spec=self.config.query_partition_spec,\n            value_partition_spec=self.config.value_partition_spec,\n            mesh=self.config.jax_mesh(),\n            sm_scale=1 / math.sqrt(self.head_dim)\n        )\n        self.resid_dropout = nn.Dropout(rate=config.resid_pdrop)\n\n    def _merge_heads(self, hidden_states):\n        return hidden_states.reshape(hidden_states.shape[:2] + (self.hidden_size,))\n\n    @nn.compact\n    def _concatenate_to_cache(self, key, value, query, attention_mask):\n        \"\"\"\n        The _concatenate_to_cache function is used to concatenate the key and value vectors\n        of a query with those of previous queries. This allows for the attention mechanism to\n        look at all previous queries when computing its output. The function takes in three\n        arguments: key, value, and query. It also uses two variables that are stored in the cache:\n        cached_key and cached_value.\n\n        :param self: Access the variables stored in the cache\n        :param key: Store the keys of the encoder-decoder attention\n        :param value: Initialize the cached_value variable\n        :param query: Determine the number of cache vectors to update\n        :param attention_mask: Mask out the padded vectors in the cache\n        :return: The key, value and attention_mask\n\n        \"\"\"\n        is_initialized = self.has_variable(\"cache\", \"cached_key\")\n        cached_key = self.variable(\n            \"cache\", \"cached_key\", jnp.zeros, key.shape, key.dtype)\n        cached_value = self.variable(\n            \"cache\", \"cached_value\", jnp.zeros, value.shape, value.dtype)\n        cache_index = self.variable(\n            \"cache\", \"cache_index\", lambda: jnp.array(0, dtype=jnp.int32))\n\n        if is_initialized:\n            *batch_dims, max_length, num_heads, depth_per_head = cached_key.value.shape\n            cur_index = cache_index.value\n            indices = (0,) * len(batch_dims) + (cur_index, 0, 0)\n            key = lax.dynamic_update_slice(cached_key.value, key, indices)\n            value = lax.dynamic_update_slice(\n                cached_value.value, value, indices)\n            cached_key.value = key\n            cached_value.value = value\n            num_updated_cache_vectors = query.shape[1]\n            cache_index.value = cache_index.value + num_updated_cache_vectors\n\n            pad_mask = jnp.broadcast_to(\n                jnp.arange(max_length) &lt; cur_index + num_updated_cache_vectors,\n                tuple(batch_dims) + (1, num_updated_cache_vectors, max_length),\n            )\n            attention_mask = combine_masks(pad_mask, attention_mask)\n        return key, value, attention_mask\n\n    @staticmethod\n    def _t(query, key, value):\n        \"\"\"\n        The _t function transposes the query, key and value matrices.\n\n        :param query: Get the attention weights for each of the heads\n        :param key: Determine the number of heads\n        :param value: Store the values of the input\n        :return: The transpose of the query, key and value matrices\n\n        \"\"\"\n        return jnp.transpose(query, (0, 2, 1, 3)), jnp.transpose(key, (0, 2, 1, 3)), jnp.transpose(value, (0, 2, 1, 3))\n\n    def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n        \"\"\"\n        The apply_rotary function is a modified version of the apply_attention function in the BertModel class.\n        The main difference is that it takes in an additional argument, freq_cis, which are used to calculate\n        the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.\n\n        :param self: Access variables that belong to the class\n        :param batch_size: Reshape the query, key and value tensors\n        :param sequence_length: Reshape the query, key and value tensors\n        :param query: Calculate the attention weights\n        :param key: Calculate the attention\n        :param value: Compute the attention weights\n        :param freq_cis: Calculate the frequency of each word in the vocabulary\n        :param position_ids: Identify the position of each token in the sequence\n        :return: A tuple of 3 tensors: query, key and value\n\n        \"\"\"\n        query = query.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_attention_heads,\n            self.head_dim\n        )\n        key = key.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_key_value_heads,\n            self.head_dim\n        )\n        value = value.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_key_value_heads,\n            self.head_dim\n        )\n\n        query, key, value = self._t(query, key, value)\n        query, key = self.rotary(\n            position_ids=position_ids, query=query, key=key, freq_cis=freq_cis\n        )\n        key = repeat_kv_bnsh(key, self.num_key_value_groups)\n        value = repeat_kv_bnsh(value, self.num_key_value_groups)\n        return self._t(query, key, value)\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            causal_mask: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            fcm_mask=None,\n    ):\n        \"\"\"\n\n        The __call__ function is the main function of a JAX module. It defines how the module behaves when called\n        with inputs. The __call__ function can be thought of as a &amp;quot;forward pass&amp;quot; through the model,\n        and it should return all outputs that are needed for training or inference.\n\n        :param self: Access variables that belong to the class\n        :param hidden_states: chex.Array: Pass the hidden states of the previous layer\n        :param freq_cis: chex.Array: Pass in the frequency coefficients for each position\n        :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n        :param position_ids: chex.Array: Determine the position of each token in a sequence\n        :param causal_mask: chex.Array: Mask out the future tokens in the decoder\n        :param deterministic: bool: Determine whether to use dropout or not\n        :param init_cache: bool: Initialize the cache\n        :param output_attentions: bool: Determine whether to return the attention weights or not\n        :param fcm_mask: Mask out the attention weights between the input and output tokens\n        :param : Determine if the attention is causal or not\n        :return: A tuple of two arrays\n\n        \"\"\"\n        batch_size, sequence_length = hidden_states.shape[:2]\n        query_state, key_state, value_state = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(\n            hidden_states)\n\n        if self.config.use_pjit_attention_force:\n            query_state = with_sharding_constraint(\n                query_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n            key_state = with_sharding_constraint(\n                key_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n            value_state = with_sharding_constraint(\n                value_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n\n        query_state = query_state.reshape(\n            batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n        key_state = key_state.reshape(\n            batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n        value_state = value_state.reshape(\n            batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n        query_state, key_state, value_state = self.apply_rotary(\n            query=query_state,\n            key=key_state,\n            value=value_state,\n            position_ids=position_ids,\n            freq_cis=freq_cis,\n            batch_size=batch_size,\n            sequence_length=sequence_length\n        )\n\n        assert_msg = (\n            \"num_attention_heads repeat wont work likely\\n\"\n            f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n            f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n        )\n\n        assert query_state.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert key_state.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert value_state.shape[-2] == self.config.num_attention_heads, assert_msg\n\n        query_length, key_length = query_state.shape[1], key_state.shape[1]\n\n        if self.has_variable(\"cache\", \"cached_key\"):\n            mask_shift = self.variables[\"cache\"][\"cache_index\"]\n            max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n            causal_mask = lax.dynamic_slice(\n                causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                     query_length, max_decoder_length)\n            )\n        else:\n            causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n        batch_size = hidden_states.shape[0]\n        causal_mask = jnp.broadcast_to(\n            causal_mask, (batch_size,) + causal_mask.shape[1:])\n        attention_mask = jnp.broadcast_to(jnp.expand_dims(\n            attention_mask, axis=(-3, -2)), causal_mask.shape)\n        attention_mask = combine_masks(attention_mask, causal_mask, fcm_mask)\n        if attention_mask.ndim == 2:\n            attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n\n        dropout_rng = None\n\n        if not deterministic and self.config.attention_dropout &gt; 0.0:\n            dropout_rng = self.make_rng(\"dropout\")\n\n        if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n            key_state, value_state, attention_mask = self._concatenate_to_cache(\n                key_state,\n                value_state,\n                query_state,\n                attention_mask\n            )\n\n        attention_bias = lax.select(\n            attention_mask &gt; 0,\n            jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n            jnp.full(attention_mask.shape, jnp.finfo(\n                self.dtype).min).astype(self.dtype),\n        )\n\n        query_state, key_state, value_state = map(\n            lambda a: a.transpose(0, 2, 1, 3),\n            [query_state, key_state, value_state]\n        )\n\n        query_length, key_length = query_state.shape[-2], key_state.shape[-2]\n\n        attentions = self.attention_performer.__call__(\n            query_states=query_state,\n            key_states=key_state,\n            value_states=value_state,\n            bias=attention_bias,\n            causal=False,\n            use_pjit_attention_force=self.config.use_pjit_attention_force,\n            dropout_rng=dropout_rng,\n            deterministic=deterministic,\n            query_sequence_length=query_length,\n            key_value_sequence_length=key_length,\n            uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n        )\n        attentions.attention_outputs = attentions.attention_outputs.transpose(0, 2, 1, 3)\n\n        attn_output = self._merge_heads(attentions.attention_outputs)\n        attn_output = self.o_proj(attn_output)\n\n        attn_output = self.resid_dropout(\n            attn_output, deterministic=deterministic)\n        outputs = (\n            attn_output, attentions.attention_weights\n        ) if output_attentions else (\n            attn_output,\n        )\n        return outputs\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaAttention.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, position_ids, causal_mask, deterministic=True, init_cache=False, output_attentions=False, fcm_mask=None)</code>","text":"<p>The call function is the main function of a JAX module. It defines how the module behaves when called with inputs. The call function can be thought of as a \"forward pass\" through the model, and it should return all outputs that are needed for training or inference.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass the hidden states of the previous layer</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass in the frequency coefficients for each position</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out certain tokens in the input sequence</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Determine the position of each token in a sequence</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask out the future tokens in the decoder</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attention weights or not</p> <code>False</code> <code>fcm_mask</code> <p>Mask out the attention weights between the input and output tokens</p> <code>None</code> <code></code> <p>Determine if the attention is causal or not</p> required <p>Returns:</p> Type Description <p>A tuple of two arrays</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        causal_mask: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        fcm_mask=None,\n):\n    \"\"\"\n\n    The __call__ function is the main function of a JAX module. It defines how the module behaves when called\n    with inputs. The __call__ function can be thought of as a &amp;quot;forward pass&amp;quot; through the model,\n    and it should return all outputs that are needed for training or inference.\n\n    :param self: Access variables that belong to the class\n    :param hidden_states: chex.Array: Pass the hidden states of the previous layer\n    :param freq_cis: chex.Array: Pass in the frequency coefficients for each position\n    :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n    :param position_ids: chex.Array: Determine the position of each token in a sequence\n    :param causal_mask: chex.Array: Mask out the future tokens in the decoder\n    :param deterministic: bool: Determine whether to use dropout or not\n    :param init_cache: bool: Initialize the cache\n    :param output_attentions: bool: Determine whether to return the attention weights or not\n    :param fcm_mask: Mask out the attention weights between the input and output tokens\n    :param : Determine if the attention is causal or not\n    :return: A tuple of two arrays\n\n    \"\"\"\n    batch_size, sequence_length = hidden_states.shape[:2]\n    query_state, key_state, value_state = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(\n        hidden_states)\n\n    if self.config.use_pjit_attention_force:\n        query_state = with_sharding_constraint(\n            query_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n        key_state = with_sharding_constraint(\n            key_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n        value_state = with_sharding_constraint(\n            value_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n\n    query_state = query_state.reshape(\n        batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n    key_state = key_state.reshape(\n        batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n    value_state = value_state.reshape(\n        batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n    query_state, key_state, value_state = self.apply_rotary(\n        query=query_state,\n        key=key_state,\n        value=value_state,\n        position_ids=position_ids,\n        freq_cis=freq_cis,\n        batch_size=batch_size,\n        sequence_length=sequence_length\n    )\n\n    assert_msg = (\n        \"num_attention_heads repeat wont work likely\\n\"\n        f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n        f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n    )\n\n    assert query_state.shape[-2] == self.config.num_attention_heads, assert_msg\n    assert key_state.shape[-2] == self.config.num_attention_heads, assert_msg\n    assert value_state.shape[-2] == self.config.num_attention_heads, assert_msg\n\n    query_length, key_length = query_state.shape[1], key_state.shape[1]\n\n    if self.has_variable(\"cache\", \"cached_key\"):\n        mask_shift = self.variables[\"cache\"][\"cache_index\"]\n        max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n        causal_mask = lax.dynamic_slice(\n            causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                 query_length, max_decoder_length)\n        )\n    else:\n        causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n    batch_size = hidden_states.shape[0]\n    causal_mask = jnp.broadcast_to(\n        causal_mask, (batch_size,) + causal_mask.shape[1:])\n    attention_mask = jnp.broadcast_to(jnp.expand_dims(\n        attention_mask, axis=(-3, -2)), causal_mask.shape)\n    attention_mask = combine_masks(attention_mask, causal_mask, fcm_mask)\n    if attention_mask.ndim == 2:\n        attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n\n    dropout_rng = None\n\n    if not deterministic and self.config.attention_dropout &gt; 0.0:\n        dropout_rng = self.make_rng(\"dropout\")\n\n    if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n        key_state, value_state, attention_mask = self._concatenate_to_cache(\n            key_state,\n            value_state,\n            query_state,\n            attention_mask\n        )\n\n    attention_bias = lax.select(\n        attention_mask &gt; 0,\n        jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n        jnp.full(attention_mask.shape, jnp.finfo(\n            self.dtype).min).astype(self.dtype),\n    )\n\n    query_state, key_state, value_state = map(\n        lambda a: a.transpose(0, 2, 1, 3),\n        [query_state, key_state, value_state]\n    )\n\n    query_length, key_length = query_state.shape[-2], key_state.shape[-2]\n\n    attentions = self.attention_performer.__call__(\n        query_states=query_state,\n        key_states=key_state,\n        value_states=value_state,\n        bias=attention_bias,\n        causal=False,\n        use_pjit_attention_force=self.config.use_pjit_attention_force,\n        dropout_rng=dropout_rng,\n        deterministic=deterministic,\n        query_sequence_length=query_length,\n        key_value_sequence_length=key_length,\n        uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n    )\n    attentions.attention_outputs = attentions.attention_outputs.transpose(0, 2, 1, 3)\n\n    attn_output = self._merge_heads(attentions.attention_outputs)\n    attn_output = self.o_proj(attn_output)\n\n    attn_output = self.resid_dropout(\n        attn_output, deterministic=deterministic)\n    outputs = (\n        attn_output, attentions.attention_weights\n    ) if output_attentions else (\n        attn_output,\n    )\n    return outputs\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaAttention.apply_rotary","title":"<code>apply_rotary(batch_size, sequence_length, query, key, value, freq_cis, position_ids)</code>","text":"<p>The apply_rotary function is a modified version of the apply_attention function in the BertModel class. The main difference is that it takes in an additional argument, freq_cis, which are used to calculate the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>batch_size</code> <p>Reshape the query, key and value tensors</p> required <code>sequence_length</code> <p>Reshape the query, key and value tensors</p> required <code>query</code> <p>Calculate the attention weights</p> required <code>key</code> <p>Calculate the attention</p> required <code>value</code> <p>Compute the attention weights</p> required <code>freq_cis</code> <p>Calculate the frequency of each word in the vocabulary</p> required <code>position_ids</code> <p>Identify the position of each token in the sequence</p> required <p>Returns:</p> Type Description <p>A tuple of 3 tensors: query, key and value</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n    \"\"\"\n    The apply_rotary function is a modified version of the apply_attention function in the BertModel class.\n    The main difference is that it takes in an additional argument, freq_cis, which are used to calculate\n    the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.\n\n    :param self: Access variables that belong to the class\n    :param batch_size: Reshape the query, key and value tensors\n    :param sequence_length: Reshape the query, key and value tensors\n    :param query: Calculate the attention weights\n    :param key: Calculate the attention\n    :param value: Compute the attention weights\n    :param freq_cis: Calculate the frequency of each word in the vocabulary\n    :param position_ids: Identify the position of each token in the sequence\n    :return: A tuple of 3 tensors: query, key and value\n\n    \"\"\"\n    query = query.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_attention_heads,\n        self.head_dim\n    )\n    key = key.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_key_value_heads,\n        self.head_dim\n    )\n    value = value.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_key_value_heads,\n        self.head_dim\n    )\n\n    query, key, value = self._t(query, key, value)\n    query, key = self.rotary(\n        position_ids=position_ids, query=query, key=key, freq_cis=freq_cis\n    )\n    key = repeat_kv_bnsh(key, self.num_key_value_groups)\n    value = repeat_kv_bnsh(value, self.num_key_value_groups)\n    return self._t(query, key, value)\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaBlock","title":"<code>FlaxLlamaBlock</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaBlock(nn.Module):\n    config: LlamaConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self) -&gt; None:\n        attn_block = FlaxLlamaAttention\n        if self.config.gradient_checkpointing != \"\":\n            attn_block = nn_partitioning.remat(\n                FlaxLlamaAttention, static_argnums=(5, 6, 7),\n                policy=get_gradient_checkpoint_policy(\n                    self.config.gradient_checkpointing)\n            )\n\n        self.self_attn = attn_block(\n            self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        mlp_block = FlaxLlamaMLP\n\n        if self.config.gradient_checkpointing != \"\":\n            mlp_block = nn_partitioning.remat(\n                FlaxLlamaMLP, static_argnums=(1,),\n                policy=get_gradient_checkpoint_policy(\n                    self.config.gradient_checkpointing)\n            )\n\n        self.mlp = mlp_block(\n            self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision,\n        )\n        self.input_layernorm = RMSNorm(\n            self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n        )\n        self.post_attention_layernorm = RMSNorm(\n            self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n\n        )\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            causal_mask: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            fcm_mask: Optional[jnp.ndarray] = None,\n    ):\n        \"\"\"\n        The __call__ function is the main function of a TransformerEncoderLayer.\n        It takes in hidden states, frequency-domain inputs, and masks as input. It then\n        applies self-attention to the hidden states using those inputs and returns an\n        output tensor with shape (batch_size, sequence_length, model_dim).\n\n        :param self: Refer to the class instance itself\n        :param hidden_states: chex.Array: Pass in the hidden state of the previous layer\n        :param freq_cis: chex.Array: Pass in the frequency information\n        :param attention_mask: chex.Array: Mask out the attention weights for padding tokens\n        :param position_ids: chex.Array: Determine the position of each token in the sequence\n        :param causal_mask: chex.Array: Mask the attention weights\n        :param deterministic: bool: Control whether the dropout is applied or not\n        :param init_cache: bool: Initialize the cache in the attention layer\n        :param output_attentions: bool: Return the attention weights\n        :param fcm_mask: Optional[jnp.ndarray]: Mask the self-attention\n        :param : Control the dropout in the self attention layer\n        :return: A tuple of two items\n\n        \"\"\"\n        attn_outputs = self.self_attn(\n            self.input_layernorm(hidden_states),\n            freq_cis,\n            attention_mask,\n            position_ids,\n            causal_mask,\n            deterministic,\n            init_cache,\n            output_attentions,\n            fcm_mask,\n        )\n        attn_output = attn_outputs[0]\n        hidden_states = hidden_states + attn_output\n\n        feed_forward_input = self.post_attention_layernorm(hidden_states)\n\n        if self.config.use_sacn_mlp:\n            feed_forward_input = einops.rearrange(\n                feed_forward_input,\n                '... (b s) d -&gt; ... b s d',\n                b=self.config.scan_mlp_chunk_size\n            )\n\n            def mlp_forward(mlp, carry, x):\n                return None, mlp(x, deterministic)\n\n            scan_axis = feed_forward_input.ndim - 3\n\n            _, feed_forward_hidden_states = nn.scan(\n                mlp_forward,\n                variable_broadcast=\"params\",\n                split_rngs={\"params\": False, \"dropout\": True},\n                in_axes=scan_axis,\n                out_axes=scan_axis,\n            )(self.mlp, None, feed_forward_input)\n            feed_forward_hidden_states = einops.rearrange(\n                feed_forward_hidden_states,\n                '... b s d -&gt; ... (b s) d'\n            )\n        else:\n            feed_forward_hidden_states = self.mlp(\n                feed_forward_input,\n                deterministic,\n            )\n\n        hidden_states = hidden_states + feed_forward_hidden_states\n\n        return (hidden_states,) + attn_outputs[1:]\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaBlock.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, position_ids, causal_mask, deterministic=True, init_cache=False, output_attentions=False, fcm_mask=None)</code>","text":"<p>The call function is the main function of a TransformerEncoderLayer. It takes in hidden states, frequency-domain inputs, and masks as input. It then applies self-attention to the hidden states using those inputs and returns an output tensor with shape (batch_size, sequence_length, model_dim).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the class instance itself</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass in the hidden state of the previous layer</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass in the frequency information</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the attention weights for padding tokens</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Determine the position of each token in the sequence</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask the attention weights</p> required <code>deterministic</code> <code>bool</code> <p>bool: Control whether the dropout is applied or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache in the attention layer</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Return the attention weights</p> <code>False</code> <code>fcm_mask</code> <code>Optional[ndarray]</code> <p>Optional[jnp.ndarray]: Mask the self-attention</p> <code>None</code> <code></code> <p>Control the dropout in the self attention layer</p> required <p>Returns:</p> Type Description <p>A tuple of two items</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        causal_mask: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        fcm_mask: Optional[jnp.ndarray] = None,\n):\n    \"\"\"\n    The __call__ function is the main function of a TransformerEncoderLayer.\n    It takes in hidden states, frequency-domain inputs, and masks as input. It then\n    applies self-attention to the hidden states using those inputs and returns an\n    output tensor with shape (batch_size, sequence_length, model_dim).\n\n    :param self: Refer to the class instance itself\n    :param hidden_states: chex.Array: Pass in the hidden state of the previous layer\n    :param freq_cis: chex.Array: Pass in the frequency information\n    :param attention_mask: chex.Array: Mask out the attention weights for padding tokens\n    :param position_ids: chex.Array: Determine the position of each token in the sequence\n    :param causal_mask: chex.Array: Mask the attention weights\n    :param deterministic: bool: Control whether the dropout is applied or not\n    :param init_cache: bool: Initialize the cache in the attention layer\n    :param output_attentions: bool: Return the attention weights\n    :param fcm_mask: Optional[jnp.ndarray]: Mask the self-attention\n    :param : Control the dropout in the self attention layer\n    :return: A tuple of two items\n\n    \"\"\"\n    attn_outputs = self.self_attn(\n        self.input_layernorm(hidden_states),\n        freq_cis,\n        attention_mask,\n        position_ids,\n        causal_mask,\n        deterministic,\n        init_cache,\n        output_attentions,\n        fcm_mask,\n    )\n    attn_output = attn_outputs[0]\n    hidden_states = hidden_states + attn_output\n\n    feed_forward_input = self.post_attention_layernorm(hidden_states)\n\n    if self.config.use_sacn_mlp:\n        feed_forward_input = einops.rearrange(\n            feed_forward_input,\n            '... (b s) d -&gt; ... b s d',\n            b=self.config.scan_mlp_chunk_size\n        )\n\n        def mlp_forward(mlp, carry, x):\n            return None, mlp(x, deterministic)\n\n        scan_axis = feed_forward_input.ndim - 3\n\n        _, feed_forward_hidden_states = nn.scan(\n            mlp_forward,\n            variable_broadcast=\"params\",\n            split_rngs={\"params\": False, \"dropout\": True},\n            in_axes=scan_axis,\n            out_axes=scan_axis,\n        )(self.mlp, None, feed_forward_input)\n        feed_forward_hidden_states = einops.rearrange(\n            feed_forward_hidden_states,\n            '... b s d -&gt; ... (b s) d'\n        )\n    else:\n        feed_forward_hidden_states = self.mlp(\n            feed_forward_input,\n            deterministic,\n        )\n\n    hidden_states = hidden_states + feed_forward_hidden_states\n\n    return (hidden_states,) + attn_outputs[1:]\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaBlockCollection","title":"<code>FlaxLlamaBlockCollection</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaBlockCollection(nn.Module):\n    config: LlamaConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        self.blocks = [\n            FlaxLlamaBlock(\n                self.config,\n                name=str(i),\n                dtype=self.dtype,\n                param_dtype=self.param_dtype,\n                precision=self.precision\n            )\n            for i in range(self.config.num_hidden_layers)\n        ]\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            causal_mask: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n    ):\n        \"\"\"\n        The __call__ function is the main function of a JAX nn.Module.\n        It defines how the module behaves when called as a function, and it's what you'll use to call your model\n         in training loops or inference scripts.\n        The __call__ method should take all inputs that are necessary for computing outputs from the module,\n        and return all outputs that are computed by this module.\n\n        :param self: Represent the instance of the class\n        :param hidden_states: chex.Array: Pass the input tensor to the encoder\n        :param freq_cis: chex.Array: Pass in the frequency of each token\n        :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n        :param position_ids: chex.Array: Specify the position of each token in a sequence\n        :param causal_mask: chex.Array: Mask the attention weights\n        :param deterministic: bool: Determine whether the model is in training or evaluation mode\n        :param init_cache: bool: Initialize the cache for each layer\n        :param output_attentions: bool: Determine whether to output the attention weights\n        :param output_hidden_states: bool: Determine whether to return the hidden states of each layer\n        :param return_dict: bool: Return a dictionary of the outputs\n        :param : Determine whether to use the forgetful causal mask\n        :return: A tuple of 3 values\n\n        \"\"\"\n        all_attentions = () if output_attentions else None\n        all_hidden_states = () if output_hidden_states else None\n\n        if not deterministic and self.config.fcm_max_ratio &gt; 0:\n            # Apply forgetful causal mask\n            batch_size, seq_length = hidden_states.shape[0], hidden_states.shape[1]\n            fcm_ratio = jax.random.uniform(\n                self.make_rng('fcm'), shape=(batch_size, 1, 1, 1),\n                minval=self.config.fcm_min_ratio,\n                maxval=self.config.fcm_max_ratio\n            )\n            fcm_mask = jax.random.uniform(\n                self.make_rng('fcm'),\n                shape=(batch_size, 1, seq_length, seq_length)\n            ) &gt; fcm_ratio\n            fcm_mask = fcm_mask.at[:, :, :, 0].set(True)\n            fcm_mask = fcm_mask.astype('bool')\n        else:\n            fcm_mask = None\n\n        for block in self.blocks:\n            if output_hidden_states:\n                all_hidden_states += (hidden_states,)\n\n            layer_outputs = block(\n                hidden_states=hidden_states,\n                freq_cis=freq_cis,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                causal_mask=causal_mask,\n                deterministic=deterministic,\n                init_cache=init_cache,\n                output_attentions=output_attentions,\n                fcm_mask=fcm_mask,\n            )\n            hidden_states = layer_outputs[0]\n\n            if output_attentions:\n                all_attentions += (layer_outputs[1],)\n\n        outputs = (hidden_states, all_hidden_states, all_attentions)\n\n        return outputs\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaBlockCollection.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, position_ids, causal_mask, deterministic=True, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True)</code>","text":"<p>The call function is the main function of a JAX nn.Module. It defines how the module behaves when called as a function, and it's what you'll use to call your model  in training loops or inference scripts. The call method should take all inputs that are necessary for computing outputs from the module, and return all outputs that are computed by this module.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass the input tensor to the encoder</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass in the frequency of each token</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out certain tokens in the input sequence</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in a sequence</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask the attention weights</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether the model is in training or evaluation mode</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for each layer</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to output the attention weights</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Determine whether to return the hidden states of each layer</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of the outputs</p> <code>True</code> <code></code> <p>Determine whether to use the forgetful causal mask</p> required <p>Returns:</p> Type Description <p>A tuple of 3 values</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        causal_mask: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n):\n    \"\"\"\n    The __call__ function is the main function of a JAX nn.Module.\n    It defines how the module behaves when called as a function, and it's what you'll use to call your model\n     in training loops or inference scripts.\n    The __call__ method should take all inputs that are necessary for computing outputs from the module,\n    and return all outputs that are computed by this module.\n\n    :param self: Represent the instance of the class\n    :param hidden_states: chex.Array: Pass the input tensor to the encoder\n    :param freq_cis: chex.Array: Pass in the frequency of each token\n    :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n    :param position_ids: chex.Array: Specify the position of each token in a sequence\n    :param causal_mask: chex.Array: Mask the attention weights\n    :param deterministic: bool: Determine whether the model is in training or evaluation mode\n    :param init_cache: bool: Initialize the cache for each layer\n    :param output_attentions: bool: Determine whether to output the attention weights\n    :param output_hidden_states: bool: Determine whether to return the hidden states of each layer\n    :param return_dict: bool: Return a dictionary of the outputs\n    :param : Determine whether to use the forgetful causal mask\n    :return: A tuple of 3 values\n\n    \"\"\"\n    all_attentions = () if output_attentions else None\n    all_hidden_states = () if output_hidden_states else None\n\n    if not deterministic and self.config.fcm_max_ratio &gt; 0:\n        # Apply forgetful causal mask\n        batch_size, seq_length = hidden_states.shape[0], hidden_states.shape[1]\n        fcm_ratio = jax.random.uniform(\n            self.make_rng('fcm'), shape=(batch_size, 1, 1, 1),\n            minval=self.config.fcm_min_ratio,\n            maxval=self.config.fcm_max_ratio\n        )\n        fcm_mask = jax.random.uniform(\n            self.make_rng('fcm'),\n            shape=(batch_size, 1, seq_length, seq_length)\n        ) &gt; fcm_ratio\n        fcm_mask = fcm_mask.at[:, :, :, 0].set(True)\n        fcm_mask = fcm_mask.astype('bool')\n    else:\n        fcm_mask = None\n\n    for block in self.blocks:\n        if output_hidden_states:\n            all_hidden_states += (hidden_states,)\n\n        layer_outputs = block(\n            hidden_states=hidden_states,\n            freq_cis=freq_cis,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            causal_mask=causal_mask,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            fcm_mask=fcm_mask,\n        )\n        hidden_states = layer_outputs[0]\n\n        if output_attentions:\n            all_attentions += (layer_outputs[1],)\n\n    outputs = (hidden_states, all_hidden_states, all_attentions)\n\n    return outputs\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaForCausalLM","title":"<code>FlaxLlamaForCausalLM</code>","text":"<p>             Bases: <code>FlaxLlamaPreTrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaForCausalLM(FlaxLlamaPreTrainedModel):\n    module_class = FlaxLlamaForCausalLMModule\n\n    def set_input_embeddings(self, value):\n        self.module.model.embed_tokens = value\n\n    def get_input_embeddings(self):\n        return self.module.model.embed_tokens\n\n    def set_decoder(self, decoder):\n        self.module.model = decoder\n\n    def get_decoder(self):\n        return self.module.model\n\n    def get_output_embeddings(self):\n        return self.module.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.module.lm_head = new_embeddings\n\n    def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n        \"\"\"\n        The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.\n\n        :param self: Access variables that belong to the class\n        :param input_ids: Pass in the input tokens\n        :param max_length: Set the length of the sequence to be generated\n        :param attention_mask: Optional[chex.Array]: Mask the attention weights\n        :return: A dictionary of the past_key_values, attention_mask and position ids\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n\n        past_key_values = self.init_cache(batch_size, max_length)\n        extended_attention_mask = jnp.ones(\n            (batch_size, max_length), dtype=\"i4\")\n        if attention_mask is not None:\n            position_ids = attention_mask.cumsum(axis=-1) - 1\n            extended_attention_mask = lax.dynamic_update_slice(\n                extended_attention_mask, attention_mask, (0, 0))\n        else:\n            position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[\n                                            None, :], (batch_size, seq_length))\n\n        return {\n            \"past_key_values\": past_key_values,\n            \"attention_mask\": extended_attention_mask,\n            \"position_ids\": position_ids,\n        }\n\n    def update_inputs_for_generation(self, model_outputs, model_kwargs):\n        model_kwargs[\"past_key_values\"] = model_outputs.past_key_values\n        model_kwargs[\"position_ids\"] = model_kwargs[\"position_ids\"][:, -1:] + 1\n        return model_kwargs\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaForCausalLM.prepare_inputs_for_generation","title":"<code>prepare_inputs_for_generation(input_ids, max_length, attention_mask=None)</code>","text":"<p>The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>input_ids</code> <p>Pass in the input tokens</p> required <code>max_length</code> <p>Set the length of the sequence to be generated</p> required <code>attention_mask</code> <code>Optional[Array]</code> <p>Optional[chex.Array]: Mask the attention weights</p> <code>None</code> <p>Returns:</p> Type Description <p>A dictionary of the past_key_values, attention_mask and position ids</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n    \"\"\"\n    The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.\n\n    :param self: Access variables that belong to the class\n    :param input_ids: Pass in the input tokens\n    :param max_length: Set the length of the sequence to be generated\n    :param attention_mask: Optional[chex.Array]: Mask the attention weights\n    :return: A dictionary of the past_key_values, attention_mask and position ids\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n\n    past_key_values = self.init_cache(batch_size, max_length)\n    extended_attention_mask = jnp.ones(\n        (batch_size, max_length), dtype=\"i4\")\n    if attention_mask is not None:\n        position_ids = attention_mask.cumsum(axis=-1) - 1\n        extended_attention_mask = lax.dynamic_update_slice(\n            extended_attention_mask, attention_mask, (0, 0))\n    else:\n        position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[\n                                        None, :], (batch_size, seq_length))\n\n    return {\n        \"past_key_values\": past_key_values,\n        \"attention_mask\": extended_attention_mask,\n        \"position_ids\": position_ids,\n    }\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaForCausalLMModule","title":"<code>FlaxLlamaForCausalLMModule</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaForCausalLMModule(nn.Module):\n    config: LlamaConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        self.model = FlaxLlamaModule(self.config,\n                                     dtype=self.dtype,\n                                     param_dtype=self.param_dtype,\n                                     precision=self.precision,\n                                     )\n\n        self.lm_head = nn.Dense(\n            self.config.vocab_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                stddev=self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array = None,\n            position_ids: chex.Array = None,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n    ):\n        \"\"\"\n        The __call__ function is the main function of a Flax module. It takes in inputs and returns outputs.\n\n        :param self: Refer to the object itself\n        :param input_ids: chex.Array: Pass the input token ids to the model\n        :param attention_mask: chex.Array: Mask out the padding tokens\n        :param position_ids: chex.Array: Specify the position of each token in the input sequence\n        :param deterministic: bool: Control whether the model is trained or not\n        :param init_cache: bool: Initialize the cache for the decoder\n        :param output_attentions: bool: Return the attention weights\n        :param output_hidden_states: bool: Determine whether to return the hidden states\n        :param return_dict: bool: Return a dictionary of the outputs or not\n        :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of the word that we want to predict\n        :param None]]: Pass in the extra embedding\n        :return: The logits and the hidden states\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n        if attention_mask is None:\n            attention_mask = jnp.ones_like(input_ids)\n        if position_ids is None:\n            position_ids = jnp.broadcast_to(\n                jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n                (batch_size, seq_length)\n            )\n        outputs = self.model(\n            input_ids,\n            attention_mask,\n            position_ids,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            extra_embedding=extra_embedding\n        )\n\n        hidden_states = outputs[0]\n\n        if self.config.tie_word_embeddings:\n            shared_kernel = self.model.variables[\"params\"][\"embed_tokens\"][\"embedding\"].T\n            lm_logits = self.lm_head.apply(\n                {\"params\": {\"kernel\": shared_kernel}}, hidden_states)\n        else:\n            lm_logits = self.lm_head(hidden_states)\n\n        lm_logits = lm_logits.astype(jnp.float32)\n\n        if not return_dict:\n            return (lm_logits,) + outputs[1:]\n\n        return FlaxCausalLMOutput(logits=lm_logits, hidden_states=outputs.hidden_states, attentions=outputs.attentions)\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaForCausalLMModule.__call__","title":"<code>__call__(input_ids, attention_mask=None, position_ids=None, deterministic=True, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True, extra_embedding=None)</code>","text":"<p>The call function is the main function of a Flax module. It takes in inputs and returns outputs.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass the input token ids to the model</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the padding tokens</p> <code>None</code> <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in the input sequence</p> <code>None</code> <code>deterministic</code> <code>bool</code> <p>bool: Control whether the model is trained or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the decoder</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Return the attention weights</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Determine whether to return the hidden states</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of the outputs or not</p> <code>True</code> <code>extra_embedding</code> <code>Optional[Union[ndarray, None]]</code> <p>Optional[Union[jnp.ndarray: Pass in the embedding of the word that we want to predict</p> <code>None</code> <code>None]]</code> <p>Pass in the extra embedding</p> required <p>Returns:</p> Type Description <p>The logits and the hidden states</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array = None,\n        position_ids: chex.Array = None,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n):\n    \"\"\"\n    The __call__ function is the main function of a Flax module. It takes in inputs and returns outputs.\n\n    :param self: Refer to the object itself\n    :param input_ids: chex.Array: Pass the input token ids to the model\n    :param attention_mask: chex.Array: Mask out the padding tokens\n    :param position_ids: chex.Array: Specify the position of each token in the input sequence\n    :param deterministic: bool: Control whether the model is trained or not\n    :param init_cache: bool: Initialize the cache for the decoder\n    :param output_attentions: bool: Return the attention weights\n    :param output_hidden_states: bool: Determine whether to return the hidden states\n    :param return_dict: bool: Return a dictionary of the outputs or not\n    :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of the word that we want to predict\n    :param None]]: Pass in the extra embedding\n    :return: The logits and the hidden states\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n    if attention_mask is None:\n        attention_mask = jnp.ones_like(input_ids)\n    if position_ids is None:\n        position_ids = jnp.broadcast_to(\n            jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n            (batch_size, seq_length)\n        )\n    outputs = self.model(\n        input_ids,\n        attention_mask,\n        position_ids,\n        deterministic=deterministic,\n        init_cache=init_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n        extra_embedding=extra_embedding\n    )\n\n    hidden_states = outputs[0]\n\n    if self.config.tie_word_embeddings:\n        shared_kernel = self.model.variables[\"params\"][\"embed_tokens\"][\"embedding\"].T\n        lm_logits = self.lm_head.apply(\n            {\"params\": {\"kernel\": shared_kernel}}, hidden_states)\n    else:\n        lm_logits = self.lm_head(hidden_states)\n\n    lm_logits = lm_logits.astype(jnp.float32)\n\n    if not return_dict:\n        return (lm_logits,) + outputs[1:]\n\n    return FlaxCausalLMOutput(logits=lm_logits, hidden_states=outputs.hidden_states, attentions=outputs.attentions)\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaForSequenceClassificationModule","title":"<code>FlaxLlamaForSequenceClassificationModule</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaForSequenceClassificationModule(nn.Module):\n    num_classes: int\n    config: LlamaConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        \"\"\"\n        The setup function is called once at the beginning of training.\n        It initializes the model and optimizer, and sets up any other state that needs to be initialized.\n\n        :param self: Access variables that belong to the class\n        :return: A tuple of the model and the classifier\n        \"\"\"\n        self.model = FlaxLlamaModule(self.config, dtype=self.dtype)\n        self.classifier = nn.Dense(\n            self.num_classes,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                stddev=self.config.initializer_range),\n            precision=self.precision,\n        )\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array = None,\n            position_ids: chex.Array = None,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n    ):\n        \"\"\"\n        The __call__ function is the main function of a Flax module.\n        It takes in all the inputs to the model and returns all outputs from it.\n        The __call__ function can be called directly on an instance of a class, or by using parentheses after an instance:\n            &amp;gt;&amp;gt;&amp;gt; my_model = MyModel()  # instantiate your model class\n            &amp;gt;&amp;gt;&amp;gt; output = my_model(input)  # call your model with input data as arguments to __call__\n\n        :param self: Refer to the class instance\n        :param input_ids: chex.Array: Pass the input to the model\n        :param attention_mask: chex.Array: Specify which tokens are masked\n        :param position_ids: chex.Array: Specify the position of each token in the sequence\n        :param deterministic: bool: Control whether the model is run in deterministic or stochastic mode\n        :param init_cache: bool: Initialize the cache for the transformer\n        :param output_attentions: bool: Return the attention weights\n        :param output_hidden_states: bool: Return the hidden states of all layers\n        :param return_dict: bool: Return a dictionary of outputs\n        :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of a new word\n        :param None]]: Pass the extra embedding to the model\n        :return: A tuple of logits and hidden_states\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n        if attention_mask is None:\n            attention_mask = jnp.ones_like(input_ids)\n        if position_ids is None:\n            position_ids = jnp.broadcast_to(\n                jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n                (batch_size, seq_length)\n            )\n        outputs = self.model(\n            input_ids,\n            attention_mask,\n            position_ids,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            extra_embedding=extra_embedding\n        )\n\n        hidden_states = outputs[0]\n        prediction = self.classifier(hidden_states)\n        if return_dict:\n            return FlaxSequenceClassifierOutput(\n                logits=prediction,\n                hidden_states=hidden_states\n            )\n        else:\n            return prediction,\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaForSequenceClassificationModule.__call__","title":"<code>__call__(input_ids, attention_mask=None, position_ids=None, deterministic=True, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True, extra_embedding=None)</code>","text":"<p>The call function is the main function of a Flax module. It takes in all the inputs to the model and returns all outputs from it. The call function can be called directly on an instance of a class, or by using parentheses after an instance:     &gt;&gt;&gt; my_model = MyModel()  # instantiate your model class     &gt;&gt;&gt; output = my_model(input)  # call your model with input data as arguments to call</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the class instance</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass the input to the model</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Specify which tokens are masked</p> <code>None</code> <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in the sequence</p> <code>None</code> <code>deterministic</code> <code>bool</code> <p>bool: Control whether the model is run in deterministic or stochastic mode</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the transformer</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Return the attention weights</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Return the hidden states of all layers</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of outputs</p> <code>True</code> <code>extra_embedding</code> <code>Optional[Union[ndarray, None]]</code> <p>Optional[Union[jnp.ndarray: Pass in the embedding of a new word</p> <code>None</code> <code>None]]</code> <p>Pass the extra embedding to the model</p> required <p>Returns:</p> Type Description <p>A tuple of logits and hidden_states</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array = None,\n        position_ids: chex.Array = None,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n):\n    \"\"\"\n    The __call__ function is the main function of a Flax module.\n    It takes in all the inputs to the model and returns all outputs from it.\n    The __call__ function can be called directly on an instance of a class, or by using parentheses after an instance:\n        &amp;gt;&amp;gt;&amp;gt; my_model = MyModel()  # instantiate your model class\n        &amp;gt;&amp;gt;&amp;gt; output = my_model(input)  # call your model with input data as arguments to __call__\n\n    :param self: Refer to the class instance\n    :param input_ids: chex.Array: Pass the input to the model\n    :param attention_mask: chex.Array: Specify which tokens are masked\n    :param position_ids: chex.Array: Specify the position of each token in the sequence\n    :param deterministic: bool: Control whether the model is run in deterministic or stochastic mode\n    :param init_cache: bool: Initialize the cache for the transformer\n    :param output_attentions: bool: Return the attention weights\n    :param output_hidden_states: bool: Return the hidden states of all layers\n    :param return_dict: bool: Return a dictionary of outputs\n    :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of a new word\n    :param None]]: Pass the extra embedding to the model\n    :return: A tuple of logits and hidden_states\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n    if attention_mask is None:\n        attention_mask = jnp.ones_like(input_ids)\n    if position_ids is None:\n        position_ids = jnp.broadcast_to(\n            jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n            (batch_size, seq_length)\n        )\n    outputs = self.model(\n        input_ids,\n        attention_mask,\n        position_ids,\n        deterministic=deterministic,\n        init_cache=init_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n        extra_embedding=extra_embedding\n    )\n\n    hidden_states = outputs[0]\n    prediction = self.classifier(hidden_states)\n    if return_dict:\n        return FlaxSequenceClassifierOutput(\n            logits=prediction,\n            hidden_states=hidden_states\n        )\n    else:\n        return prediction,\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaForSequenceClassificationModule.setup","title":"<code>setup()</code>","text":"<p>The setup function is called once at the beginning of training. It initializes the model and optimizer, and sets up any other state that needs to be initialized.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <p>Returns:</p> Type Description <p>A tuple of the model and the classifier</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def setup(self):\n    \"\"\"\n    The setup function is called once at the beginning of training.\n    It initializes the model and optimizer, and sets up any other state that needs to be initialized.\n\n    :param self: Access variables that belong to the class\n    :return: A tuple of the model and the classifier\n    \"\"\"\n    self.model = FlaxLlamaModule(self.config, dtype=self.dtype)\n    self.classifier = nn.Dense(\n        self.num_classes,\n        dtype=self.dtype,\n        param_dtype=self.param_dtype,\n        use_bias=False,\n        kernel_init=jax.nn.initializers.normal(\n            stddev=self.config.initializer_range),\n        precision=self.precision,\n    )\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaMLP","title":"<code>FlaxLlamaMLP</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaMLP(nn.Module):\n    config: LlamaConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self) -&gt; None:\n        config = self.config\n\n        self.gate_proj = nn.Dense(\n            config.intermediate_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.down_proj = nn.Dense(\n            config.hidden_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.up_proj = nn.Dense(\n            config.intermediate_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.dropout = nn.Dropout(rate=self.config.resid_pdrop)\n\n    def __call__(self, x: jnp.ndarray, deterministic: bool = True) -&gt; jnp.ndarray:\n        \"\"\"\n        The __call__ function is the main function of a class.\n        It is called when an instance of the class (an object) is invoked as a function, i.e., obj(arguments).\n        The __call__ method enables instances of a class to be called like standard Python functions.\n\n        :param self: Represent the instance of the class\n        :param x: jnp.ndarray: Pass in the input to the layer\n        :param deterministic: bool: Determine whether to use dropout\n        :return: A tensor that is the result of applying a dropout function to x\n\n        \"\"\"\n        x = self.down_proj(nn.silu(self.gate_proj(x)) * self.up_proj(x))\n        x = self.dropout(x, deterministic=deterministic)\n        return x\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaMLP.__call__","title":"<code>__call__(x, deterministic=True)</code>","text":"<p>The call function is the main function of a class. It is called when an instance of the class (an object) is invoked as a function, i.e., obj(arguments). The call method enables instances of a class to be called like standard Python functions.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>x</code> <code>ndarray</code> <p>jnp.ndarray: Pass in the input to the layer</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A tensor that is the result of applying a dropout function to x</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __call__(self, x: jnp.ndarray, deterministic: bool = True) -&gt; jnp.ndarray:\n    \"\"\"\n    The __call__ function is the main function of a class.\n    It is called when an instance of the class (an object) is invoked as a function, i.e., obj(arguments).\n    The __call__ method enables instances of a class to be called like standard Python functions.\n\n    :param self: Represent the instance of the class\n    :param x: jnp.ndarray: Pass in the input to the layer\n    :param deterministic: bool: Determine whether to use dropout\n    :return: A tensor that is the result of applying a dropout function to x\n\n    \"\"\"\n    x = self.down_proj(nn.silu(self.gate_proj(x)) * self.up_proj(x))\n    x = self.dropout(x, deterministic=deterministic)\n    return x\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaModule","title":"<code>FlaxLlamaModule</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaModule(nn.Module):\n    config: LlamaConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n\n        self.embed_tokens = nn.Embed(\n            self.config.vocab_size,\n            self.config.hidden_size,\n            embedding_init=jax.nn.initializers.normal(\n                stddev=self.config.initializer_range),\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n        )\n        self.dropout = nn.Dropout(rate=self.config.embd_pdrop)\n        self.layers = FlaxLlamaBlockCollection(self.config, dtype=self.dtype, param_dtype=self.param_dtype,\n                                               precision=self.precision)\n        self.norm = RMSNorm(self.config.hidden_size, eps=self.config.rms_norm_eps, dtype=self.dtype,\n                            param_dtype=self.param_dtype)\n        config = self.config\n        self.causal_mask = make_causal_mask(\n            jnp.ones((1, config.max_position_embeddings)))\n\n        initial_rope_kwargs = dict(\n            rope_type=\"none\"\n        )\n        if config.rope_scaling is not None:\n            scaling_type = config.rope_scaling[\"type\"]\n            scaling_factor = config.rope_scaling[\"factor\"]\n            initial_rope_kwargs = dict(\n                scaling_factor=scaling_factor,\n                rope_type=scaling_type\n            )\n        self.freq_cis = precompute_freq_cis(\n            max_position_embeddings=config.max_position_embeddings,\n            dim=config.hidden_size // config.num_attention_heads,\n            base=config.rope_theta,\n            **initial_rope_kwargs\n        )\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            deterministic: bool = True,\n            inputs_embeds: chex.Array = None,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n    ):\n        \"\"\"\n        The __call__ function is the main function of a Flax model. It takes in input_ids, attention_mask, and position_ids\n        and returns the output of the model. The __call__ function also has optional arguments that can be used to control\n        the behavior of the model (e.g., deterministic=True). These optional arguments are passed as keyword arguments when\n        calling a Flax model.\n\n        :param self: Represent the instance of the class\n        :param input_ids: chex.Array: Pass in the input token ids\n        :param attention_mask: chex.Array: Mask out the padding tokens\n        :param position_ids: chex.Array: Indicate the position of each token in a sequence\n        :param deterministic: bool: Control whether dropout is applied or not\n        :param inputs_embeds: chex.Array: Pass in the embeddings of the input tokens\n        :param init_cache: bool: Initialize the cache\n        :param output_attentions: bool: Determine whether to return the attentions or not\n        :param output_hidden_states: bool: Determine whether to return hidden states\n        :param return_dict: bool: Return a dictionary of the output or not\n        :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of the\n        :param None]]: Pass in the extra embedding\n        :return: A tuple of:\n\n        \"\"\"\n        if inputs_embeds is None:\n            inputs_embeds = self.embed_tokens(input_ids.astype(\"i4\"))\n\n        batch_size, sequence_length, _ = inputs_embeds.shape\n\n        assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n        inputs_embeds = inputs_embeds + \\\n                        extra_embedding if extra_embedding is not None else inputs_embeds\n        hidden_states = self.dropout(\n            inputs_embeds, deterministic=deterministic)\n\n        outputs = self.layers(\n            hidden_states=hidden_states,\n            freq_cis=self.freq_cis,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            causal_mask=self.causal_mask,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n\n        hidden_states = outputs[0]\n        hidden_states = self.norm(hidden_states)\n\n        if output_hidden_states:\n            all_hidden_states = outputs[1] + (hidden_states,)\n            outputs = (hidden_states, all_hidden_states) + outputs[2:]\n        else:\n            outputs = (hidden_states,) + outputs[1:]\n\n        if not return_dict:\n            return tuple(v for v in outputs if v is not None)\n\n        return FlaxBaseModelOutput(\n            last_hidden_state=hidden_states,\n            hidden_states=outputs[1],\n            attentions=outputs[-1],\n        )\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaModule.__call__","title":"<code>__call__(input_ids, attention_mask, position_ids, deterministic=True, inputs_embeds=None, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True, extra_embedding=None)</code>","text":"<p>The call function is the main function of a Flax model. It takes in input_ids, attention_mask, and position_ids and returns the output of the model. The call function also has optional arguments that can be used to control the behavior of the model (e.g., deterministic=True). These optional arguments are passed as keyword arguments when calling a Flax model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass in the input token ids</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the padding tokens</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Indicate the position of each token in a sequence</p> required <code>deterministic</code> <code>bool</code> <p>bool: Control whether dropout is applied or not</p> <code>True</code> <code>inputs_embeds</code> <code>Array</code> <p>chex.Array: Pass in the embeddings of the input tokens</p> <code>None</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attentions or not</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Determine whether to return hidden states</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of the output or not</p> <code>True</code> <code>extra_embedding</code> <code>Optional[Union[ndarray, None]]</code> <p>Optional[Union[jnp.ndarray: Pass in the embedding of the</p> <code>None</code> <code>None]]</code> <p>Pass in the extra embedding</p> required <p>Returns:</p> Type Description <p>A tuple of:</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        deterministic: bool = True,\n        inputs_embeds: chex.Array = None,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n):\n    \"\"\"\n    The __call__ function is the main function of a Flax model. It takes in input_ids, attention_mask, and position_ids\n    and returns the output of the model. The __call__ function also has optional arguments that can be used to control\n    the behavior of the model (e.g., deterministic=True). These optional arguments are passed as keyword arguments when\n    calling a Flax model.\n\n    :param self: Represent the instance of the class\n    :param input_ids: chex.Array: Pass in the input token ids\n    :param attention_mask: chex.Array: Mask out the padding tokens\n    :param position_ids: chex.Array: Indicate the position of each token in a sequence\n    :param deterministic: bool: Control whether dropout is applied or not\n    :param inputs_embeds: chex.Array: Pass in the embeddings of the input tokens\n    :param init_cache: bool: Initialize the cache\n    :param output_attentions: bool: Determine whether to return the attentions or not\n    :param output_hidden_states: bool: Determine whether to return hidden states\n    :param return_dict: bool: Return a dictionary of the output or not\n    :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of the\n    :param None]]: Pass in the extra embedding\n    :return: A tuple of:\n\n    \"\"\"\n    if inputs_embeds is None:\n        inputs_embeds = self.embed_tokens(input_ids.astype(\"i4\"))\n\n    batch_size, sequence_length, _ = inputs_embeds.shape\n\n    assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n    inputs_embeds = inputs_embeds + \\\n                    extra_embedding if extra_embedding is not None else inputs_embeds\n    hidden_states = self.dropout(\n        inputs_embeds, deterministic=deterministic)\n\n    outputs = self.layers(\n        hidden_states=hidden_states,\n        freq_cis=self.freq_cis,\n        attention_mask=attention_mask,\n        position_ids=position_ids,\n        causal_mask=self.causal_mask,\n        deterministic=deterministic,\n        init_cache=init_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n\n    hidden_states = outputs[0]\n    hidden_states = self.norm(hidden_states)\n\n    if output_hidden_states:\n        all_hidden_states = outputs[1] + (hidden_states,)\n        outputs = (hidden_states, all_hidden_states) + outputs[2:]\n    else:\n        outputs = (hidden_states,) + outputs[1:]\n\n    if not return_dict:\n        return tuple(v for v in outputs if v is not None)\n\n    return FlaxBaseModelOutput(\n        last_hidden_state=hidden_states,\n        hidden_states=outputs[1],\n        attentions=outputs[-1],\n    )\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaPreTrainedModel","title":"<code>FlaxLlamaPreTrainedModel</code>","text":"<p>             Bases: <code>EasyDelFlaxPretrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>class FlaxLlamaPreTrainedModel(EasyDelFlaxPretrainedModel):\n    config_class = LlamaConfig\n    base_model_prefix = \"model\"\n    module_class: nn.Module = None\n\n    def __init__(\n            self,\n            config: LlamaConfig,\n            input_shape: Tuple = (1, 1),\n            seed: int = 0,\n            dtype: jnp.dtype = jnp.float32,\n            _do_init: bool = True,\n            **kwargs,\n    ):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the instance of the class, and defines what happens when it's created.\n        The __init__ function can take arguments, but self is always required (it refers to the instance of the object).\n\n\n        :param self: Refer to the object itself\n        :param config: LlamaConfig: Pass the configuration to the module\n        :param input_shape: Tuple: Specify the shape of the input to the model\n        :param seed: int: Set the seed for random number generation\n        :param dtype: jnp.dtype: Specify the data type of the input\n        :param _do_init: bool: Control whether the module is initialized or not\n        :param kwargs: Pass in any additional parameters that the module_class might need\n        :param : Specify the number of layers in the network\n        :return: The super() of the class\n\n        \"\"\"\n        module = self.module_class(config=config, dtype=dtype, **kwargs)\n        super().__init__(config, module, input_shape=input_shape,\n                         seed=seed, dtype=dtype, _do_init=_do_init)\n\n    def init_weights(self, rng: jax.random.PRNGKey, input_shape: Tuple, params: FrozenDict = None) -&gt; FrozenDict:\n        \"\"\"\n        The init_weights function is used to initialize the weights of a model.\n\n        :param self: Access variables that belong to the class\n        :param rng: jax.random.PRNGKey: Initialize the weights of the model\n        :param input_shape: Tuple: Specify the shape of the input tensor\n        :param params: FrozenDict: Pass in the parameters of a pre-trained model\n        :return: A frozendict of parameters\n\n        \"\"\"\n        input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(\n            jnp.atleast_2d(input_ids).shape[-1]), input_shape)\n        params_rng, dropout_rng = jax.random.split(rng)\n        rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n        if self.config.add_cross_attention:\n            encoder_hidden_states = jnp.zeros(\n                input_shape + (self.config.hidden_size,))\n            encoder_attention_mask = attention_mask\n            module_init_outputs = self.module.init(\n                rngs,\n                input_ids,\n                attention_mask,\n                position_ids,\n                encoder_hidden_states,\n                encoder_attention_mask,\n                return_dict=False,\n            )\n        else:\n            module_init_outputs = self.module.init(\n                rngs, input_ids, attention_mask, position_ids, return_dict=False)\n\n        random_params = module_init_outputs[\"params\"]\n\n        if params is not None:\n            random_params = flatten_dict(unfreeze(random_params))\n            params = flatten_dict(unfreeze(params))\n            for missing_key in self._missing_keys:\n                params[missing_key] = random_params[missing_key]\n            self._missing_keys = set()\n            return freeze(unflatten_dict(params))\n        else:\n            return random_params\n\n    def init_cache(self, batch_size, max_length):\n        \"\"\"\n        The init_cache function is used to initialize the cache for a given batch size and sequence length.\n        The cache is a dictionary that contains all the intermediate states from each layer in the model.\n        This allows us to run inference on multiple batches without having to re-run forward passes through every layer in\n        the model, which would be very slow.\n\n        :param self: Access the module\n        :param batch_size: Define the batch size of the input tensors\n        :param max_length: Set the length of the input sequence\n        :return: A dictionary with the following keys:\n\n        \"\"\"\n        input_ids = jnp.ones((batch_size, max_length))\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(\n            jnp.atleast_2d(input_ids).shape[-1]), input_ids.shape)\n\n        init_variables = self.module.init(\n            jax.random.PRNGKey(0), input_ids, attention_mask, position_ids, return_dict=False, init_cache=True\n        )\n        return init_variables[\"cache\"]\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array = None,\n            position_ids: chex.Array = None,\n            params: dict = None,\n            past_key_values: dict = None,\n            dropout_rng: jax.random.PRNGKey = None,\n            train: bool = False,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            return_dict: Optional[bool] = None,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None,\n            add_params_field: bool = False,\n            **kwargs\n    ):\n        \"\"\"\n        The __call__ function is the main function of a JAX module.\n        It takes in inputs and returns outputs, but it also has some other important features:\n        - It can take in mutable state (e.g., past_key_values) that will be updated during the call and returned at the end.\n        - It can take in random number generators (rngs) that are used to generate random numbers for dropout or sampling operations.\n\n        :param self: Represent the instance of the class\n        :param input_ids: chex.Array: Pass in the input tokens\n        :param attention_mask: chex.Array: Mask out certain tokens in the input\n        :param position_ids: chex.Array: Create the positional embeddings\n        :param params: dict: Pass in the parameters of the model\n        :param past_key_values: dict: Pass in the past key values from a previous call to __call__\n        :param dropout_rng: jax.random.PRNGKey: Make sure that the dropout is applied in a random way\n        :param train: bool: Determine whether to use dropout or not\n        :param output_attentions: Optional[bool]: Determine whether to return the attention weights\n        :param output_hidden_states: Optional[bool]: Return the hidden states of all layers\n        :param return_dict: Optional[bool]: Determine whether to return a dictionary or not\n        :param extra_embedding: Optional[Union[jnp.ndarray,None]]: Pass in the embedding for the input_ids\n        :param add_params_field: bool: Add the params field to the inputs dictionary\n        :return: A tuple of the following:\n\n        \"\"\"\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n        batch_size, sequence_length = input_ids.shape\n\n        assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n\n        if position_ids is None:\n            if past_key_values is not None:\n                raise ValueError(\n                    \"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n            position_ids = jnp.broadcast_to(jnp.arange(sequence_length)[\n                                            None, :], (batch_size, sequence_length))\n\n        if attention_mask is None:\n            attention_mask = jnp.ones((batch_size, sequence_length))\n\n        rngs = {}\n        if dropout_rng is not None:\n            rngs[\"dropout\"] = dropout_rng\n\n        if self.config.bits is not None:\n            rngs['params'] = jax.random.key(0)\n\n        inputs = {\n            \"params\": params or self.params\n        } if add_params_field else params or self.params\n\n        if past_key_values:\n            inputs[\"cache\"] = past_key_values\n            mutable = [\"cache\"]\n        else:\n            mutable = False\n\n        outputs = self.module.apply(\n            inputs,\n            jnp.array(input_ids, dtype=\"i4\"),\n            jnp.array(attention_mask, dtype=\"i4\"),\n            jnp.array(position_ids, dtype=\"i4\"),\n            not train,\n            False,\n            output_attentions,\n            output_hidden_states,\n            return_dict,\n            extra_embedding,\n            rngs=rngs,\n            mutable=mutable,\n        )\n\n        if past_key_values is not None and return_dict:\n            outputs, past_key_values = outputs\n            outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n            return outputs\n        elif past_key_values is not None and not return_dict:\n            outputs, past_key_values = outputs\n            outputs = outputs[:1] + \\\n                      (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n        return outputs\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaPreTrainedModel.__call__","title":"<code>__call__(input_ids, attention_mask=None, position_ids=None, params=None, past_key_values=None, dropout_rng=None, train=False, output_attentions=None, output_hidden_states=None, return_dict=None, extra_embedding=None, add_params_field=False, **kwargs)</code>","text":"<p>The call function is the main function of a JAX module. It takes in inputs and returns outputs, but it also has some other important features: - It can take in mutable state (e.g., past_key_values) that will be updated during the call and returned at the end. - It can take in random number generators (rngs) that are used to generate random numbers for dropout or sampling operations.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass in the input tokens</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out certain tokens in the input</p> <code>None</code> <code>position_ids</code> <code>Array</code> <p>chex.Array: Create the positional embeddings</p> <code>None</code> <code>params</code> <code>dict</code> <p>dict: Pass in the parameters of the model</p> <code>None</code> <code>past_key_values</code> <code>dict</code> <p>dict: Pass in the past key values from a previous call to call</p> <code>None</code> <code>dropout_rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Make sure that the dropout is applied in a random way</p> <code>None</code> <code>train</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>False</code> <code>output_attentions</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine whether to return the attention weights</p> <code>None</code> <code>output_hidden_states</code> <code>Optional[bool]</code> <p>Optional[bool]: Return the hidden states of all layers</p> <code>None</code> <code>return_dict</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine whether to return a dictionary or not</p> <code>None</code> <code>extra_embedding</code> <code>Optional[Union[ndarray, None]]</code> <p>Optional[Union[jnp.ndarray,None]]: Pass in the embedding for the input_ids</p> <code>None</code> <code>add_params_field</code> <code>bool</code> <p>bool: Add the params field to the inputs dictionary</p> <code>False</code> <p>Returns:</p> Type Description <p>A tuple of the following:</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array = None,\n        position_ids: chex.Array = None,\n        params: dict = None,\n        past_key_values: dict = None,\n        dropout_rng: jax.random.PRNGKey = None,\n        train: bool = False,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        extra_embedding: Optional[Union[jnp.ndarray, None]] = None,\n        add_params_field: bool = False,\n        **kwargs\n):\n    \"\"\"\n    The __call__ function is the main function of a JAX module.\n    It takes in inputs and returns outputs, but it also has some other important features:\n    - It can take in mutable state (e.g., past_key_values) that will be updated during the call and returned at the end.\n    - It can take in random number generators (rngs) that are used to generate random numbers for dropout or sampling operations.\n\n    :param self: Represent the instance of the class\n    :param input_ids: chex.Array: Pass in the input tokens\n    :param attention_mask: chex.Array: Mask out certain tokens in the input\n    :param position_ids: chex.Array: Create the positional embeddings\n    :param params: dict: Pass in the parameters of the model\n    :param past_key_values: dict: Pass in the past key values from a previous call to __call__\n    :param dropout_rng: jax.random.PRNGKey: Make sure that the dropout is applied in a random way\n    :param train: bool: Determine whether to use dropout or not\n    :param output_attentions: Optional[bool]: Determine whether to return the attention weights\n    :param output_hidden_states: Optional[bool]: Return the hidden states of all layers\n    :param return_dict: Optional[bool]: Determine whether to return a dictionary or not\n    :param extra_embedding: Optional[Union[jnp.ndarray,None]]: Pass in the embedding for the input_ids\n    :param add_params_field: bool: Add the params field to the inputs dictionary\n    :return: A tuple of the following:\n\n    \"\"\"\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n    batch_size, sequence_length = input_ids.shape\n\n    assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n\n    if position_ids is None:\n        if past_key_values is not None:\n            raise ValueError(\n                \"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n        position_ids = jnp.broadcast_to(jnp.arange(sequence_length)[\n                                        None, :], (batch_size, sequence_length))\n\n    if attention_mask is None:\n        attention_mask = jnp.ones((batch_size, sequence_length))\n\n    rngs = {}\n    if dropout_rng is not None:\n        rngs[\"dropout\"] = dropout_rng\n\n    if self.config.bits is not None:\n        rngs['params'] = jax.random.key(0)\n\n    inputs = {\n        \"params\": params or self.params\n    } if add_params_field else params or self.params\n\n    if past_key_values:\n        inputs[\"cache\"] = past_key_values\n        mutable = [\"cache\"]\n    else:\n        mutable = False\n\n    outputs = self.module.apply(\n        inputs,\n        jnp.array(input_ids, dtype=\"i4\"),\n        jnp.array(attention_mask, dtype=\"i4\"),\n        jnp.array(position_ids, dtype=\"i4\"),\n        not train,\n        False,\n        output_attentions,\n        output_hidden_states,\n        return_dict,\n        extra_embedding,\n        rngs=rngs,\n        mutable=mutable,\n    )\n\n    if past_key_values is not None and return_dict:\n        outputs, past_key_values = outputs\n        outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n        return outputs\n    elif past_key_values is not None and not return_dict:\n        outputs, past_key_values = outputs\n        outputs = outputs[:1] + \\\n                  (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n    return outputs\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaPreTrainedModel.__init__","title":"<code>__init__(config, input_shape=(1, 1), seed=0, dtype=jnp.float32, _do_init=True, **kwargs)</code>","text":"<p>The init function is called when the class is instantiated. It sets up the instance of the class, and defines what happens when it's created. The init function can take arguments, but self is always required (it refers to the instance of the object).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>config</code> <code>LlamaConfig</code> <p>LlamaConfig: Pass the configuration to the module</p> required <code>input_shape</code> <code>Tuple</code> <p>Tuple: Specify the shape of the input to the model</p> <code>(1, 1)</code> <code>seed</code> <code>int</code> <p>int: Set the seed for random number generation</p> <code>0</code> <code>dtype</code> <code>dtype</code> <p>jnp.dtype: Specify the data type of the input</p> <code>float32</code> <code>_do_init</code> <code>bool</code> <p>bool: Control whether the module is initialized or not</p> <code>True</code> <code>kwargs</code> <p>Pass in any additional parameters that the module_class might need</p> <code>{}</code> <code></code> <p>Specify the number of layers in the network</p> required <p>Returns:</p> Type Description <p>The super() of the class</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def __init__(\n        self,\n        config: LlamaConfig,\n        input_shape: Tuple = (1, 1),\n        seed: int = 0,\n        dtype: jnp.dtype = jnp.float32,\n        _do_init: bool = True,\n        **kwargs,\n):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up the instance of the class, and defines what happens when it's created.\n    The __init__ function can take arguments, but self is always required (it refers to the instance of the object).\n\n\n    :param self: Refer to the object itself\n    :param config: LlamaConfig: Pass the configuration to the module\n    :param input_shape: Tuple: Specify the shape of the input to the model\n    :param seed: int: Set the seed for random number generation\n    :param dtype: jnp.dtype: Specify the data type of the input\n    :param _do_init: bool: Control whether the module is initialized or not\n    :param kwargs: Pass in any additional parameters that the module_class might need\n    :param : Specify the number of layers in the network\n    :return: The super() of the class\n\n    \"\"\"\n    module = self.module_class(config=config, dtype=dtype, **kwargs)\n    super().__init__(config, module, input_shape=input_shape,\n                     seed=seed, dtype=dtype, _do_init=_do_init)\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaPreTrainedModel.init_cache","title":"<code>init_cache(batch_size, max_length)</code>","text":"<p>The init_cache function is used to initialize the cache for a given batch size and sequence length. The cache is a dictionary that contains all the intermediate states from each layer in the model. This allows us to run inference on multiple batches without having to re-run forward passes through every layer in the model, which would be very slow.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the module</p> required <code>batch_size</code> <p>Define the batch size of the input tensors</p> required <code>max_length</code> <p>Set the length of the input sequence</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys:</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def init_cache(self, batch_size, max_length):\n    \"\"\"\n    The init_cache function is used to initialize the cache for a given batch size and sequence length.\n    The cache is a dictionary that contains all the intermediate states from each layer in the model.\n    This allows us to run inference on multiple batches without having to re-run forward passes through every layer in\n    the model, which would be very slow.\n\n    :param self: Access the module\n    :param batch_size: Define the batch size of the input tensors\n    :param max_length: Set the length of the input sequence\n    :return: A dictionary with the following keys:\n\n    \"\"\"\n    input_ids = jnp.ones((batch_size, max_length))\n    attention_mask = jnp.ones_like(input_ids)\n    position_ids = jnp.broadcast_to(jnp.arange(\n        jnp.atleast_2d(input_ids).shape[-1]), input_ids.shape)\n\n    init_variables = self.module.init(\n        jax.random.PRNGKey(0), input_ids, attention_mask, position_ids, return_dict=False, init_cache=True\n    )\n    return init_variables[\"cache\"]\n</code></pre>"},{"location":"generated-modules-llama-modelling_llama_flax/#lib.python.EasyDel.modules.llama.modelling_llama_flax.FlaxLlamaPreTrainedModel.init_weights","title":"<code>init_weights(rng, input_shape, params=None)</code>","text":"<p>The init_weights function is used to initialize the weights of a model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Initialize the weights of the model</p> required <code>input_shape</code> <code>Tuple</code> <p>Tuple: Specify the shape of the input tensor</p> required <code>params</code> <code>FrozenDict</code> <p>FrozenDict: Pass in the parameters of a pre-trained model</p> <code>None</code> <p>Returns:</p> Type Description <code>FrozenDict</code> <p>A frozendict of parameters</p> Source code in <code>lib/python/EasyDel/modules/llama/modelling_llama_flax.py</code> <pre><code>def init_weights(self, rng: jax.random.PRNGKey, input_shape: Tuple, params: FrozenDict = None) -&gt; FrozenDict:\n    \"\"\"\n    The init_weights function is used to initialize the weights of a model.\n\n    :param self: Access variables that belong to the class\n    :param rng: jax.random.PRNGKey: Initialize the weights of the model\n    :param input_shape: Tuple: Specify the shape of the input tensor\n    :param params: FrozenDict: Pass in the parameters of a pre-trained model\n    :return: A frozendict of parameters\n\n    \"\"\"\n    input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n    attention_mask = jnp.ones_like(input_ids)\n    position_ids = jnp.broadcast_to(jnp.arange(\n        jnp.atleast_2d(input_ids).shape[-1]), input_shape)\n    params_rng, dropout_rng = jax.random.split(rng)\n    rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n    if self.config.add_cross_attention:\n        encoder_hidden_states = jnp.zeros(\n            input_shape + (self.config.hidden_size,))\n        encoder_attention_mask = attention_mask\n        module_init_outputs = self.module.init(\n            rngs,\n            input_ids,\n            attention_mask,\n            position_ids,\n            encoder_hidden_states,\n            encoder_attention_mask,\n            return_dict=False,\n        )\n    else:\n        module_init_outputs = self.module.init(\n            rngs, input_ids, attention_mask, position_ids, return_dict=False)\n\n    random_params = module_init_outputs[\"params\"]\n\n    if params is not None:\n        random_params = flatten_dict(unfreeze(random_params))\n        params = flatten_dict(unfreeze(params))\n        for missing_key in self._missing_keys:\n            params[missing_key] = random_params[missing_key]\n        self._missing_keys = set()\n        return freeze(unflatten_dict(params))\n    else:\n        return random_params\n</code></pre>"},{"location":"generated-modules-lucid_transformer-lt_configuration/","title":"modules.lucid_transformer.lt_configuration","text":""},{"location":"generated-modules-lucid_transformer-modelling_lt_flax/","title":"modules.lucid_transformer.modelling_lt_flax","text":""},{"location":"generated-modules-mamba-mamba_configuration/","title":"modules.mamba.mamba_configuration","text":""},{"location":"generated-modules-mamba-modelling_mamba_flax/","title":"modules.mamba.modelling_mamba_flax","text":""},{"location":"generated-modules-mistral-mistral_configuration/","title":"modules.mistral.mistral_configuration","text":""},{"location":"generated-modules-mistral-mistral_configuration/#lib.python.EasyDel.modules.mistral.mistral_configuration.MistralConfig","title":"<code>MistralConfig</code>","text":"<p>             Bases: <code>EasyDelPretrainedConfig</code></p> Source code in <code>lib/python/EasyDel/modules/mistral/mistral_configuration.py</code> <pre><code>class MistralConfig(EasyDelPretrainedConfig):\n    model_type = \"mistral\"\n    def __init__(\n            self,\n            vocab_size=32000,\n            hidden_size=4096,\n            intermediate_size=14336,\n            num_hidden_layers=32,\n            num_attention_heads=32,\n            num_key_value_heads=8,\n            hidden_act=\"silu\",\n            max_position_embeddings=4096 * 32,\n            initializer_range=0.02,\n            rms_norm_eps=1e-6,\n            use_cache=True,\n            pad_token_id=None,\n            bos_token_id=1,\n            eos_token_id=2,\n            tie_word_embeddings=False,\n            rope_theta=10000.0,\n            rope_scaling: Dict[str, Union[str, float]] = None,\n            sliding_window=4096,\n            gradient_checkpointing: str = 'nothing_saveable',\n            use_pjit_attention_force: bool = False,\n            use_sacn_mlp: bool = False,\n            scan_mlp_chunk_size: int = 1024,\n            number_rep_kv: int = 1,\n            attention_dropout: float = 0.0,\n            c_max_position_embeddings: int = 4096,\n            freq_max_position_embeddings: int = 4096,\n            bits: Optional[int] = None,\n            attention_bias: bool = False,\n            **kwargs,\n    ):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It allows the class to initialize the attributes of a class.\n        The self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\n        :param self: Represent the instance of the class\n        :param vocab_size: Define the size of the vocabulary\n        :param hidden_size: Determine the size of the embedding layers\n        :param intermediate_size: Define the size of the intermediate layer in each transformer block\n        :param num_hidden_layers: Determine the number of layers in the encoder and decoder\n        :param num_attention_heads: Determine the number of attention heads in each layer\n        :param num_key_value_heads: Specify the number of heads for key and value\n        :param hidden_act: Specify the activation function used in the hidden layers\n        :param max_position_embeddings: Set the maximum length of the sequence\n        :param initializer_range: Initialize the weights of the model\n        :param rms_norm_eps: Avoid division by zero in the rms normalization\n        :param use_cache: Determine whether to use the cache in the decoder\n        :param pad_token_id: Specify the token id of the padding token\n        :param bos_token_id: Specify the beginning of sentence token id\n        :param eos_token_id: Specify the end of sentence token\n        :param tie_word_embeddings: Tie the word embeddings and the output layer\n        :param rope_theta: Control the number of tokens in a rope\n        :param sliding_window: Control the number of tokens that are processed in parallel\n        :param gradient_checkpointing: str: Specify whether to use gradient checkpointing\n        :param use_pjit_attention_force: bool: Force the use of pjit attention\n        :param use_sacn_mlp: bool: Determine whether or not to use the scan_mlp function\n        :param scan_mlp_chunk_size: int: Specify the chunk size of the scan mlp\n        :param number_rep_kv: int: Specify the number of times to repeat the key and value vectors\n        :param attention_dropout: float: Set the dropout rate for the attention layer\n        :param c_max_position_embeddings: int: Set the maximum number of tokens in a sequence\n        :param freq_max_position_embeddings: int: Set the maximum number of frequency bins that can be used in the model\n        :param bits: Optional[int]: Specify the number of bits used for quantization\n        :param axis_dims: Sequence[int]: Specify the dimension of each axis\n        :param axis_names: Sequence[str]: Specify the names of each axis in the tensor\n        :param &amp;quot;mp&amp;quot;): Define the maximum position embeddings\n        :param attention_bias: bool: when ever to use attention_bias\n        :param kwargs: Pass a variable number of keyword arguments to a function\n        :param : Define the number of layers in the model\n        :return: An instance of the class\n\n        \"\"\"\n        self.vocab_size = vocab_size\n        self.max_position_embeddings = max_position_embeddings\n        self.hidden_size = hidden_size\n        self.intermediate_size = intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.sliding_window = sliding_window\n        self.bits = bits\n        # for backward compatibility\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n\n        self.num_key_value_heads = num_key_value_heads\n        self.hidden_act = hidden_act\n        self.initializer_range = initializer_range\n        self.rms_norm_eps = rms_norm_eps\n        self.use_cache = use_cache\n        self.rope_theta = rope_theta\n        self.rope_scaling = rope_scaling\n        self.number_rep_kv = number_rep_kv\n        self.gradient_checkpointing = gradient_checkpointing\n        self.use_pjit_attention_force = use_pjit_attention_force\n        self.use_sacn_mlp = use_sacn_mlp\n        self.scan_mlp_chunk_size = scan_mlp_chunk_size\n        self.attention_bias = attention_bias\n        self.attention_dropout = attention_dropout\n        self.c_max_position_embeddings = c_max_position_embeddings\n        self.freq_max_position_embeddings = freq_max_position_embeddings\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs,\n        )\n\n    @staticmethod\n    def get_partition_rules(fully_sharded_data_parallel: bool = True):\n        \"\"\"\n        The get_partition_rules function is used to define the partitioning scheme for a model.\n        It returns a list of tuples, where each tuple contains two elements:\n          1) A regex string that matches the name of one or more parameters in the model.\n          2) A PartitionScheme object that defines how those parameters should be partitioned.\n\n        :param fully_sharded_data_parallel: bool: Determine whether to use the fully_sharded_data_parallel partitioning scheme or not\n        :return: A list of tuples\n\n        \"\"\"\n        return (\n\n            (\"model/embed_tokens/embedding\", PartitionSpec(\"dp\", \"fsdp\")),\n\n            (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec(\"fsdp\", \"dp\")),\n            (\"self_attn/o_proj/kernel\", PartitionSpec(\"dp\", \"fsdp\")),\n\n            (\"mlp/gate_proj/kernel\", PartitionSpec(\"fsdp\", \"dp\")),\n            (\"mlp/down_proj/kernel\", PartitionSpec(\"dp\", \"fsdp\")),\n            (\"mlp/up_proj/kernel\", PartitionSpec(\"fsdp\", \"dp\")),\n\n            (\"input_layernorm/kernel\", PartitionSpec(None)),\n            (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n            (\"model/norm/kernel\", PartitionSpec(None)),\n            (\"lm_head/kernel\", PartitionSpec(\"fsdp\", \"dp\")),\n            (\".*\", PartitionSpec(None)),\n        ) if not fully_sharded_data_parallel else (\n            (\"model/embed_tokens/embedding\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"self_attn/o_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/down_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"input_layernorm/kernel\", PartitionSpec(None)),\n            (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n            (\"model/norm/kernel\", PartitionSpec(None)),\n            (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\".*\", PartitionSpec((\"fsdp\", \"sp\"))),\n        )\n\n    def add_jax_args(\n            self,\n            gradient_checkpointing: str = 'nothing_saveable',\n            use_pjit_attention_force: bool = False,\n            use_sacn_mlp: bool = False,\n            scan_mlp_chunk_size: int = 1024,\n            number_rep_kv: int = 1,\n            c_max_position_embeddings: int = 4096,\n            freq_max_position_embeddings: int = None,\n            bits: Optional[int] = None,\n            attention_dropout: float = 0.0,\n            rope_scaling: Dict[str, Union[str, float]] = None,\n            attention_bias: bool = False,\n            **kwargs,\n    ):\n        \"\"\"\n        The add_jax_args function adds the following arguments to the model:\n\n        :param self: Bind the attributes and methods of a class to an instance of that class\n        :param gradient_checkpointing: str: Determine whether to use gradient checkpointing\n        :param use_pjit_attention_force: bool: Determine whether to use the pjit_attention_force function\n        :param use_sacn_mlp: bool: Determine whether to use the scan_mlp function or notn\n        :param scan_mlp_chunk_size: int: Chunk the input to the mlp\n        :param number_rep_kv: int: Control the number of times that the key and value vectors are repeated\n        :param c_max_position_embeddings: int: Set the maximum number of positional embeddings for the causal axis\n        :param freq_max_position_embeddings: int: Set the maximum length of the frequency axis\n        :param bits: Optional[int]: Specify the number of bits to use for quantization\n        :param attention_dropout: float: Set the dropout rate for the attention layer\n        :param attention_bias: bool: when ever to use attention_bias\n        :param rope_scaling: Dict[str, Union[str, float]]: rope_scaling for rope\n        :return: A tuple of the following:\n\n        \"\"\"\n\n        self.attention_bias = attention_bias\n        self.rope_scaling = rope_scaling\n        self.number_rep_kv = number_rep_kv\n        self.gradient_checkpointing = gradient_checkpointing\n        self.use_pjit_attention_force = use_pjit_attention_force\n        self.use_sacn_mlp = use_sacn_mlp\n        self.scan_mlp_chunk_size = scan_mlp_chunk_size\n        self.attention_dropout = attention_dropout\n        self.c_max_position_embeddings = c_max_position_embeddings\n        self.freq_max_position_embeddings = freq_max_position_embeddings\n        self.bits = bits\n\n    @staticmethod\n    def get_weight_decay_exclusions():\n        return tuple()\n\n    @staticmethod\n    def rng_keys():\n        return 'params', 'dropout', 'fcm'\n</code></pre>"},{"location":"generated-modules-mistral-mistral_configuration/#lib.python.EasyDel.modules.mistral.mistral_configuration.MistralConfig.__init__","title":"<code>__init__(vocab_size=32000, hidden_size=4096, intermediate_size=14336, num_hidden_layers=32, num_attention_heads=32, num_key_value_heads=8, hidden_act='silu', max_position_embeddings=4096 * 32, initializer_range=0.02, rms_norm_eps=1e-06, use_cache=True, pad_token_id=None, bos_token_id=1, eos_token_id=2, tie_word_embeddings=False, rope_theta=10000.0, rope_scaling=None, sliding_window=4096, gradient_checkpointing='nothing_saveable', use_pjit_attention_force=False, use_sacn_mlp=False, scan_mlp_chunk_size=1024, number_rep_kv=1, attention_dropout=0.0, c_max_position_embeddings=4096, freq_max_position_embeddings=4096, bits=None, attention_bias=False, **kwargs)</code>","text":"<p>The init function is called when the class is instantiated. It allows the class to initialize the attributes of a class. The self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>vocab_size</code> <p>Define the size of the vocabulary</p> <code>32000</code> <code>hidden_size</code> <p>Determine the size of the embedding layers</p> <code>4096</code> <code>intermediate_size</code> <p>Define the size of the intermediate layer in each transformer block</p> <code>14336</code> <code>num_hidden_layers</code> <p>Determine the number of layers in the encoder and decoder</p> <code>32</code> <code>num_attention_heads</code> <p>Determine the number of attention heads in each layer</p> <code>32</code> <code>num_key_value_heads</code> <p>Specify the number of heads for key and value</p> <code>8</code> <code>hidden_act</code> <p>Specify the activation function used in the hidden layers</p> <code>'silu'</code> <code>max_position_embeddings</code> <p>Set the maximum length of the sequence</p> <code>4096 * 32</code> <code>initializer_range</code> <p>Initialize the weights of the model</p> <code>0.02</code> <code>rms_norm_eps</code> <p>Avoid division by zero in the rms normalization</p> <code>1e-06</code> <code>use_cache</code> <p>Determine whether to use the cache in the decoder</p> <code>True</code> <code>pad_token_id</code> <p>Specify the token id of the padding token</p> <code>None</code> <code>bos_token_id</code> <p>Specify the beginning of sentence token id</p> <code>1</code> <code>eos_token_id</code> <p>Specify the end of sentence token</p> <code>2</code> <code>tie_word_embeddings</code> <p>Tie the word embeddings and the output layer</p> <code>False</code> <code>rope_theta</code> <p>Control the number of tokens in a rope</p> <code>10000.0</code> <code>sliding_window</code> <p>Control the number of tokens that are processed in parallel</p> <code>4096</code> <code>gradient_checkpointing</code> <code>str</code> <p>str: Specify whether to use gradient checkpointing</p> <code>'nothing_saveable'</code> <code>use_pjit_attention_force</code> <code>bool</code> <p>bool: Force the use of pjit attention</p> <code>False</code> <code>use_sacn_mlp</code> <code>bool</code> <p>bool: Determine whether or not to use the scan_mlp function</p> <code>False</code> <code>scan_mlp_chunk_size</code> <code>int</code> <p>int: Specify the chunk size of the scan mlp</p> <code>1024</code> <code>number_rep_kv</code> <code>int</code> <p>int: Specify the number of times to repeat the key and value vectors</p> <code>1</code> <code>attention_dropout</code> <code>float</code> <p>float: Set the dropout rate for the attention layer</p> <code>0.0</code> <code>c_max_position_embeddings</code> <code>int</code> <p>int: Set the maximum number of tokens in a sequence</p> <code>4096</code> <code>freq_max_position_embeddings</code> <code>int</code> <p>int: Set the maximum number of frequency bins that can be used in the model</p> <code>4096</code> <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Specify the number of bits used for quantization</p> <code>None</code> <code>axis_dims</code> <p>Sequence[int]: Specify the dimension of each axis</p> required <code>axis_names</code> <p>Sequence[str]: Specify the names of each axis in the tensor</p> required <code>&amp;quot;mp&amp;quot;)</code> <p>Define the maximum position embeddings</p> required <code>attention_bias</code> <code>bool</code> <p>bool: when ever to use attention_bias</p> <code>False</code> <code>kwargs</code> <p>Pass a variable number of keyword arguments to a function</p> <code>{}</code> <code></code> <p>Define the number of layers in the model</p> required <p>Returns:</p> Type Description <p>An instance of the class</p> Source code in <code>lib/python/EasyDel/modules/mistral/mistral_configuration.py</code> <pre><code>def __init__(\n        self,\n        vocab_size=32000,\n        hidden_size=4096,\n        intermediate_size=14336,\n        num_hidden_layers=32,\n        num_attention_heads=32,\n        num_key_value_heads=8,\n        hidden_act=\"silu\",\n        max_position_embeddings=4096 * 32,\n        initializer_range=0.02,\n        rms_norm_eps=1e-6,\n        use_cache=True,\n        pad_token_id=None,\n        bos_token_id=1,\n        eos_token_id=2,\n        tie_word_embeddings=False,\n        rope_theta=10000.0,\n        rope_scaling: Dict[str, Union[str, float]] = None,\n        sliding_window=4096,\n        gradient_checkpointing: str = 'nothing_saveable',\n        use_pjit_attention_force: bool = False,\n        use_sacn_mlp: bool = False,\n        scan_mlp_chunk_size: int = 1024,\n        number_rep_kv: int = 1,\n        attention_dropout: float = 0.0,\n        c_max_position_embeddings: int = 4096,\n        freq_max_position_embeddings: int = 4096,\n        bits: Optional[int] = None,\n        attention_bias: bool = False,\n        **kwargs,\n):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It allows the class to initialize the attributes of a class.\n    The self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\n    :param self: Represent the instance of the class\n    :param vocab_size: Define the size of the vocabulary\n    :param hidden_size: Determine the size of the embedding layers\n    :param intermediate_size: Define the size of the intermediate layer in each transformer block\n    :param num_hidden_layers: Determine the number of layers in the encoder and decoder\n    :param num_attention_heads: Determine the number of attention heads in each layer\n    :param num_key_value_heads: Specify the number of heads for key and value\n    :param hidden_act: Specify the activation function used in the hidden layers\n    :param max_position_embeddings: Set the maximum length of the sequence\n    :param initializer_range: Initialize the weights of the model\n    :param rms_norm_eps: Avoid division by zero in the rms normalization\n    :param use_cache: Determine whether to use the cache in the decoder\n    :param pad_token_id: Specify the token id of the padding token\n    :param bos_token_id: Specify the beginning of sentence token id\n    :param eos_token_id: Specify the end of sentence token\n    :param tie_word_embeddings: Tie the word embeddings and the output layer\n    :param rope_theta: Control the number of tokens in a rope\n    :param sliding_window: Control the number of tokens that are processed in parallel\n    :param gradient_checkpointing: str: Specify whether to use gradient checkpointing\n    :param use_pjit_attention_force: bool: Force the use of pjit attention\n    :param use_sacn_mlp: bool: Determine whether or not to use the scan_mlp function\n    :param scan_mlp_chunk_size: int: Specify the chunk size of the scan mlp\n    :param number_rep_kv: int: Specify the number of times to repeat the key and value vectors\n    :param attention_dropout: float: Set the dropout rate for the attention layer\n    :param c_max_position_embeddings: int: Set the maximum number of tokens in a sequence\n    :param freq_max_position_embeddings: int: Set the maximum number of frequency bins that can be used in the model\n    :param bits: Optional[int]: Specify the number of bits used for quantization\n    :param axis_dims: Sequence[int]: Specify the dimension of each axis\n    :param axis_names: Sequence[str]: Specify the names of each axis in the tensor\n    :param &amp;quot;mp&amp;quot;): Define the maximum position embeddings\n    :param attention_bias: bool: when ever to use attention_bias\n    :param kwargs: Pass a variable number of keyword arguments to a function\n    :param : Define the number of layers in the model\n    :return: An instance of the class\n\n    \"\"\"\n    self.vocab_size = vocab_size\n    self.max_position_embeddings = max_position_embeddings\n    self.hidden_size = hidden_size\n    self.intermediate_size = intermediate_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.sliding_window = sliding_window\n    self.bits = bits\n    # for backward compatibility\n    if num_key_value_heads is None:\n        num_key_value_heads = num_attention_heads\n\n    self.num_key_value_heads = num_key_value_heads\n    self.hidden_act = hidden_act\n    self.initializer_range = initializer_range\n    self.rms_norm_eps = rms_norm_eps\n    self.use_cache = use_cache\n    self.rope_theta = rope_theta\n    self.rope_scaling = rope_scaling\n    self.number_rep_kv = number_rep_kv\n    self.gradient_checkpointing = gradient_checkpointing\n    self.use_pjit_attention_force = use_pjit_attention_force\n    self.use_sacn_mlp = use_sacn_mlp\n    self.scan_mlp_chunk_size = scan_mlp_chunk_size\n    self.attention_bias = attention_bias\n    self.attention_dropout = attention_dropout\n    self.c_max_position_embeddings = c_max_position_embeddings\n    self.freq_max_position_embeddings = freq_max_position_embeddings\n\n    super().__init__(\n        pad_token_id=pad_token_id,\n        bos_token_id=bos_token_id,\n        eos_token_id=eos_token_id,\n        tie_word_embeddings=tie_word_embeddings,\n        **kwargs,\n    )\n</code></pre>"},{"location":"generated-modules-mistral-mistral_configuration/#lib.python.EasyDel.modules.mistral.mistral_configuration.MistralConfig.add_jax_args","title":"<code>add_jax_args(gradient_checkpointing='nothing_saveable', use_pjit_attention_force=False, use_sacn_mlp=False, scan_mlp_chunk_size=1024, number_rep_kv=1, c_max_position_embeddings=4096, freq_max_position_embeddings=None, bits=None, attention_dropout=0.0, rope_scaling=None, attention_bias=False, **kwargs)</code>","text":"<p>The add_jax_args function adds the following arguments to the model:</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Bind the attributes and methods of a class to an instance of that class</p> required <code>gradient_checkpointing</code> <code>str</code> <p>str: Determine whether to use gradient checkpointing</p> <code>'nothing_saveable'</code> <code>use_pjit_attention_force</code> <code>bool</code> <p>bool: Determine whether to use the pjit_attention_force function</p> <code>False</code> <code>use_sacn_mlp</code> <code>bool</code> <p>bool: Determine whether to use the scan_mlp function or notn</p> <code>False</code> <code>scan_mlp_chunk_size</code> <code>int</code> <p>int: Chunk the input to the mlp</p> <code>1024</code> <code>number_rep_kv</code> <code>int</code> <p>int: Control the number of times that the key and value vectors are repeated</p> <code>1</code> <code>c_max_position_embeddings</code> <code>int</code> <p>int: Set the maximum number of positional embeddings for the causal axis</p> <code>4096</code> <code>freq_max_position_embeddings</code> <code>int</code> <p>int: Set the maximum length of the frequency axis</p> <code>None</code> <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Specify the number of bits to use for quantization</p> <code>None</code> <code>attention_dropout</code> <code>float</code> <p>float: Set the dropout rate for the attention layer</p> <code>0.0</code> <code>attention_bias</code> <code>bool</code> <p>bool: when ever to use attention_bias</p> <code>False</code> <code>rope_scaling</code> <code>Dict[str, Union[str, float]]</code> <p>Dict[str, Union[str, float]]: rope_scaling for rope</p> <code>None</code> <p>Returns:</p> Type Description <p>A tuple of the following:</p> Source code in <code>lib/python/EasyDel/modules/mistral/mistral_configuration.py</code> <pre><code>def add_jax_args(\n        self,\n        gradient_checkpointing: str = 'nothing_saveable',\n        use_pjit_attention_force: bool = False,\n        use_sacn_mlp: bool = False,\n        scan_mlp_chunk_size: int = 1024,\n        number_rep_kv: int = 1,\n        c_max_position_embeddings: int = 4096,\n        freq_max_position_embeddings: int = None,\n        bits: Optional[int] = None,\n        attention_dropout: float = 0.0,\n        rope_scaling: Dict[str, Union[str, float]] = None,\n        attention_bias: bool = False,\n        **kwargs,\n):\n    \"\"\"\n    The add_jax_args function adds the following arguments to the model:\n\n    :param self: Bind the attributes and methods of a class to an instance of that class\n    :param gradient_checkpointing: str: Determine whether to use gradient checkpointing\n    :param use_pjit_attention_force: bool: Determine whether to use the pjit_attention_force function\n    :param use_sacn_mlp: bool: Determine whether to use the scan_mlp function or notn\n    :param scan_mlp_chunk_size: int: Chunk the input to the mlp\n    :param number_rep_kv: int: Control the number of times that the key and value vectors are repeated\n    :param c_max_position_embeddings: int: Set the maximum number of positional embeddings for the causal axis\n    :param freq_max_position_embeddings: int: Set the maximum length of the frequency axis\n    :param bits: Optional[int]: Specify the number of bits to use for quantization\n    :param attention_dropout: float: Set the dropout rate for the attention layer\n    :param attention_bias: bool: when ever to use attention_bias\n    :param rope_scaling: Dict[str, Union[str, float]]: rope_scaling for rope\n    :return: A tuple of the following:\n\n    \"\"\"\n\n    self.attention_bias = attention_bias\n    self.rope_scaling = rope_scaling\n    self.number_rep_kv = number_rep_kv\n    self.gradient_checkpointing = gradient_checkpointing\n    self.use_pjit_attention_force = use_pjit_attention_force\n    self.use_sacn_mlp = use_sacn_mlp\n    self.scan_mlp_chunk_size = scan_mlp_chunk_size\n    self.attention_dropout = attention_dropout\n    self.c_max_position_embeddings = c_max_position_embeddings\n    self.freq_max_position_embeddings = freq_max_position_embeddings\n    self.bits = bits\n</code></pre>"},{"location":"generated-modules-mistral-mistral_configuration/#lib.python.EasyDel.modules.mistral.mistral_configuration.MistralConfig.get_partition_rules","title":"<code>get_partition_rules(fully_sharded_data_parallel=True)</code>  <code>staticmethod</code>","text":"<p>The get_partition_rules function is used to define the partitioning scheme for a model. It returns a list of tuples, where each tuple contains two elements:   1) A regex string that matches the name of one or more parameters in the model.   2) A PartitionScheme object that defines how those parameters should be partitioned.</p> <p>Parameters:</p> Name Type Description Default <code>fully_sharded_data_parallel</code> <code>bool</code> <p>bool: Determine whether to use the fully_sharded_data_parallel partitioning scheme or not</p> <code>True</code> <p>Returns:</p> Type Description <p>A list of tuples</p> Source code in <code>lib/python/EasyDel/modules/mistral/mistral_configuration.py</code> <pre><code>@staticmethod\ndef get_partition_rules(fully_sharded_data_parallel: bool = True):\n    \"\"\"\n    The get_partition_rules function is used to define the partitioning scheme for a model.\n    It returns a list of tuples, where each tuple contains two elements:\n      1) A regex string that matches the name of one or more parameters in the model.\n      2) A PartitionScheme object that defines how those parameters should be partitioned.\n\n    :param fully_sharded_data_parallel: bool: Determine whether to use the fully_sharded_data_parallel partitioning scheme or not\n    :return: A list of tuples\n\n    \"\"\"\n    return (\n\n        (\"model/embed_tokens/embedding\", PartitionSpec(\"dp\", \"fsdp\")),\n\n        (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec(\"fsdp\", \"dp\")),\n        (\"self_attn/o_proj/kernel\", PartitionSpec(\"dp\", \"fsdp\")),\n\n        (\"mlp/gate_proj/kernel\", PartitionSpec(\"fsdp\", \"dp\")),\n        (\"mlp/down_proj/kernel\", PartitionSpec(\"dp\", \"fsdp\")),\n        (\"mlp/up_proj/kernel\", PartitionSpec(\"fsdp\", \"dp\")),\n\n        (\"input_layernorm/kernel\", PartitionSpec(None)),\n        (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n        (\"model/norm/kernel\", PartitionSpec(None)),\n        (\"lm_head/kernel\", PartitionSpec(\"fsdp\", \"dp\")),\n        (\".*\", PartitionSpec(None)),\n    ) if not fully_sharded_data_parallel else (\n        (\"model/embed_tokens/embedding\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"self_attn/o_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/down_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"input_layernorm/kernel\", PartitionSpec(None)),\n        (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n        (\"model/norm/kernel\", PartitionSpec(None)),\n        (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\".*\", PartitionSpec((\"fsdp\", \"sp\"))),\n    )\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/","title":"modules.mistral.modelling_mistral_flax","text":""},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralAttention","title":"<code>FlaxMistralAttention</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>class FlaxMistralAttention(nn.Module):\n    config: MistralConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        config = self.config\n        self.hidden_size = config.hidden_size\n        self.head_dim = self.config.hidden_size // self.config.num_attention_heads\n        self.num_key_value_groups = self.config.num_attention_heads // self.config.num_key_value_heads\n\n        if self.num_key_value_groups == 1:\n            assert self.config.num_attention_heads == self.config.num_key_value_heads\n        self.q_proj = nn.Dense(\n            config.num_attention_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=self.config.attention_bias,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.k_proj = nn.Dense(\n            config.num_key_value_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=self.config.attention_bias,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.v_proj = nn.Dense(\n            config.num_key_value_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=self.config.attention_bias,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.o_proj = nn.Dense(\n            config.hidden_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n\n        self.rotary = FlaxMistralRotaryEmbedding(self.dtype)\n        self.attention_performer = EasyAttention(\n            attn_type=\"normal\",\n            block_k_major=self.config.block_k_major,\n            block_b=self.config.block_b,\n            block_q=self.config.block_q,\n            block_k=self.config.block_k,\n            block_q_major_dkv=self.config.block_q_major_dkv,\n            block_k_major_dkv=self.config.block_k_major_dkv,\n            block_k_major_dq=self.config.block_k_major_dq,\n            block_k_dkv=self.config.block_k_dkv,\n            block_q_dkv=self.config.block_q_dkv,\n            block_q_dq=self.config.block_q_dq,\n            block_k_dq=self.config.block_k_dq,\n            num_attention_heads=self.config.num_attention_heads,\n            attention_dropout=self.config.attention_dropout,\n            head_dims=self.head_dim,\n            attention_partition_spec=self.config.attention_partition_spec,\n            use_shard_map=self.config.use_shard_map,\n            precision=self.precision,\n            force_float32_tpu=True,\n            attn_mechanism=self.config.attn_mechanism,\n            dtype=self.dtype,\n            bias_partition_spec=self.config.bias_partition_spec,\n            key_partition_spec=self.config.key_partition_spec,\n            query_partition_spec=self.config.query_partition_spec,\n            value_partition_spec=self.config.value_partition_spec,\n            mesh=self.config.jax_mesh(),\n            sm_scale=1 / math.sqrt(self.head_dim)\n        )\n\n    def _merge_heads(self, hidden_states):\n        return hidden_states.reshape(hidden_states.shape[:2] + (self.hidden_size,))\n\n    @nn.compact\n    def _concatenate_to_cache(self, key, value, query, attention_mask):\n        \"\"\"\n        The _concatenate_to_cache function is used to concatenate the key and value vectors\n        of a query with those of previous queries. This allows for the attention mechanism to\n        look at all previous queries when computing its output. The function takes in three\n        arguments: key, value, and query. It also uses two variables that are stored in the cache:\n        cached_key and cached_value.\n\n        :param self: Access the variables stored in the cache\n        :param key: Store the keys of the encoder-decoder attention\n        :param value: Initialize the cached_value variable\n        :param query: Determine the number of cache vectors to update\n        :param attention_mask: Mask out the padded vectors in the cache\n        :return: The key, value and attention_mask\n\n        \"\"\"\n        is_initialized = self.has_variable(\"cache\", \"cached_key\")\n        cached_key = self.variable(\n            \"cache\", \"cached_key\", jnp.zeros, key.shape, key.dtype)\n        cached_value = self.variable(\n            \"cache\", \"cached_value\", jnp.zeros, value.shape, value.dtype)\n        cache_index = self.variable(\n            \"cache\", \"cache_index\", lambda: jnp.array(0, dtype=jnp.int32))\n\n        if is_initialized:\n            *batch_dims, max_length, num_heads, depth_per_head = cached_key.value.shape\n            cur_index = cache_index.value\n            indices = (0,) * len(batch_dims) + (cur_index, 0, 0)\n            key = lax.dynamic_update_slice(cached_key.value, key, indices)\n            value = lax.dynamic_update_slice(\n                cached_value.value, value, indices)\n            cached_key.value = key\n            cached_value.value = value\n            num_updated_cache_vectors = query.shape[1]\n            cache_index.value = cache_index.value + num_updated_cache_vectors\n\n            pad_mask = jnp.broadcast_to(\n                jnp.arange(max_length) &lt; cur_index + num_updated_cache_vectors,\n                tuple(batch_dims) + (1, num_updated_cache_vectors, max_length),\n            )\n            attention_mask = combine_masks(pad_mask, attention_mask)\n        return key, value, attention_mask\n\n    @staticmethod\n    def _t(query, key, value):\n        \"\"\"\n        The _t function transposes the query, key and value matrices.\n\n        :param query: Get the attention weights for each of the heads\n        :param key: Determine the number of heads\n        :param value: Store the values of the input\n        :return: The transpose of the query, key and value matrices\n\n        \"\"\"\n        return jnp.transpose(query, (0, 2, 1, 3)), jnp.transpose(key, (0, 2, 1, 3)), jnp.transpose(value, (0, 2, 1, 3))\n\n    def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n        \"\"\"\n        The apply_rotary function is a modified version of the apply_attention function in the BertModel class.\n        The main difference is that it takes in an additional argument, freq_cis, which are used to calculate\n        the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.\n\n        :param self: Access variables that belong to the class\n        :param batch_size: Reshape the query, key and value tensors\n        :param sequence_length: Reshape the query, key and value tensors\n        :param query: Calculate the attention weights\n        :param key: Calculate the attention\n        :param value: Compute the attention weights\n        :param freq_cis: Calculate the frequency of each word in the vocabulary\n        :param position_ids: Identify the position of each token in the sequence\n        :return: A tuple of 3 tensors: query, key and value\n\n        \"\"\"\n        query = query.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_attention_heads,\n            self.head_dim\n        )\n        key = key.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_key_value_heads,\n            self.head_dim\n        )\n        value = value.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_key_value_heads,\n            self.head_dim\n        )\n\n        query, key, value = self._t(query, key, value)\n        query, key = self.rotary(\n            position_ids=position_ids, query=query, key=key, freq_cis=freq_cis\n        )\n        key = repeat_kv_bnsh(key, self.num_key_value_groups)\n        value = repeat_kv_bnsh(value, self.num_key_value_groups)\n        return self._t(query, key, value)\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            causal_mask: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            fcm_mask=None,\n    ):\n        \"\"\"\n\n        The __call__ function is the main function of a JAX module. It defines how the module behaves when called\n        with inputs. The __call__ function can be thought of as a &amp;quot;forward pass&amp;quot; through the model,\n        and it should return all outputs that are needed for training or inference.\n\n        :param self: Access variables that belong to the class\n        :param hidden_states: chex.Array: Pass the hidden states of the previous layer\n        :param freq_cis: chex.Array: Pass in the frequency coefficients for each position\n        :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n        :param position_ids: chex.Array: Determine the position of each token in a sequence\n        :param causal_mask: chex.Array: Mask out the future tokens in the decoder\n        :param deterministic: bool: Determine whether to use dropout or not\n        :param init_cache: bool: Initialize the cache\n        :param output_attentions: bool: Determine whether to return the attention weights or not\n        :param fcm_mask: Mask out the attention weights between the input and output tokens\n        :param : Determine if the attention is causal or not\n        :return: A tuple of two arrays\n\n        \"\"\"\n        batch_size, sequence_length = hidden_states.shape[:2]\n        query_state, key_state, value_state = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(\n            hidden_states)\n\n        if self.config.use_pjit_attention_force:\n            query_state = with_sharding_constraint(\n                query_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n            key_state = with_sharding_constraint(\n                key_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n            value_state = with_sharding_constraint(\n                value_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n\n        query_state = query_state.reshape(\n            batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n        key_state = key_state.reshape(\n            batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n        value_state = value_state.reshape(\n            batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n        query_state, key_state, value_state = self.apply_rotary(\n            query=query_state,\n            key=key_state,\n            value=value_state,\n            position_ids=position_ids,\n            freq_cis=freq_cis,\n            batch_size=batch_size,\n            sequence_length=sequence_length\n        )\n\n        assert_msg = (\n            \"num_attention_heads repeat wont work likely\\n\"\n            f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n            f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n        )\n\n        assert query_state.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert key_state.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert value_state.shape[-2] == self.config.num_attention_heads, assert_msg\n\n        query_length, key_length = query_state.shape[1], key_state.shape[1]\n\n        if self.has_variable(\"cache\", \"cached_key\"):\n            mask_shift = self.variables[\"cache\"][\"cache_index\"]\n            max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n            causal_mask = lax.dynamic_slice(\n                causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                     query_length, max_decoder_length)\n            )\n        else:\n            causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n        batch_size = hidden_states.shape[0]\n        causal_mask = jnp.broadcast_to(\n            causal_mask, (batch_size,) + causal_mask.shape[1:])\n        if attention_mask.ndim == 2:\n            attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n        attention_mask = jnp.broadcast_to(\n            attention_mask, causal_mask.shape\n        )\n        attention_mask = combine_masks(attention_mask, causal_mask, fcm_mask)\n\n        dropout_rng = None\n\n        if not deterministic and self.config.attention_dropout &gt; 0.0:\n            dropout_rng = self.make_rng(\"dropout\")\n\n        if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n            key_state, value_state, attention_mask = self._concatenate_to_cache(\n                key_state,\n                value_state,\n                query_state,\n                attention_mask\n            )\n\n        attention_bias = lax.select(\n            attention_mask &gt; 0,\n            jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n            jnp.full(attention_mask.shape, jnp.finfo(\n                self.dtype).min).astype(self.dtype),\n        )\n\n        query_state, key_state, value_state = map(\n            lambda a: a.transpose(0, 2, 1, 3),\n            [query_state, key_state, value_state]\n        )\n\n        query_length, key_length = query_state.shape[-2], key_state.shape[-2]\n\n        attentions = self.attention_performer.__call__(\n            query_states=query_state,\n            key_states=key_state,\n            value_states=value_state,\n            bias=attention_bias,\n            causal=False,\n            use_pjit_attention_force=self.config.use_pjit_attention_force,\n            dropout_rng=dropout_rng,\n            deterministic=deterministic,\n            query_sequence_length=query_length,\n            key_value_sequence_length=key_length,\n            uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n        )\n        attentions.attention_outputs = attentions.attention_outputs.transpose(0, 2, 1, 3)\n\n        attn_output = self._merge_heads(attentions.attention_outputs)\n        attn_output = self.o_proj(attn_output)\n\n        outputs = (\n            attn_output, attentions.attention_weights\n        ) if output_attentions else (\n            attn_output,\n        )\n        return outputs\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralAttention.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, position_ids, causal_mask, deterministic=True, init_cache=False, output_attentions=False, fcm_mask=None)</code>","text":"<p>The call function is the main function of a JAX module. It defines how the module behaves when called with inputs. The call function can be thought of as a \"forward pass\" through the model, and it should return all outputs that are needed for training or inference.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass the hidden states of the previous layer</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass in the frequency coefficients for each position</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out certain tokens in the input sequence</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Determine the position of each token in a sequence</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask out the future tokens in the decoder</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attention weights or not</p> <code>False</code> <code>fcm_mask</code> <p>Mask out the attention weights between the input and output tokens</p> <code>None</code> <code></code> <p>Determine if the attention is causal or not</p> required <p>Returns:</p> Type Description <p>A tuple of two arrays</p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        causal_mask: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        fcm_mask=None,\n):\n    \"\"\"\n\n    The __call__ function is the main function of a JAX module. It defines how the module behaves when called\n    with inputs. The __call__ function can be thought of as a &amp;quot;forward pass&amp;quot; through the model,\n    and it should return all outputs that are needed for training or inference.\n\n    :param self: Access variables that belong to the class\n    :param hidden_states: chex.Array: Pass the hidden states of the previous layer\n    :param freq_cis: chex.Array: Pass in the frequency coefficients for each position\n    :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n    :param position_ids: chex.Array: Determine the position of each token in a sequence\n    :param causal_mask: chex.Array: Mask out the future tokens in the decoder\n    :param deterministic: bool: Determine whether to use dropout or not\n    :param init_cache: bool: Initialize the cache\n    :param output_attentions: bool: Determine whether to return the attention weights or not\n    :param fcm_mask: Mask out the attention weights between the input and output tokens\n    :param : Determine if the attention is causal or not\n    :return: A tuple of two arrays\n\n    \"\"\"\n    batch_size, sequence_length = hidden_states.shape[:2]\n    query_state, key_state, value_state = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(\n        hidden_states)\n\n    if self.config.use_pjit_attention_force:\n        query_state = with_sharding_constraint(\n            query_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n        key_state = with_sharding_constraint(\n            key_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n        value_state = with_sharding_constraint(\n            value_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n\n    query_state = query_state.reshape(\n        batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n    key_state = key_state.reshape(\n        batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n    value_state = value_state.reshape(\n        batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n    query_state, key_state, value_state = self.apply_rotary(\n        query=query_state,\n        key=key_state,\n        value=value_state,\n        position_ids=position_ids,\n        freq_cis=freq_cis,\n        batch_size=batch_size,\n        sequence_length=sequence_length\n    )\n\n    assert_msg = (\n        \"num_attention_heads repeat wont work likely\\n\"\n        f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n        f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n    )\n\n    assert query_state.shape[-2] == self.config.num_attention_heads, assert_msg\n    assert key_state.shape[-2] == self.config.num_attention_heads, assert_msg\n    assert value_state.shape[-2] == self.config.num_attention_heads, assert_msg\n\n    query_length, key_length = query_state.shape[1], key_state.shape[1]\n\n    if self.has_variable(\"cache\", \"cached_key\"):\n        mask_shift = self.variables[\"cache\"][\"cache_index\"]\n        max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n        causal_mask = lax.dynamic_slice(\n            causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                 query_length, max_decoder_length)\n        )\n    else:\n        causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n    batch_size = hidden_states.shape[0]\n    causal_mask = jnp.broadcast_to(\n        causal_mask, (batch_size,) + causal_mask.shape[1:])\n    if attention_mask.ndim == 2:\n        attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n    attention_mask = jnp.broadcast_to(\n        attention_mask, causal_mask.shape\n    )\n    attention_mask = combine_masks(attention_mask, causal_mask, fcm_mask)\n\n    dropout_rng = None\n\n    if not deterministic and self.config.attention_dropout &gt; 0.0:\n        dropout_rng = self.make_rng(\"dropout\")\n\n    if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n        key_state, value_state, attention_mask = self._concatenate_to_cache(\n            key_state,\n            value_state,\n            query_state,\n            attention_mask\n        )\n\n    attention_bias = lax.select(\n        attention_mask &gt; 0,\n        jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n        jnp.full(attention_mask.shape, jnp.finfo(\n            self.dtype).min).astype(self.dtype),\n    )\n\n    query_state, key_state, value_state = map(\n        lambda a: a.transpose(0, 2, 1, 3),\n        [query_state, key_state, value_state]\n    )\n\n    query_length, key_length = query_state.shape[-2], key_state.shape[-2]\n\n    attentions = self.attention_performer.__call__(\n        query_states=query_state,\n        key_states=key_state,\n        value_states=value_state,\n        bias=attention_bias,\n        causal=False,\n        use_pjit_attention_force=self.config.use_pjit_attention_force,\n        dropout_rng=dropout_rng,\n        deterministic=deterministic,\n        query_sequence_length=query_length,\n        key_value_sequence_length=key_length,\n        uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n    )\n    attentions.attention_outputs = attentions.attention_outputs.transpose(0, 2, 1, 3)\n\n    attn_output = self._merge_heads(attentions.attention_outputs)\n    attn_output = self.o_proj(attn_output)\n\n    outputs = (\n        attn_output, attentions.attention_weights\n    ) if output_attentions else (\n        attn_output,\n    )\n    return outputs\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralAttention.apply_rotary","title":"<code>apply_rotary(batch_size, sequence_length, query, key, value, freq_cis, position_ids)</code>","text":"<p>The apply_rotary function is a modified version of the apply_attention function in the BertModel class. The main difference is that it takes in an additional argument, freq_cis, which are used to calculate the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>batch_size</code> <p>Reshape the query, key and value tensors</p> required <code>sequence_length</code> <p>Reshape the query, key and value tensors</p> required <code>query</code> <p>Calculate the attention weights</p> required <code>key</code> <p>Calculate the attention</p> required <code>value</code> <p>Compute the attention weights</p> required <code>freq_cis</code> <p>Calculate the frequency of each word in the vocabulary</p> required <code>position_ids</code> <p>Identify the position of each token in the sequence</p> required <p>Returns:</p> Type Description <p>A tuple of 3 tensors: query, key and value</p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n    \"\"\"\n    The apply_rotary function is a modified version of the apply_attention function in the BertModel class.\n    The main difference is that it takes in an additional argument, freq_cis, which are used to calculate\n    the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.\n\n    :param self: Access variables that belong to the class\n    :param batch_size: Reshape the query, key and value tensors\n    :param sequence_length: Reshape the query, key and value tensors\n    :param query: Calculate the attention weights\n    :param key: Calculate the attention\n    :param value: Compute the attention weights\n    :param freq_cis: Calculate the frequency of each word in the vocabulary\n    :param position_ids: Identify the position of each token in the sequence\n    :return: A tuple of 3 tensors: query, key and value\n\n    \"\"\"\n    query = query.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_attention_heads,\n        self.head_dim\n    )\n    key = key.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_key_value_heads,\n        self.head_dim\n    )\n    value = value.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_key_value_heads,\n        self.head_dim\n    )\n\n    query, key, value = self._t(query, key, value)\n    query, key = self.rotary(\n        position_ids=position_ids, query=query, key=key, freq_cis=freq_cis\n    )\n    key = repeat_kv_bnsh(key, self.num_key_value_groups)\n    value = repeat_kv_bnsh(value, self.num_key_value_groups)\n    return self._t(query, key, value)\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralDecoderLayer","title":"<code>FlaxMistralDecoderLayer</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>class FlaxMistralDecoderLayer(nn.Module):\n    config: MistralConfig\n    dtype: jnp.dtype = jnp.bfloat16\n    param_dtype: jnp.dtype = jnp.bfloat16\n    precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\")\n\n    def setup(self) -&gt; None:\n        self.self_attn = FlaxMistralAttention(\n            config=self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        self.mlp = FlaxMistralMLP(\n            config=self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        self.input_layernorm = MistralRMSNorm(\n            dim=self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype\n        )\n        self.post_attention_layernorm = MistralRMSNorm(\n            dim=self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype\n        )\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            causal_mask: chex.Array,\n            position_ids: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = True\n    ):\n        \"\"\"\n        The __call__ function is the main function of a TransformerEncoderLayer.\n        It takes in the following arguments:\n            hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed\n            by all sublayers.\n            freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector,\n            used for computing self-attention weights and biases in a more efficient manner than using position\n            embeddings or sinusoidal positional encoding vectors would allow for [2].\n\n        :param self: Represent the instance of the class\n        :param hidden_states: chex.Array: Represent the input to the encoder layer\n        :param freq_cis: chex.Array: Pass the frequency information to the attention layer\n        :param attention_mask: chex.Array: Mask out the attention weights for certain positions\n        :param causal_mask: chex.Array: Mask the future tokens\n        :param position_ids: chex.Array: Indicate the position of each token in the sequence\n        :param deterministic: bool: Determine whether to use dropout or not\n        :param init_cache: bool: Initialize the cache for the self-attention layer\n        :param output_attentions: bool: Determine whether to return the attention weights or not\n        :return: A tuple of hidden_states and attention_output\n\n        \"\"\"\n        residual = hidden_states\n        attention_output = self.self_attn(\n            hidden_states=self.input_layernorm(hidden_states),\n            freq_cis=freq_cis,\n            attention_mask=attention_mask,\n            causal_mask=causal_mask,\n            position_ids=position_ids,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions\n        )\n\n        hidden_states = attention_output[0] + residual\n\n        hidden_states = self.mlp(\n            self.post_attention_layernorm(hidden_states)) + hidden_states\n        outputs = (hidden_states,)\n        if output_attentions:\n            outputs += attention_output[1]\n        return outputs\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralDecoderLayer.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, causal_mask, position_ids, deterministic=True, init_cache=False, output_attentions=True)</code>","text":"<p>The call function is the main function of a TransformerEncoderLayer. It takes in the following arguments:     hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed     by all sublayers.     freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector,     used for computing self-attention weights and biases in a more efficient manner than using position     embeddings or sinusoidal positional encoding vectors would allow for [2].</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Represent the input to the encoder layer</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass the frequency information to the attention layer</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the attention weights for certain positions</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask the future tokens</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Indicate the position of each token in the sequence</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the self-attention layer</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attention weights or not</p> <code>True</code> <p>Returns:</p> Type Description <p>A tuple of hidden_states and attention_output</p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        causal_mask: chex.Array,\n        position_ids: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = True\n):\n    \"\"\"\n    The __call__ function is the main function of a TransformerEncoderLayer.\n    It takes in the following arguments:\n        hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed\n        by all sublayers.\n        freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector,\n        used for computing self-attention weights and biases in a more efficient manner than using position\n        embeddings or sinusoidal positional encoding vectors would allow for [2].\n\n    :param self: Represent the instance of the class\n    :param hidden_states: chex.Array: Represent the input to the encoder layer\n    :param freq_cis: chex.Array: Pass the frequency information to the attention layer\n    :param attention_mask: chex.Array: Mask out the attention weights for certain positions\n    :param causal_mask: chex.Array: Mask the future tokens\n    :param position_ids: chex.Array: Indicate the position of each token in the sequence\n    :param deterministic: bool: Determine whether to use dropout or not\n    :param init_cache: bool: Initialize the cache for the self-attention layer\n    :param output_attentions: bool: Determine whether to return the attention weights or not\n    :return: A tuple of hidden_states and attention_output\n\n    \"\"\"\n    residual = hidden_states\n    attention_output = self.self_attn(\n        hidden_states=self.input_layernorm(hidden_states),\n        freq_cis=freq_cis,\n        attention_mask=attention_mask,\n        causal_mask=causal_mask,\n        position_ids=position_ids,\n        deterministic=deterministic,\n        init_cache=init_cache,\n        output_attentions=output_attentions\n    )\n\n    hidden_states = attention_output[0] + residual\n\n    hidden_states = self.mlp(\n        self.post_attention_layernorm(hidden_states)) + hidden_states\n    outputs = (hidden_states,)\n    if output_attentions:\n        outputs += attention_output[1]\n    return outputs\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralForCausalLMModule","title":"<code>FlaxMistralForCausalLMModule</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>class FlaxMistralForCausalLMModule(nn.Module):\n    config: MistralConfig\n    dtype: jnp.dtype = jnp.bfloat16\n    param_dtype: jnp.dtype = jnp.bfloat16\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        self.model: FlaxMistralModule = FlaxMistralModule(\n            self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision,\n        )\n\n        self.lm_head = nn.Dense(\n            self.config.vocab_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                stddev=self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            deterministic: bool = True,\n            inputs_embeds: chex.Array = None,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n    ):\n        \"\"\"\n            The __call__ function is the main function of a Flax module. It defines how the model will be called,\n            and what it returns. In this case, we are calling our Transformer model with input_ids and attention_mask\n            as inputs (these are defined in __init__). We also have some optional arguments that can be passed to\n            the call function: deterministic (whether to use dropout), inputs_embeds (if you want to pass your own embeddings),\n            output_attentions and output_hidden states which return additional outputs from the transformer layers if set True. Finally,\n\n            :param self: Refer to the object itself\n            :param input_ids: chex.Array: Pass in the input tokens\n            :param attention_mask: chex.Array: Mask out the padding tokens\n            :param position_ids: chex.Array: Specify the position of each token in the sequence\n            :param deterministic: bool: Determine whether to use dropout in the model\n            :param inputs_embeds: chex.Array: Pass in the embeddings of the input tokens\n            :param init_cache: bool: Initialize the cache for the decoder\n            :param output_attentions: bool: Return the attention weights\n            :param output_hidden_states: bool: Return the hidden states of all layers\n            :param return_dict: bool: Return a dictionary of the outputs or just the logits\n            :param : Determine whether to return the logits or not\n            :return: A tuple of (lm_logits, hidden_states, attentions)\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n\n        if attention_mask is None:\n            attention_mask = jnp.ones_like(input_ids)\n        if position_ids is None:\n            position_ids = jnp.broadcast_to(\n                jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n                (batch_size, seq_length)\n            )\n        outputs = self.model(\n            input_ids=input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            deterministic=deterministic,\n            inputs_embeds=inputs_embeds,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict\n        )\n\n        hidden_states = outputs[0]\n\n        if self.config.tie_word_embeddings:\n            shared_kernel = self.transformer.variables[\"params\"][\"wte\"][\"embedding\"].T\n            lm_logits = self.lm_head.apply(\n                {\"params\": {\"kernel\": shared_kernel}}, hidden_states)\n        else:\n            lm_logits = self.lm_head(hidden_states)\n\n        # lm_logits = lm_logits.astype(jnp.float32)\n\n        if not return_dict:\n            return (lm_logits,) + outputs[1:]\n\n        return FlaxCausalLMOutput(logits=lm_logits, hidden_states=outputs.hidden_states, attentions=outputs.attentions)\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralForCausalLMModule.__call__","title":"<code>__call__(input_ids, attention_mask, position_ids, deterministic=True, inputs_embeds=None, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True)</code>","text":"<p>The call function is the main function of a Flax module. It defines how the model will be called, and what it returns. In this case, we are calling our Transformer model with input_ids and attention_mask as inputs (these are defined in init). We also have some optional arguments that can be passed to the call function: deterministic (whether to use dropout), inputs_embeds (if you want to pass your own embeddings), output_attentions and output_hidden states which return additional outputs from the transformer layers if set True. Finally,</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass in the input tokens</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the padding tokens</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in the sequence</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout in the model</p> <code>True</code> <code>inputs_embeds</code> <code>Array</code> <p>chex.Array: Pass in the embeddings of the input tokens</p> <code>None</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the decoder</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Return the attention weights</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Return the hidden states of all layers</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of the outputs or just the logits</p> <code>True</code> <code></code> <p>Determine whether to return the logits or not</p> required <p>Returns:</p> Type Description <p>A tuple of (lm_logits, hidden_states, attentions)</p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        deterministic: bool = True,\n        inputs_embeds: chex.Array = None,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n):\n    \"\"\"\n        The __call__ function is the main function of a Flax module. It defines how the model will be called,\n        and what it returns. In this case, we are calling our Transformer model with input_ids and attention_mask\n        as inputs (these are defined in __init__). We also have some optional arguments that can be passed to\n        the call function: deterministic (whether to use dropout), inputs_embeds (if you want to pass your own embeddings),\n        output_attentions and output_hidden states which return additional outputs from the transformer layers if set True. Finally,\n\n        :param self: Refer to the object itself\n        :param input_ids: chex.Array: Pass in the input tokens\n        :param attention_mask: chex.Array: Mask out the padding tokens\n        :param position_ids: chex.Array: Specify the position of each token in the sequence\n        :param deterministic: bool: Determine whether to use dropout in the model\n        :param inputs_embeds: chex.Array: Pass in the embeddings of the input tokens\n        :param init_cache: bool: Initialize the cache for the decoder\n        :param output_attentions: bool: Return the attention weights\n        :param output_hidden_states: bool: Return the hidden states of all layers\n        :param return_dict: bool: Return a dictionary of the outputs or just the logits\n        :param : Determine whether to return the logits or not\n        :return: A tuple of (lm_logits, hidden_states, attentions)\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n\n    if attention_mask is None:\n        attention_mask = jnp.ones_like(input_ids)\n    if position_ids is None:\n        position_ids = jnp.broadcast_to(\n            jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n            (batch_size, seq_length)\n        )\n    outputs = self.model(\n        input_ids=input_ids,\n        attention_mask=attention_mask,\n        position_ids=position_ids,\n        deterministic=deterministic,\n        inputs_embeds=inputs_embeds,\n        init_cache=init_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict\n    )\n\n    hidden_states = outputs[0]\n\n    if self.config.tie_word_embeddings:\n        shared_kernel = self.transformer.variables[\"params\"][\"wte\"][\"embedding\"].T\n        lm_logits = self.lm_head.apply(\n            {\"params\": {\"kernel\": shared_kernel}}, hidden_states)\n    else:\n        lm_logits = self.lm_head(hidden_states)\n\n    # lm_logits = lm_logits.astype(jnp.float32)\n\n    if not return_dict:\n        return (lm_logits,) + outputs[1:]\n\n    return FlaxCausalLMOutput(logits=lm_logits, hidden_states=outputs.hidden_states, attentions=outputs.attentions)\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralModule","title":"<code>FlaxMistralModule</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>class FlaxMistralModule(nn.Module):\n    config: MistralConfig\n    dtype: jnp.dtype = jnp.bfloat16\n    param_dtype: jnp.dtype = jnp.bfloat16\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n\n        self.embed_tokens = nn.Embed(\n            self.config.vocab_size,\n            self.config.hidden_size,\n            embedding_init=jax.nn.initializers.normal(\n                stddev=self.config.initializer_range),\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n        )\n\n        self.layers = FlaxMistralDecoratorCollection(\n            self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        self.norm = MistralRMSNorm(\n            self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype\n        )\n\n        initial_rope_kwargs = dict(\n            rope_type=\"none\"\n        )\n        if self.config.rope_scaling is not None:\n            scaling_type = self.config.rope_scaling[\"type\"]\n            scaling_factor = self.config.rope_scaling[\"factor\"]\n            initial_rope_kwargs = dict(\n                scaling_factor=scaling_factor,\n                rope_type=scaling_type\n            )\n        self.freq_cis = precompute_freq_cis(\n            max_position_embeddings=self.config.max_position_embeddings,\n            dim=self.config.hidden_size // self.config.num_attention_heads,\n            base=self.config.rope_theta,\n            **initial_rope_kwargs\n        )\n        self.causal_mask = nn.make_causal_mask(\n            jnp.ones((1, self.config.c_max_position_embeddings), dtype='i4'))\n\n    def __call__(\n            self,\n            input_ids: Optional[chex.Array] = None,\n            attention_mask: Optional[chex.Array] = None,\n            position_ids: Optional[chex.Array] = None,\n            deterministic: bool = True,\n            inputs_embeds: chex.Array = None,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n\n    ) -&gt; typing.Union[Tuple[Array, ...], FlaxBaseModelOutput]:\n        \"\"\"\n        The __call__ function is the main function of a Flax model.\n        It takes in input_ids, attention_mask, and position_ids as inputs to the model.\n        The output is a tuple containing: last hidden state (hidden states), all hidden states (if output_hidden_states=True), attentions (if output attentions=True).\n\n\n        :param self: Represent the instance of the class\n        :param input_ids: chex.Array: Pass in the input ids\n        :param attention_mask: chex.Array: Mask out the attention weights for certain tokens\n        :param position_ids: chex.Array: Determine the position of each token in a sequence\n        :param deterministic: bool: Determine whether to use dropout or not\n        :param inputs_embeds: chex.Array: Pass in the embedding of the input_ids\n        :param init_cache: bool: Initialize the cache for the decoder\n        :param output_attentions: bool: Determine whether to return the attention weights or not\n        :param output_hidden_states: bool: Return all hidden states or just the last one\n        :param return_dict: bool: Return a dictionary of the outputs or not\n        :param : Determine whether the model is in training mode or not\n        :return: A tuple of the hidden states, all hidden states, and attentions\n\n        \"\"\"\n        if inputs_embeds is None:\n            inputs_embeds = self.embed_tokens(input_ids.astype(\"i4\"))\n        if attention_mask.ndim == 2:\n            b, s = attention_mask.shape\n            attention_mask = attention_mask.reshape(b, 1, 1, s)\n\n        outputs = self.layers(\n            hidden_states=inputs_embeds,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            freq_cis=self.freq_cis,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            deterministic=deterministic,\n            causal_mask=self.causal_mask\n        )\n\n        hidden_states = outputs[0]\n        hidden_states = self.norm(hidden_states)\n\n        if output_hidden_states:\n            all_hidden_states = outputs[1] + (hidden_states,)\n            outputs = (hidden_states, all_hidden_states) + outputs[2:]\n        else:\n            outputs = (hidden_states,) + outputs[1:]\n\n        if not return_dict:\n            return tuple(value for value in outputs if value is not None)\n\n        return FlaxBaseModelOutput(\n            last_hidden_state=hidden_states,\n            hidden_states=outputs[1],\n            attentions=outputs[-1],\n        )\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralModule.__call__","title":"<code>__call__(input_ids=None, attention_mask=None, position_ids=None, deterministic=True, inputs_embeds=None, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True)</code>","text":"<p>The call function is the main function of a Flax model. It takes in input_ids, attention_mask, and position_ids as inputs to the model. The output is a tuple containing: last hidden state (hidden states), all hidden states (if output_hidden_states=True), attentions (if output attentions=True).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>input_ids</code> <code>Optional[Array]</code> <p>chex.Array: Pass in the input ids</p> <code>None</code> <code>attention_mask</code> <code>Optional[Array]</code> <p>chex.Array: Mask out the attention weights for certain tokens</p> <code>None</code> <code>position_ids</code> <code>Optional[Array]</code> <p>chex.Array: Determine the position of each token in a sequence</p> <code>None</code> <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>True</code> <code>inputs_embeds</code> <code>Array</code> <p>chex.Array: Pass in the embedding of the input_ids</p> <code>None</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the decoder</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attention weights or not</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Return all hidden states or just the last one</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of the outputs or not</p> <code>True</code> <code></code> <p>Determine whether the model is in training mode or not</p> required <p>Returns:</p> Type Description <code>Union[Tuple[Array, ...], FlaxBaseModelOutput]</code> <p>A tuple of the hidden states, all hidden states, and attentions</p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: Optional[chex.Array] = None,\n        attention_mask: Optional[chex.Array] = None,\n        position_ids: Optional[chex.Array] = None,\n        deterministic: bool = True,\n        inputs_embeds: chex.Array = None,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n\n) -&gt; typing.Union[Tuple[Array, ...], FlaxBaseModelOutput]:\n    \"\"\"\n    The __call__ function is the main function of a Flax model.\n    It takes in input_ids, attention_mask, and position_ids as inputs to the model.\n    The output is a tuple containing: last hidden state (hidden states), all hidden states (if output_hidden_states=True), attentions (if output attentions=True).\n\n\n    :param self: Represent the instance of the class\n    :param input_ids: chex.Array: Pass in the input ids\n    :param attention_mask: chex.Array: Mask out the attention weights for certain tokens\n    :param position_ids: chex.Array: Determine the position of each token in a sequence\n    :param deterministic: bool: Determine whether to use dropout or not\n    :param inputs_embeds: chex.Array: Pass in the embedding of the input_ids\n    :param init_cache: bool: Initialize the cache for the decoder\n    :param output_attentions: bool: Determine whether to return the attention weights or not\n    :param output_hidden_states: bool: Return all hidden states or just the last one\n    :param return_dict: bool: Return a dictionary of the outputs or not\n    :param : Determine whether the model is in training mode or not\n    :return: A tuple of the hidden states, all hidden states, and attentions\n\n    \"\"\"\n    if inputs_embeds is None:\n        inputs_embeds = self.embed_tokens(input_ids.astype(\"i4\"))\n    if attention_mask.ndim == 2:\n        b, s = attention_mask.shape\n        attention_mask = attention_mask.reshape(b, 1, 1, s)\n\n    outputs = self.layers(\n        hidden_states=inputs_embeds,\n        attention_mask=attention_mask,\n        position_ids=position_ids,\n        freq_cis=self.freq_cis,\n        init_cache=init_cache,\n        output_attentions=output_attentions,\n        deterministic=deterministic,\n        causal_mask=self.causal_mask\n    )\n\n    hidden_states = outputs[0]\n    hidden_states = self.norm(hidden_states)\n\n    if output_hidden_states:\n        all_hidden_states = outputs[1] + (hidden_states,)\n        outputs = (hidden_states, all_hidden_states) + outputs[2:]\n    else:\n        outputs = (hidden_states,) + outputs[1:]\n\n    if not return_dict:\n        return tuple(value for value in outputs if value is not None)\n\n    return FlaxBaseModelOutput(\n        last_hidden_state=hidden_states,\n        hidden_states=outputs[1],\n        attentions=outputs[-1],\n    )\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralPretrainedModel","title":"<code>FlaxMistralPretrainedModel</code>","text":"<p>             Bases: <code>EasyDelFlaxPretrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>class FlaxMistralPretrainedModel(EasyDelFlaxPretrainedModel):\n    config_class = MistralConfig\n    base_model_prefix = 'mistral'\n    module_class: nn.Module = None\n\n    def __init__(self,\n                 config: MistralConfig,\n                 input_shape: Tuple = (1, 1),\n                 seed: int = 0,\n                 dtype: jnp.dtype = jnp.bfloat16,\n                 _do_init: bool = True,\n                 **kwargs\n                 ):\n        module = self.module_class(config=config, dtype=dtype, **kwargs)\n        super().__init__(config, module, input_shape=input_shape,\n                         seed=seed, dtype=dtype, _do_init=_do_init)\n\n    def init_weights(\n            self,\n            rng: jax.random.PRNGKey,\n            input_shape: Tuple,\n            params: flax.core.FrozenDict = None\n    ) -&gt; flax.core.FrozenDict:\n        \"\"\"\n        The init_weights function is used to initialize the weights of a model.\n        It takes in an rng, which is a random number generator key that can be used to generate random numbers.\n        The input_shape parameter specifies the shape of the inputs that will be fed into this model.\n        The params parameter allows you to pass in pre-trained weights for your model, if you have them available.\n\n        :param self: Access variables that belong to the class\n        :param rng: jax.random.PRNGKey: Initialize the weights of the model\n        :param input_shape: Tuple: Initialize the input_ids, attention_mask and position_ids\n        :param params: flax.core.FrozenDict: Pass in the parameters of a pre-trained model\n        :return: A frozendict of parameters\n\n        \"\"\"\n        input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(\n            jnp.atleast_2d(input_ids).shape[-1]), input_shape)\n        params_rng, dropout_rng = jax.random.split(rng)\n        rng_s = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n        if self.config.add_cross_attention:\n            encoder_hidden_states = jnp.zeros(\n                input_shape + (self.config.hidden_size,))\n            encoder_attention_mask = attention_mask\n            module_init_outputs = self.module.init(\n                rng_s,\n                input_ids,\n                attention_mask,\n                position_ids,\n                encoder_hidden_states,\n                encoder_attention_mask,\n                return_dict=False,\n            )\n        else:\n            module_init_outputs = self.module.init(\n                rng_s, input_ids, attention_mask, position_ids, return_dict=False\n            )\n\n        random_params = module_init_outputs[\"params\"]\n\n        if params is not None:\n            random_params = flatten_dict(unfreeze(random_params))\n            params = flatten_dict(unfreeze(params))\n            for missing_key in self._missing_keys:\n                params[missing_key] = random_params[missing_key]\n            self._missing_keys = set()\n            return freeze(unflatten_dict(params))\n        else:\n            return random_params\n\n    def init_cache(self, batch_size, max_length):\n\n        input_ids = jnp.ones((batch_size, max_length))\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(\n            jnp.atleast_2d(input_ids).shape[-1]), input_ids.shape)\n\n        init_variables = self.module.init(\n            jax.random.PRNGKey(0), input_ids, attention_mask, position_ids, return_dict=False, init_cache=True\n        )\n        return init_variables[\"cache\"]\n\n    def __call__(\n            self,\n            input_ids,\n            attention_mask=None,\n            position_ids=None,\n            params: dict = None,\n            past_key_values: dict = None,\n            dropout_rng: jax.random.PRNGKey = None,\n            train: bool = False,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            return_dict: Optional[bool] = None,\n            add_params_field: bool = False,\n            **kwargs\n    ):\n        \"\"\"\n        The __call__ function is the main function of a JAX module.\n        It takes as input:\n        - The parameters of the model (self.params)\n        - The inputs to the model (input_ids, attention_mask, position_ids)\n        - Whether we are training (train=True/False) and whether we want to return all hidden states and\n        attentions weights at each layer in addition to just the last layer output (output_hidden_states=True/False).\n\n        :param self: Represent the instance of the class\n        :param input_ids: Pass the input sequence to the model\n        :param attention_mask: Mask out the padding tokens\n        :param position_ids: Specify the position of each token in the sequence\n        :param params: dict: Pass in the parameters of the model\n        :param past_key_values: dict: Pass the past key values to the model\n        :param dropout_rng: jax.random.PRNGKey: Pass in a random number generator key to the model\n        :param train: bool: Determine whether to use dropout or not\n        :param output_attentions: Optional[bool]: Determine whether to return the attention weights\n        :param output_hidden_states: Optional[bool]: Determine whether to return the hidden states of all layers\n        :param return_dict: Optional[bool]: Return a dictionary of the outputs\n        :param add_params_field: bool: Add a params field to the inputs dictionary\n        :return: A tuple of (last_hidden_state, past_key_values)\n\n        \"\"\"\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n        batch_size, sequence_length = input_ids.shape\n\n        if position_ids is None:\n            if past_key_values is not None:\n                raise ValueError(\n                    \"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n            position_ids = jnp.broadcast_to(jnp.arange(sequence_length)[\n                                            None, :], (batch_size, sequence_length))\n\n        if attention_mask is None:\n            attention_mask = jnp.ones((batch_size, sequence_length))\n\n        rng_s = {}\n        if dropout_rng is not None:\n            rng_s[\"dropout\"] = dropout_rng\n\n        inputs = {\n            \"params\": params or self.params} if add_params_field else params or self.params\n\n        if self.config.bits is not None:\n            rng_s['params'] = jax.random.key(0)\n        if past_key_values:\n            inputs[\"cache\"] = past_key_values\n            mutable = [\"cache\"]\n        else:\n            mutable = False\n\n        outputs = self.module.apply(\n            inputs,\n            jnp.array(input_ids, dtype=\"i4\"),\n            jnp.array(attention_mask, dtype=\"i4\"),\n            jnp.array(position_ids, dtype=\"i4\"),\n            not train,\n            None,\n            False,\n            output_attentions,\n            output_hidden_states,\n            return_dict,\n            rngs=rng_s,\n            mutable=mutable,\n        )\n\n        if past_key_values is not None and return_dict:\n            outputs, past_key_values = outputs\n            outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n            return outputs\n        elif past_key_values is not None and not return_dict:\n            outputs, past_key_values = outputs\n            outputs = outputs[:1] + \\\n                      (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n        return outputs\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralPretrainedModel.__call__","title":"<code>__call__(input_ids, attention_mask=None, position_ids=None, params=None, past_key_values=None, dropout_rng=None, train=False, output_attentions=None, output_hidden_states=None, return_dict=None, add_params_field=False, **kwargs)</code>","text":"<p>The call function is the main function of a JAX module. It takes as input: - The parameters of the model (self.params) - The inputs to the model (input_ids, attention_mask, position_ids) - Whether we are training (train=True/False) and whether we want to return all hidden states and attentions weights at each layer in addition to just the last layer output (output_hidden_states=True/False).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>input_ids</code> <p>Pass the input sequence to the model</p> required <code>attention_mask</code> <p>Mask out the padding tokens</p> <code>None</code> <code>position_ids</code> <p>Specify the position of each token in the sequence</p> <code>None</code> <code>params</code> <code>dict</code> <p>dict: Pass in the parameters of the model</p> <code>None</code> <code>past_key_values</code> <code>dict</code> <p>dict: Pass the past key values to the model</p> <code>None</code> <code>dropout_rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Pass in a random number generator key to the model</p> <code>None</code> <code>train</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>False</code> <code>output_attentions</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine whether to return the attention weights</p> <code>None</code> <code>output_hidden_states</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine whether to return the hidden states of all layers</p> <code>None</code> <code>return_dict</code> <code>Optional[bool]</code> <p>Optional[bool]: Return a dictionary of the outputs</p> <code>None</code> <code>add_params_field</code> <code>bool</code> <p>bool: Add a params field to the inputs dictionary</p> <code>False</code> <p>Returns:</p> Type Description <p>A tuple of (last_hidden_state, past_key_values)</p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids,\n        attention_mask=None,\n        position_ids=None,\n        params: dict = None,\n        past_key_values: dict = None,\n        dropout_rng: jax.random.PRNGKey = None,\n        train: bool = False,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        add_params_field: bool = False,\n        **kwargs\n):\n    \"\"\"\n    The __call__ function is the main function of a JAX module.\n    It takes as input:\n    - The parameters of the model (self.params)\n    - The inputs to the model (input_ids, attention_mask, position_ids)\n    - Whether we are training (train=True/False) and whether we want to return all hidden states and\n    attentions weights at each layer in addition to just the last layer output (output_hidden_states=True/False).\n\n    :param self: Represent the instance of the class\n    :param input_ids: Pass the input sequence to the model\n    :param attention_mask: Mask out the padding tokens\n    :param position_ids: Specify the position of each token in the sequence\n    :param params: dict: Pass in the parameters of the model\n    :param past_key_values: dict: Pass the past key values to the model\n    :param dropout_rng: jax.random.PRNGKey: Pass in a random number generator key to the model\n    :param train: bool: Determine whether to use dropout or not\n    :param output_attentions: Optional[bool]: Determine whether to return the attention weights\n    :param output_hidden_states: Optional[bool]: Determine whether to return the hidden states of all layers\n    :param return_dict: Optional[bool]: Return a dictionary of the outputs\n    :param add_params_field: bool: Add a params field to the inputs dictionary\n    :return: A tuple of (last_hidden_state, past_key_values)\n\n    \"\"\"\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n    batch_size, sequence_length = input_ids.shape\n\n    if position_ids is None:\n        if past_key_values is not None:\n            raise ValueError(\n                \"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n        position_ids = jnp.broadcast_to(jnp.arange(sequence_length)[\n                                        None, :], (batch_size, sequence_length))\n\n    if attention_mask is None:\n        attention_mask = jnp.ones((batch_size, sequence_length))\n\n    rng_s = {}\n    if dropout_rng is not None:\n        rng_s[\"dropout\"] = dropout_rng\n\n    inputs = {\n        \"params\": params or self.params} if add_params_field else params or self.params\n\n    if self.config.bits is not None:\n        rng_s['params'] = jax.random.key(0)\n    if past_key_values:\n        inputs[\"cache\"] = past_key_values\n        mutable = [\"cache\"]\n    else:\n        mutable = False\n\n    outputs = self.module.apply(\n        inputs,\n        jnp.array(input_ids, dtype=\"i4\"),\n        jnp.array(attention_mask, dtype=\"i4\"),\n        jnp.array(position_ids, dtype=\"i4\"),\n        not train,\n        None,\n        False,\n        output_attentions,\n        output_hidden_states,\n        return_dict,\n        rngs=rng_s,\n        mutable=mutable,\n    )\n\n    if past_key_values is not None and return_dict:\n        outputs, past_key_values = outputs\n        outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n        return outputs\n    elif past_key_values is not None and not return_dict:\n        outputs, past_key_values = outputs\n        outputs = outputs[:1] + \\\n                  (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n    return outputs\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.FlaxMistralPretrainedModel.init_weights","title":"<code>init_weights(rng, input_shape, params=None)</code>","text":"<p>The init_weights function is used to initialize the weights of a model. It takes in an rng, which is a random number generator key that can be used to generate random numbers. The input_shape parameter specifies the shape of the inputs that will be fed into this model. The params parameter allows you to pass in pre-trained weights for your model, if you have them available.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Initialize the weights of the model</p> required <code>input_shape</code> <code>Tuple</code> <p>Tuple: Initialize the input_ids, attention_mask and position_ids</p> required <code>params</code> <code>FrozenDict</code> <p>flax.core.FrozenDict: Pass in the parameters of a pre-trained model</p> <code>None</code> <p>Returns:</p> Type Description <code>FrozenDict</code> <p>A frozendict of parameters</p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>def init_weights(\n        self,\n        rng: jax.random.PRNGKey,\n        input_shape: Tuple,\n        params: flax.core.FrozenDict = None\n) -&gt; flax.core.FrozenDict:\n    \"\"\"\n    The init_weights function is used to initialize the weights of a model.\n    It takes in an rng, which is a random number generator key that can be used to generate random numbers.\n    The input_shape parameter specifies the shape of the inputs that will be fed into this model.\n    The params parameter allows you to pass in pre-trained weights for your model, if you have them available.\n\n    :param self: Access variables that belong to the class\n    :param rng: jax.random.PRNGKey: Initialize the weights of the model\n    :param input_shape: Tuple: Initialize the input_ids, attention_mask and position_ids\n    :param params: flax.core.FrozenDict: Pass in the parameters of a pre-trained model\n    :return: A frozendict of parameters\n\n    \"\"\"\n    input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n    attention_mask = jnp.ones_like(input_ids)\n    position_ids = jnp.broadcast_to(jnp.arange(\n        jnp.atleast_2d(input_ids).shape[-1]), input_shape)\n    params_rng, dropout_rng = jax.random.split(rng)\n    rng_s = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n    if self.config.add_cross_attention:\n        encoder_hidden_states = jnp.zeros(\n            input_shape + (self.config.hidden_size,))\n        encoder_attention_mask = attention_mask\n        module_init_outputs = self.module.init(\n            rng_s,\n            input_ids,\n            attention_mask,\n            position_ids,\n            encoder_hidden_states,\n            encoder_attention_mask,\n            return_dict=False,\n        )\n    else:\n        module_init_outputs = self.module.init(\n            rng_s, input_ids, attention_mask, position_ids, return_dict=False\n        )\n\n    random_params = module_init_outputs[\"params\"]\n\n    if params is not None:\n        random_params = flatten_dict(unfreeze(random_params))\n        params = flatten_dict(unfreeze(params))\n        for missing_key in self._missing_keys:\n            params[missing_key] = random_params[missing_key]\n        self._missing_keys = set()\n        return freeze(unflatten_dict(params))\n    else:\n        return random_params\n</code></pre>"},{"location":"generated-modules-mistral-modelling_mistral_flax/#lib.python.EasyDel.modules.mistral.modelling_mistral_flax.matmul_4d_loop","title":"<code>matmul_4d_loop(x, y)</code>","text":"<p>Computes the matrix product of two 4D arrays x and y using a loop.</p> Source code in <code>lib/python/EasyDel/modules/mistral/modelling_mistral_flax.py</code> <pre><code>def matmul_4d_loop(x, y):\n    \"\"\"Computes the matrix product of two 4D arrays x and y using a loop.\"\"\"\n    result = jnp.zeros(*x.shape[:-2] + x.shape[-2] + y.shape[-1])\n    for i in range(x.shape[0]):\n        for j in range(y.shape[1]):\n            for key in range(x.shape[2]):\n                for l in range(y.shape[3]):\n                    result[i, j, key, l] += x[i, j, key, :] * y[key, l, :, :]\n    return result\n</code></pre>"},{"location":"generated-modules-mixtral-mixtral_configuration/","title":"modules.mixtral.mixtral_configuration","text":""},{"location":"generated-modules-mixtral-mixtral_configuration/#lib.python.EasyDel.modules.mixtral.mixtral_configuration.MixtralConfig","title":"<code>MixtralConfig</code>","text":"<p>             Bases: <code>EasyDelPretrainedConfig</code></p> Source code in <code>lib/python/EasyDel/modules/mixtral/mixtral_configuration.py</code> <pre><code>class MixtralConfig(EasyDelPretrainedConfig):\n    model_type = \"mixtral\"\n\n    def __init__(\n            self,\n            vocab_size=32000,\n            hidden_size=4096,\n            intermediate_size=14336,\n            num_hidden_layers=32,\n            num_attention_heads=32,\n            num_key_value_heads=8,\n            hidden_act=\"silu\",\n            max_position_embeddings=4096 * 32,\n            initializer_range=0.02,\n            rms_norm_eps=1e-5,\n            use_cache=True,\n            pad_token_id=None,\n            bos_token_id=1,\n            eos_token_id=2,\n            tie_word_embeddings=False,\n            rope_theta=1e6,\n            sliding_window=4096,\n            attention_dropout=0.0,\n            num_experts_per_tok=2,\n            num_local_experts=8,\n            output_router_logits=False,\n            router_aux_loss_coef=0.001,\n            gradient_checkpointing: str = 'nothing_saveable',\n            use_pjit_attention_force: bool = False,\n            use_sacn_mlp: bool = False,\n            scan_mlp_chunk_size: int = 1024,\n            number_rep_kv: int = 1,\n            c_max_position_embeddings: int = 4096,\n            freq_max_position_embeddings: int = 4096,\n            bits: Optional[int] = None,\n            rope_scaling: Dict[str, Union[str, float]] = None,\n            attention_bias: bool = False,\n            initialization_of_moe: bool = False,\n            **kwargs,\n    ):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It allows the class to initialize the attributes of a class.\n        The self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\n        :param self: Represent the instance of the class\n        :param vocab_size: Define the size of the vocabulary\n        :param hidden_size: Determine the size of the embedding layers\n        :param intermediate_size: Define the size of the intermediate layer in each transformer block\n        :param num_hidden_layers: Determine the number of layers in the encoder and decoder\n        :param num_attention_heads: Determine the number of attention heads in each layer\n        :param num_key_value_heads: Specify the number of heads for key and value\n        :param hidden_act: Specify the activation function used in the hidden layers\n        :param max_position_embeddings: Set the maximum length of the sequence\n        :param initializer_range: Initialize the weights of the model\n        :param rms_norm_eps: Avoid division by zero in the rms normalization\n        :param use_cache: Determine whether to use the cache in the decoder\n        :param pad_token_id: Specify the token id of the padding token\n        :param bos_token_id: Specify the beginning of sentence token id\n        :param eos_token_id: Specify the end of sentence token\n        :param tie_word_embeddings: Tie the word embeddings and the output layer\n        :param rope_theta: Control the number of tokens in a rope\n        :param sliding_window: Control the number of tokens that are processed in parallel\n        :param gradient_checkpointing: str: Specify whether to use gradient checkpointing\n        :param use_pjit_attention_force: bool: Force the use of pjit attention\n        :param use_sacn_mlp: bool: Determine whether or not to use the scan_mlp function\n        :param scan_mlp_chunk_size: int: Specify the chunk size of the scan mlp\n        :param number_rep_kv: int: Specify the number of times to repeat the key and value vectors\n        :param c_max_position_embeddings: int: Set the maximum number of tokens in a sequence\n        :param freq_max_position_embeddings: int: Set the maximum number of frequency bins that can be used in the model\n        :param bits: Optional[int]: Specify the number of bits used for quantization\n        :param axis_dims: Sequence[int]: Specify the dimension of each axis\n        :param axis_names: Sequence[str]: Specify the names of each axis in the tensor\n        :param &amp;quot;mp&amp;quot;): Define the maximum position embeddings\n        :param kwargs: Pass a variable number of keyword arguments to a function\n        :param rope_scaling: Dict[str, Union[str, float]]: rope scaling information\n        :param attention_dropout: float: Set the dropout rate for the attention layer\n        :param initialization_of_moe: bool: initialization of moe needs to disable some dynamic part's this boolean\n         variable will turn them off.\n        :param attention_bias: bool: when ever to use attention_bias\n        :param : Define the number of layers in the model\n        :return: An instance of the class\n\n        \"\"\"\n        self.vocab_size = vocab_size\n        self.max_position_embeddings = max_position_embeddings\n        self.hidden_size = hidden_size\n        self.intermediate_size = intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.sliding_window = sliding_window\n        self.bits = bits\n        self.attention_dropout = attention_dropout\n        self.num_local_experts = num_local_experts\n        self.num_experts_per_tok = num_experts_per_tok\n        self.output_router_logits = output_router_logits\n        self.router_aux_loss_coef = router_aux_loss_coef\n        self.attention_bias = attention_bias\n        # for backward compatibility\n        self.rope_scaling = rope_scaling\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n\n        self.num_key_value_heads = num_key_value_heads\n        self.hidden_act = hidden_act\n        self.initialization_of_moe = initialization_of_moe\n        self.initializer_range = initializer_range\n        self.rms_norm_eps = rms_norm_eps\n        self.use_cache = use_cache\n        self.rope_theta = rope_theta\n        self.number_rep_kv = number_rep_kv\n        self.gradient_checkpointing = gradient_checkpointing\n        self.use_pjit_attention_force = use_pjit_attention_force\n        self.use_sacn_mlp = use_sacn_mlp\n        self.scan_mlp_chunk_size = scan_mlp_chunk_size\n        self.c_max_position_embeddings = c_max_position_embeddings\n        self.freq_max_position_embeddings = freq_max_position_embeddings\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs,\n        )\n\n    @staticmethod\n    def get_partition_rules(fully_sharded_data_parallel: bool = True):\n        \"\"\"\n        The get_partition_rules function is used to define the partitioning scheme for a model.\n        It returns a list of tuples, where each tuple contains two elements:\n          1) A regex string that matches the name of one or more parameters in the model.\n          2) A PartitionScheme object that defines how those parameters should be partitioned.\n\n        :param fully_sharded_data_parallel: bool: Determine whether to use the fully_sharded_data_parallel partitioning scheme or not\n        :return: A list of tuples\n\n        \"\"\"\n        return (\n\n            (\"model/embed_tokens/embedding\", PartitionSpec(\"sp\", \"fsdp\")),\n\n            (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec(\"fsdp\", \"sp\")),\n            (\"self_attn/o_proj/kernel\", PartitionSpec(\"sp\", \"fsdp\")),\n\n            (\"mlp/w1/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/w2/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/w3/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"input_layernorm/kernel\", PartitionSpec(None)),\n            (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n            (\"model/norm/kernel\", PartitionSpec(None)),\n            (\"lm_head/kernel\", PartitionSpec(\"fsdp\", \"sp\")),\n            (\".*\", PartitionSpec(None)),\n        ) if not fully_sharded_data_parallel else (\n            (\"model/embed_tokens/embedding\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"self_attn/o_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"mlp/w1/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/w2/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/w3/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"input_layernorm/kernel\", PartitionSpec(None)),\n            (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n            (\"model/norm/kernel\", PartitionSpec(None)),\n            (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\".*\", PartitionSpec((\"fsdp\", \"sp\"))),\n        )\n\n    def add_jax_args(\n            self,\n            gradient_checkpointing: str = 'nothing_saveable',\n            use_pjit_attention_force: bool = False,\n            use_sacn_mlp: bool = False,\n            scan_mlp_chunk_size: int = 1024,\n            number_rep_kv: int = 1,\n            c_max_position_embeddings: int = 4096,\n            freq_max_position_embeddings: int = None,\n            bits: Optional[int] = None,\n            attention_dropout: float = 0.0,\n            rope_scaling: Dict[str, Union[str, float]] = None,\n            attention_bias: bool = False,\n            initialization_of_moe: bool = False,\n            **kwargs,\n    ):\n        \"\"\"\n        The add_jax_args function adds the following arguments to the model:\n\n        :param self: Bind the attributes and methods of a class to an instance of that class\n        :param gradient_checkpointing: str: Determine whether to use gradient checkpointing\n        :param use_pjit_attention_force: bool: Determine whether to use the pjit_attention_force function\n        :param use_sacn_mlp: bool: Determine whether to use the scan_mlp function or not\n        :param scan_mlp_chunk_size: int: Chunk the input to the mlp\n        :param number_rep_kv: int: Control the number of times that the key and value vectors are repeated\n        :param c_max_position_embeddings: int: Set the maximum number of positional embeddings for the causal axis\n        :param freq_max_position_embeddings: int: Set the maximum length of the frequency axis\n        :param bits: Optional[int]: Specify the number of bits to use for quantization\n        :param attention_dropout: float: Set the dropout rate for the attention layer\n        :param attention_bias: bool: when ever to use attention_bias\n        :param initialization_of_moe: bool: initialization of moe needs to disable some dynamic part's this boolean\n         variable will turn them off.\n        :param rope_scaling: Dict[str, Union[str, float]]: rope_scaling for rope\n        :return: A tuple of the following:\n\n        \"\"\"\n        self.attention_dropout = attention_dropout\n        self.attention_bias = attention_bias\n        self.rope_scaling = rope_scaling\n        self.number_rep_kv = number_rep_kv\n        self.gradient_checkpointing = gradient_checkpointing\n        self.use_pjit_attention_force = use_pjit_attention_force\n        self.use_sacn_mlp = use_sacn_mlp\n        self.scan_mlp_chunk_size = scan_mlp_chunk_size\n        self.c_max_position_embeddings = c_max_position_embeddings\n        self.freq_max_position_embeddings = freq_max_position_embeddings\n        self.bits = bits\n        self.initialization_of_moe = initialization_of_moe\n\n    @staticmethod\n    def get_weight_decay_exclusions():\n        return tuple()\n\n    @staticmethod\n    def rng_keys():\n        return 'params', 'dropout', 'fcm'\n</code></pre>"},{"location":"generated-modules-mixtral-mixtral_configuration/#lib.python.EasyDel.modules.mixtral.mixtral_configuration.MixtralConfig.__init__","title":"<code>__init__(vocab_size=32000, hidden_size=4096, intermediate_size=14336, num_hidden_layers=32, num_attention_heads=32, num_key_value_heads=8, hidden_act='silu', max_position_embeddings=4096 * 32, initializer_range=0.02, rms_norm_eps=1e-05, use_cache=True, pad_token_id=None, bos_token_id=1, eos_token_id=2, tie_word_embeddings=False, rope_theta=1000000.0, sliding_window=4096, attention_dropout=0.0, num_experts_per_tok=2, num_local_experts=8, output_router_logits=False, router_aux_loss_coef=0.001, gradient_checkpointing='nothing_saveable', use_pjit_attention_force=False, use_sacn_mlp=False, scan_mlp_chunk_size=1024, number_rep_kv=1, c_max_position_embeddings=4096, freq_max_position_embeddings=4096, bits=None, rope_scaling=None, attention_bias=False, initialization_of_moe=False, **kwargs)</code>","text":"<p>The init function is called when the class is instantiated. It allows the class to initialize the attributes of a class. The self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>vocab_size</code> <p>Define the size of the vocabulary</p> <code>32000</code> <code>hidden_size</code> <p>Determine the size of the embedding layers</p> <code>4096</code> <code>intermediate_size</code> <p>Define the size of the intermediate layer in each transformer block</p> <code>14336</code> <code>num_hidden_layers</code> <p>Determine the number of layers in the encoder and decoder</p> <code>32</code> <code>num_attention_heads</code> <p>Determine the number of attention heads in each layer</p> <code>32</code> <code>num_key_value_heads</code> <p>Specify the number of heads for key and value</p> <code>8</code> <code>hidden_act</code> <p>Specify the activation function used in the hidden layers</p> <code>'silu'</code> <code>max_position_embeddings</code> <p>Set the maximum length of the sequence</p> <code>4096 * 32</code> <code>initializer_range</code> <p>Initialize the weights of the model</p> <code>0.02</code> <code>rms_norm_eps</code> <p>Avoid division by zero in the rms normalization</p> <code>1e-05</code> <code>use_cache</code> <p>Determine whether to use the cache in the decoder</p> <code>True</code> <code>pad_token_id</code> <p>Specify the token id of the padding token</p> <code>None</code> <code>bos_token_id</code> <p>Specify the beginning of sentence token id</p> <code>1</code> <code>eos_token_id</code> <p>Specify the end of sentence token</p> <code>2</code> <code>tie_word_embeddings</code> <p>Tie the word embeddings and the output layer</p> <code>False</code> <code>rope_theta</code> <p>Control the number of tokens in a rope</p> <code>1000000.0</code> <code>sliding_window</code> <p>Control the number of tokens that are processed in parallel</p> <code>4096</code> <code>gradient_checkpointing</code> <code>str</code> <p>str: Specify whether to use gradient checkpointing</p> <code>'nothing_saveable'</code> <code>use_pjit_attention_force</code> <code>bool</code> <p>bool: Force the use of pjit attention</p> <code>False</code> <code>use_sacn_mlp</code> <code>bool</code> <p>bool: Determine whether or not to use the scan_mlp function</p> <code>False</code> <code>scan_mlp_chunk_size</code> <code>int</code> <p>int: Specify the chunk size of the scan mlp</p> <code>1024</code> <code>number_rep_kv</code> <code>int</code> <p>int: Specify the number of times to repeat the key and value vectors</p> <code>1</code> <code>c_max_position_embeddings</code> <code>int</code> <p>int: Set the maximum number of tokens in a sequence</p> <code>4096</code> <code>freq_max_position_embeddings</code> <code>int</code> <p>int: Set the maximum number of frequency bins that can be used in the model</p> <code>4096</code> <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Specify the number of bits used for quantization</p> <code>None</code> <code>axis_dims</code> <p>Sequence[int]: Specify the dimension of each axis</p> required <code>axis_names</code> <p>Sequence[str]: Specify the names of each axis in the tensor</p> required <code>&amp;quot;mp&amp;quot;)</code> <p>Define the maximum position embeddings</p> required <code>kwargs</code> <p>Pass a variable number of keyword arguments to a function</p> <code>{}</code> <code>rope_scaling</code> <code>Dict[str, Union[str, float]]</code> <p>Dict[str, Union[str, float]]: rope scaling information</p> <code>None</code> <code>attention_dropout</code> <p>float: Set the dropout rate for the attention layer</p> <code>0.0</code> <code>initialization_of_moe</code> <code>bool</code> <p>bool: initialization of moe needs to disable some dynamic part's this boolean variable will turn them off.</p> <code>False</code> <code>attention_bias</code> <code>bool</code> <p>bool: when ever to use attention_bias</p> <code>False</code> <code></code> <p>Define the number of layers in the model</p> required <p>Returns:</p> Type Description <p>An instance of the class</p> Source code in <code>lib/python/EasyDel/modules/mixtral/mixtral_configuration.py</code> <pre><code>def __init__(\n        self,\n        vocab_size=32000,\n        hidden_size=4096,\n        intermediate_size=14336,\n        num_hidden_layers=32,\n        num_attention_heads=32,\n        num_key_value_heads=8,\n        hidden_act=\"silu\",\n        max_position_embeddings=4096 * 32,\n        initializer_range=0.02,\n        rms_norm_eps=1e-5,\n        use_cache=True,\n        pad_token_id=None,\n        bos_token_id=1,\n        eos_token_id=2,\n        tie_word_embeddings=False,\n        rope_theta=1e6,\n        sliding_window=4096,\n        attention_dropout=0.0,\n        num_experts_per_tok=2,\n        num_local_experts=8,\n        output_router_logits=False,\n        router_aux_loss_coef=0.001,\n        gradient_checkpointing: str = 'nothing_saveable',\n        use_pjit_attention_force: bool = False,\n        use_sacn_mlp: bool = False,\n        scan_mlp_chunk_size: int = 1024,\n        number_rep_kv: int = 1,\n        c_max_position_embeddings: int = 4096,\n        freq_max_position_embeddings: int = 4096,\n        bits: Optional[int] = None,\n        rope_scaling: Dict[str, Union[str, float]] = None,\n        attention_bias: bool = False,\n        initialization_of_moe: bool = False,\n        **kwargs,\n):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It allows the class to initialize the attributes of a class.\n    The self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\n    :param self: Represent the instance of the class\n    :param vocab_size: Define the size of the vocabulary\n    :param hidden_size: Determine the size of the embedding layers\n    :param intermediate_size: Define the size of the intermediate layer in each transformer block\n    :param num_hidden_layers: Determine the number of layers in the encoder and decoder\n    :param num_attention_heads: Determine the number of attention heads in each layer\n    :param num_key_value_heads: Specify the number of heads for key and value\n    :param hidden_act: Specify the activation function used in the hidden layers\n    :param max_position_embeddings: Set the maximum length of the sequence\n    :param initializer_range: Initialize the weights of the model\n    :param rms_norm_eps: Avoid division by zero in the rms normalization\n    :param use_cache: Determine whether to use the cache in the decoder\n    :param pad_token_id: Specify the token id of the padding token\n    :param bos_token_id: Specify the beginning of sentence token id\n    :param eos_token_id: Specify the end of sentence token\n    :param tie_word_embeddings: Tie the word embeddings and the output layer\n    :param rope_theta: Control the number of tokens in a rope\n    :param sliding_window: Control the number of tokens that are processed in parallel\n    :param gradient_checkpointing: str: Specify whether to use gradient checkpointing\n    :param use_pjit_attention_force: bool: Force the use of pjit attention\n    :param use_sacn_mlp: bool: Determine whether or not to use the scan_mlp function\n    :param scan_mlp_chunk_size: int: Specify the chunk size of the scan mlp\n    :param number_rep_kv: int: Specify the number of times to repeat the key and value vectors\n    :param c_max_position_embeddings: int: Set the maximum number of tokens in a sequence\n    :param freq_max_position_embeddings: int: Set the maximum number of frequency bins that can be used in the model\n    :param bits: Optional[int]: Specify the number of bits used for quantization\n    :param axis_dims: Sequence[int]: Specify the dimension of each axis\n    :param axis_names: Sequence[str]: Specify the names of each axis in the tensor\n    :param &amp;quot;mp&amp;quot;): Define the maximum position embeddings\n    :param kwargs: Pass a variable number of keyword arguments to a function\n    :param rope_scaling: Dict[str, Union[str, float]]: rope scaling information\n    :param attention_dropout: float: Set the dropout rate for the attention layer\n    :param initialization_of_moe: bool: initialization of moe needs to disable some dynamic part's this boolean\n     variable will turn them off.\n    :param attention_bias: bool: when ever to use attention_bias\n    :param : Define the number of layers in the model\n    :return: An instance of the class\n\n    \"\"\"\n    self.vocab_size = vocab_size\n    self.max_position_embeddings = max_position_embeddings\n    self.hidden_size = hidden_size\n    self.intermediate_size = intermediate_size\n    self.num_hidden_layers = num_hidden_layers\n    self.num_attention_heads = num_attention_heads\n    self.sliding_window = sliding_window\n    self.bits = bits\n    self.attention_dropout = attention_dropout\n    self.num_local_experts = num_local_experts\n    self.num_experts_per_tok = num_experts_per_tok\n    self.output_router_logits = output_router_logits\n    self.router_aux_loss_coef = router_aux_loss_coef\n    self.attention_bias = attention_bias\n    # for backward compatibility\n    self.rope_scaling = rope_scaling\n    if num_key_value_heads is None:\n        num_key_value_heads = num_attention_heads\n\n    self.num_key_value_heads = num_key_value_heads\n    self.hidden_act = hidden_act\n    self.initialization_of_moe = initialization_of_moe\n    self.initializer_range = initializer_range\n    self.rms_norm_eps = rms_norm_eps\n    self.use_cache = use_cache\n    self.rope_theta = rope_theta\n    self.number_rep_kv = number_rep_kv\n    self.gradient_checkpointing = gradient_checkpointing\n    self.use_pjit_attention_force = use_pjit_attention_force\n    self.use_sacn_mlp = use_sacn_mlp\n    self.scan_mlp_chunk_size = scan_mlp_chunk_size\n    self.c_max_position_embeddings = c_max_position_embeddings\n    self.freq_max_position_embeddings = freq_max_position_embeddings\n\n    super().__init__(\n        pad_token_id=pad_token_id,\n        bos_token_id=bos_token_id,\n        eos_token_id=eos_token_id,\n        tie_word_embeddings=tie_word_embeddings,\n        **kwargs,\n    )\n</code></pre>"},{"location":"generated-modules-mixtral-mixtral_configuration/#lib.python.EasyDel.modules.mixtral.mixtral_configuration.MixtralConfig.add_jax_args","title":"<code>add_jax_args(gradient_checkpointing='nothing_saveable', use_pjit_attention_force=False, use_sacn_mlp=False, scan_mlp_chunk_size=1024, number_rep_kv=1, c_max_position_embeddings=4096, freq_max_position_embeddings=None, bits=None, attention_dropout=0.0, rope_scaling=None, attention_bias=False, initialization_of_moe=False, **kwargs)</code>","text":"<p>The add_jax_args function adds the following arguments to the model:</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Bind the attributes and methods of a class to an instance of that class</p> required <code>gradient_checkpointing</code> <code>str</code> <p>str: Determine whether to use gradient checkpointing</p> <code>'nothing_saveable'</code> <code>use_pjit_attention_force</code> <code>bool</code> <p>bool: Determine whether to use the pjit_attention_force function</p> <code>False</code> <code>use_sacn_mlp</code> <code>bool</code> <p>bool: Determine whether to use the scan_mlp function or not</p> <code>False</code> <code>scan_mlp_chunk_size</code> <code>int</code> <p>int: Chunk the input to the mlp</p> <code>1024</code> <code>number_rep_kv</code> <code>int</code> <p>int: Control the number of times that the key and value vectors are repeated</p> <code>1</code> <code>c_max_position_embeddings</code> <code>int</code> <p>int: Set the maximum number of positional embeddings for the causal axis</p> <code>4096</code> <code>freq_max_position_embeddings</code> <code>int</code> <p>int: Set the maximum length of the frequency axis</p> <code>None</code> <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Specify the number of bits to use for quantization</p> <code>None</code> <code>attention_dropout</code> <code>float</code> <p>float: Set the dropout rate for the attention layer</p> <code>0.0</code> <code>attention_bias</code> <code>bool</code> <p>bool: when ever to use attention_bias</p> <code>False</code> <code>initialization_of_moe</code> <code>bool</code> <p>bool: initialization of moe needs to disable some dynamic part's this boolean variable will turn them off.</p> <code>False</code> <code>rope_scaling</code> <code>Dict[str, Union[str, float]]</code> <p>Dict[str, Union[str, float]]: rope_scaling for rope</p> <code>None</code> <p>Returns:</p> Type Description <p>A tuple of the following:</p> Source code in <code>lib/python/EasyDel/modules/mixtral/mixtral_configuration.py</code> <pre><code>def add_jax_args(\n        self,\n        gradient_checkpointing: str = 'nothing_saveable',\n        use_pjit_attention_force: bool = False,\n        use_sacn_mlp: bool = False,\n        scan_mlp_chunk_size: int = 1024,\n        number_rep_kv: int = 1,\n        c_max_position_embeddings: int = 4096,\n        freq_max_position_embeddings: int = None,\n        bits: Optional[int] = None,\n        attention_dropout: float = 0.0,\n        rope_scaling: Dict[str, Union[str, float]] = None,\n        attention_bias: bool = False,\n        initialization_of_moe: bool = False,\n        **kwargs,\n):\n    \"\"\"\n    The add_jax_args function adds the following arguments to the model:\n\n    :param self: Bind the attributes and methods of a class to an instance of that class\n    :param gradient_checkpointing: str: Determine whether to use gradient checkpointing\n    :param use_pjit_attention_force: bool: Determine whether to use the pjit_attention_force function\n    :param use_sacn_mlp: bool: Determine whether to use the scan_mlp function or not\n    :param scan_mlp_chunk_size: int: Chunk the input to the mlp\n    :param number_rep_kv: int: Control the number of times that the key and value vectors are repeated\n    :param c_max_position_embeddings: int: Set the maximum number of positional embeddings for the causal axis\n    :param freq_max_position_embeddings: int: Set the maximum length of the frequency axis\n    :param bits: Optional[int]: Specify the number of bits to use for quantization\n    :param attention_dropout: float: Set the dropout rate for the attention layer\n    :param attention_bias: bool: when ever to use attention_bias\n    :param initialization_of_moe: bool: initialization of moe needs to disable some dynamic part's this boolean\n     variable will turn them off.\n    :param rope_scaling: Dict[str, Union[str, float]]: rope_scaling for rope\n    :return: A tuple of the following:\n\n    \"\"\"\n    self.attention_dropout = attention_dropout\n    self.attention_bias = attention_bias\n    self.rope_scaling = rope_scaling\n    self.number_rep_kv = number_rep_kv\n    self.gradient_checkpointing = gradient_checkpointing\n    self.use_pjit_attention_force = use_pjit_attention_force\n    self.use_sacn_mlp = use_sacn_mlp\n    self.scan_mlp_chunk_size = scan_mlp_chunk_size\n    self.c_max_position_embeddings = c_max_position_embeddings\n    self.freq_max_position_embeddings = freq_max_position_embeddings\n    self.bits = bits\n    self.initialization_of_moe = initialization_of_moe\n</code></pre>"},{"location":"generated-modules-mixtral-mixtral_configuration/#lib.python.EasyDel.modules.mixtral.mixtral_configuration.MixtralConfig.get_partition_rules","title":"<code>get_partition_rules(fully_sharded_data_parallel=True)</code>  <code>staticmethod</code>","text":"<p>The get_partition_rules function is used to define the partitioning scheme for a model. It returns a list of tuples, where each tuple contains two elements:   1) A regex string that matches the name of one or more parameters in the model.   2) A PartitionScheme object that defines how those parameters should be partitioned.</p> <p>Parameters:</p> Name Type Description Default <code>fully_sharded_data_parallel</code> <code>bool</code> <p>bool: Determine whether to use the fully_sharded_data_parallel partitioning scheme or not</p> <code>True</code> <p>Returns:</p> Type Description <p>A list of tuples</p> Source code in <code>lib/python/EasyDel/modules/mixtral/mixtral_configuration.py</code> <pre><code>@staticmethod\ndef get_partition_rules(fully_sharded_data_parallel: bool = True):\n    \"\"\"\n    The get_partition_rules function is used to define the partitioning scheme for a model.\n    It returns a list of tuples, where each tuple contains two elements:\n      1) A regex string that matches the name of one or more parameters in the model.\n      2) A PartitionScheme object that defines how those parameters should be partitioned.\n\n    :param fully_sharded_data_parallel: bool: Determine whether to use the fully_sharded_data_parallel partitioning scheme or not\n    :return: A list of tuples\n\n    \"\"\"\n    return (\n\n        (\"model/embed_tokens/embedding\", PartitionSpec(\"sp\", \"fsdp\")),\n\n        (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec(\"fsdp\", \"sp\")),\n        (\"self_attn/o_proj/kernel\", PartitionSpec(\"sp\", \"fsdp\")),\n\n        (\"mlp/w1/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/w2/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/w3/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"input_layernorm/kernel\", PartitionSpec(None)),\n        (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n        (\"model/norm/kernel\", PartitionSpec(None)),\n        (\"lm_head/kernel\", PartitionSpec(\"fsdp\", \"sp\")),\n        (\".*\", PartitionSpec(None)),\n    ) if not fully_sharded_data_parallel else (\n        (\"model/embed_tokens/embedding\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"self_attn/o_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"mlp/w1/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/w2/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/w3/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"input_layernorm/kernel\", PartitionSpec(None)),\n        (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n        (\"model/norm/kernel\", PartitionSpec(None)),\n        (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\".*\", PartitionSpec((\"fsdp\", \"sp\"))),\n    )\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/","title":"modules.mixtral.modelling_mixtral_flax","text":""},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralAttention","title":"<code>FlaxMixtralAttention</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>class FlaxMixtralAttention(nn.Module):\n    config: MixtralConfig\n    layer_index: int\n    dtype: jnp.dtype = jnp.bfloat16\n    param_dtype: jnp.dtype = jnp.bfloat16\n    precision: Optional[Union[None, jax.lax.Precision]\n                        ] = jax.lax.Precision(\"fastest\")\n\n    def setup(self) -&gt; None:\n        config = self.config\n        self.hidden_size = config.hidden_size\n        self.num_heads = config.num_attention_heads\n        self.head_dim = self.hidden_size // self.num_heads\n        self.num_key_value_heads = config.num_key_value_heads\n        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n        self.max_position_embeddings = config.max_position_embeddings\n\n        dense = functools.partial(\n            nn.Dense,\n            use_bias=getattr(self.config, \"attention_bias\", False),\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision,\n            kernel_init=nn.initializers.normal(),\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n\n        self.q_proj = dense(self.num_heads * self.head_dim)\n        self.k_proj = dense(self.num_key_value_heads * self.head_dim)\n        self.v_proj = dense(self.num_key_value_heads * self.head_dim)\n        self.o_proj = dense(self.hidden_size)\n        self.rotary = FlaxMixtralRotaryEmbedding(self.dtype)\n        self.attention_performer = EasyAttention(\n            attn_type=\"normal\",\n            block_k_major=self.config.block_k_major,\n            block_b=self.config.block_b,\n            block_q=self.config.block_q,\n            block_k=self.config.block_k,\n            block_q_major_dkv=self.config.block_q_major_dkv,\n            block_k_major_dkv=self.config.block_k_major_dkv,\n            block_k_major_dq=self.config.block_k_major_dq,\n            block_k_dkv=self.config.block_k_dkv,\n            block_q_dkv=self.config.block_q_dkv,\n            block_q_dq=self.config.block_q_dq,\n            block_k_dq=self.config.block_k_dq,\n            num_attention_heads=self.config.num_attention_heads,\n            attention_dropout=self.config.attention_dropout,\n            head_dims=self.head_dim,\n            attention_partition_spec=self.config.attention_partition_spec,\n            use_shard_map=self.config.use_shard_map,\n            precision=self.precision,\n            force_float32_tpu=True,\n            attn_mechanism=self.config.attn_mechanism,\n            dtype=self.dtype,\n            bias_partition_spec=self.config.bias_partition_spec,\n            key_partition_spec=self.config.key_partition_spec,\n            query_partition_spec=self.config.query_partition_spec,\n            value_partition_spec=self.config.value_partition_spec,\n            mesh=self.config.jax_mesh(),\n            sm_scale=1 / math.sqrt(self.head_dim)\n        )\n\n    @staticmethod\n    def _t(query, key, value):\n        return jnp.transpose(query, (0, 2, 1, 3)), jnp.transpose(key, (0, 2, 1, 3)), jnp.transpose(value, (0, 2, 1, 3))\n\n    def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n        query = query.reshape(batch_size, sequence_length,\n                              self.config.num_attention_heads, self.head_dim)\n        key = key.reshape(batch_size, sequence_length,\n                          self.config.num_key_value_heads, self.head_dim)\n        value = value.reshape(batch_size, sequence_length,\n                              self.config.num_key_value_heads, self.head_dim)\n\n        query, key, value = self._t(query, key, value)\n        query, key = self.rotary(\n            position_ids=position_ids, query=query, key=key, freq_cis=freq_cis)\n        key = repeat_kv_bnsh(key, self.num_key_value_groups)\n        value = repeat_kv_bnsh(value, self.num_key_value_groups)\n        return self._t(query, key, value)\n\n    def _merge_heads(self, hidden_states):\n        return hidden_states.reshape(hidden_states.shape[:2] + (self.hidden_size,))\n\n    @nn.compact\n    def _concatenate_to_cache(self, key, value, query, attention_mask):\n        \"\"\"\n        The _concatenate_to_cache function is used to concatenate the key and value vectors\n        of a query with those of previous queries. This allows for the attention mechanism to\n        look at all previous queries when computing its output. The function takes in three\n        arguments: key, value, and query. It also uses two variables that are stored in the cache:\n        cached_key and cached_value.\n\n        :param self: Access the variables stored in the cache\n        :param key: Store the keys of the encoder-decoder attention\n        :param value: Initialize the cached_value variable\n        :param query: Determine the number of cache vectors to update\n        :param attention_mask: Mask out the padded vectors in the cache\n        :return: The key, value and attention_mask\n\n        \"\"\"\n        is_initialized = self.has_variable(\"cache\", \"cached_key\")\n        cached_key = self.variable(\n            \"cache\", \"cached_key\", jnp.zeros, key.shape, key.dtype)\n        cached_value = self.variable(\n            \"cache\", \"cached_value\", jnp.zeros, value.shape, value.dtype)\n        cache_index = self.variable(\n            \"cache\", \"cache_index\", lambda: jnp.array(0, dtype=jnp.int32))\n\n        if is_initialized:\n            *batch_dims, max_length, num_heads, depth_per_head = cached_key.value.shape\n            cur_index = cache_index.value\n            indices = (0,) * len(batch_dims) + (cur_index, 0, 0)\n            key = lax.dynamic_update_slice(cached_key.value, key, indices)\n            value = lax.dynamic_update_slice(\n                cached_value.value, value, indices)\n            cached_key.value = key\n            cached_value.value = value\n            num_updated_cache_vectors = query.shape[1]\n            cache_index.value = cache_index.value + num_updated_cache_vectors\n\n            pad_mask = jnp.broadcast_to(\n                jnp.arange(max_length) &lt; cur_index + num_updated_cache_vectors,\n                tuple(batch_dims) + (1, num_updated_cache_vectors, max_length),\n            )\n            attention_mask = combine_masks(pad_mask, attention_mask)\n        return key, value, attention_mask\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            causal_mask: chex.Array,\n            position_ids: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = True\n    ):\n        \"\"\"\n        The __call__ function is the main function of a JAX module.\n        It defines how the module behaves when called as a function, and it's what you'll use to call your model in practice.\n        The __call__ method takes an input tensor (x) and returns an output tensor (y).\n        In this case, we're defining our model to be a simple linear layer with no activation: y = x @ w + b.\n\n        :param self: Refer to the object itself\n        :param hidden_states: chex.Array: Pass in the hidden state of the model\n        :param freq_cis: chex.Array: Create the apply_rotary variable\n        :param attention_mask: chex.Array: Mask the attention weights\n        :param causal_mask: chex.Array: Mask the attention weights\n        :param position_ids: chex.Array: Specify the position of each token in a sequence\n        :param deterministic: bool: Determine whether to use dropout or not\n        :param init_cache: bool: Initialize the cache\n        :param output_attentions: bool: Determine whether to return the attention weights\n        :return: A tuple of (out, attn_output)\n\n        \"\"\"\n        batch_size, sequence_length = hidden_states.shape[:2]\n        query_state, key_state, value_state = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(\n            hidden_states)\n\n        if self.config.use_pjit_attention_force:\n            query_state = with_sharding_constraint(\n                query_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n            key_state = with_sharding_constraint(\n                key_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n            value_state = with_sharding_constraint(\n                value_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n\n        query_state = query_state.reshape(\n            batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n        key_state = key_state.reshape(\n            batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n        value_state = value_state.reshape(\n            batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n        query_state, key_state, value_state = self.apply_rotary(\n            query=query_state,\n            key=key_state,\n            value=value_state,\n            position_ids=position_ids,\n            freq_cis=freq_cis,\n            batch_size=batch_size,\n            sequence_length=sequence_length\n        )\n\n        assert_msg = (\n            \"num_attention_heads repeat wont work likely\\n\"\n            f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n            f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n        )\n\n        assert query_state.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert key_state.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert value_state.shape[-2] == self.config.num_attention_heads, assert_msg\n\n        query_length, key_length = query_state.shape[1], key_state.shape[1]\n\n        if self.has_variable(\"cache\", \"cached_key\"):\n            mask_shift = self.variables[\"cache\"][\"cache_index\"]\n            max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n            causal_mask = lax.dynamic_slice(\n                causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                     query_length, max_decoder_length)\n            )\n        else:\n            causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n        batch_size = hidden_states.shape[0]\n        causal_mask = jnp.broadcast_to(\n            causal_mask, (batch_size,) + causal_mask.shape[1:])\n        attention_mask = jnp.broadcast_to(jnp.expand_dims(\n            attention_mask, axis=(-3, -2)), causal_mask.shape)\n        attention_mask = combine_masks(attention_mask, causal_mask)\n        if attention_mask.ndim == 2:\n            attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n\n        dropout_rng = None\n\n        if not deterministic and self.config.attention_dropout &gt; 0.0:\n            dropout_rng = self.make_rng(\"dropout\")\n\n        if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n            key_state, value_state, attention_mask = self._concatenate_to_cache(\n                key_state,\n                value_state,\n                query_state,\n                attention_mask\n            )\n\n        attention_bias = lax.select(\n            attention_mask &gt; 0,\n            jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n            jnp.full(attention_mask.shape, jnp.finfo(\n                self.dtype).min).astype(self.dtype),\n        )\n\n        query_state, key_state, value_state = map(\n            lambda a: a.transpose(0, 2, 1, 3),\n            [query_state, key_state, value_state]\n        )\n\n        query_length, key_length = query_state.shape[-2], key_state.shape[-2]\n\n        attentions = self.attention_performer.__call__(\n            query_states=query_state,\n            key_states=key_state,\n            value_states=value_state,\n            bias=attention_bias,\n            causal=False,\n            use_pjit_attention_force=self.config.use_pjit_attention_force,\n            dropout_rng=dropout_rng,\n            deterministic=deterministic,\n            query_sequence_length=query_length,\n            key_value_sequence_length=key_length,\n            uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n        )\n        attentions.attention_outputs = attentions.attention_outputs.transpose(\n            0, 2, 1, 3)\n\n        attn_output = self._merge_heads(attentions.attention_outputs)\n        attn_output = self.o_proj(attn_output)\n        outputs = (\n            attn_output, attentions.attention_weights\n        )\n        return outputs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralAttention.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, causal_mask, position_ids, deterministic=True, init_cache=False, output_attentions=True)</code>","text":"<p>The call function is the main function of a JAX module. It defines how the module behaves when called as a function, and it's what you'll use to call your model in practice. The call method takes an input tensor (x) and returns an output tensor (y). In this case, we're defining our model to be a simple linear layer with no activation: y = x @ w + b.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass in the hidden state of the model</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Create the apply_rotary variable</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask the attention weights</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask the attention weights</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in a sequence</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attention weights</p> <code>True</code> <p>Returns:</p> Type Description <p>A tuple of (out, attn_output)</p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        causal_mask: chex.Array,\n        position_ids: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = True\n):\n    \"\"\"\n    The __call__ function is the main function of a JAX module.\n    It defines how the module behaves when called as a function, and it's what you'll use to call your model in practice.\n    The __call__ method takes an input tensor (x) and returns an output tensor (y).\n    In this case, we're defining our model to be a simple linear layer with no activation: y = x @ w + b.\n\n    :param self: Refer to the object itself\n    :param hidden_states: chex.Array: Pass in the hidden state of the model\n    :param freq_cis: chex.Array: Create the apply_rotary variable\n    :param attention_mask: chex.Array: Mask the attention weights\n    :param causal_mask: chex.Array: Mask the attention weights\n    :param position_ids: chex.Array: Specify the position of each token in a sequence\n    :param deterministic: bool: Determine whether to use dropout or not\n    :param init_cache: bool: Initialize the cache\n    :param output_attentions: bool: Determine whether to return the attention weights\n    :return: A tuple of (out, attn_output)\n\n    \"\"\"\n    batch_size, sequence_length = hidden_states.shape[:2]\n    query_state, key_state, value_state = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(\n        hidden_states)\n\n    if self.config.use_pjit_attention_force:\n        query_state = with_sharding_constraint(\n            query_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n        key_state = with_sharding_constraint(\n            key_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n        value_state = with_sharding_constraint(\n            value_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n\n    query_state = query_state.reshape(\n        batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n    key_state = key_state.reshape(\n        batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n    value_state = value_state.reshape(\n        batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n    query_state, key_state, value_state = self.apply_rotary(\n        query=query_state,\n        key=key_state,\n        value=value_state,\n        position_ids=position_ids,\n        freq_cis=freq_cis,\n        batch_size=batch_size,\n        sequence_length=sequence_length\n    )\n\n    assert_msg = (\n        \"num_attention_heads repeat wont work likely\\n\"\n        f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n        f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n    )\n\n    assert query_state.shape[-2] == self.config.num_attention_heads, assert_msg\n    assert key_state.shape[-2] == self.config.num_attention_heads, assert_msg\n    assert value_state.shape[-2] == self.config.num_attention_heads, assert_msg\n\n    query_length, key_length = query_state.shape[1], key_state.shape[1]\n\n    if self.has_variable(\"cache\", \"cached_key\"):\n        mask_shift = self.variables[\"cache\"][\"cache_index\"]\n        max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n        causal_mask = lax.dynamic_slice(\n            causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                 query_length, max_decoder_length)\n        )\n    else:\n        causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n    batch_size = hidden_states.shape[0]\n    causal_mask = jnp.broadcast_to(\n        causal_mask, (batch_size,) + causal_mask.shape[1:])\n    attention_mask = jnp.broadcast_to(jnp.expand_dims(\n        attention_mask, axis=(-3, -2)), causal_mask.shape)\n    attention_mask = combine_masks(attention_mask, causal_mask)\n    if attention_mask.ndim == 2:\n        attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n\n    dropout_rng = None\n\n    if not deterministic and self.config.attention_dropout &gt; 0.0:\n        dropout_rng = self.make_rng(\"dropout\")\n\n    if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n        key_state, value_state, attention_mask = self._concatenate_to_cache(\n            key_state,\n            value_state,\n            query_state,\n            attention_mask\n        )\n\n    attention_bias = lax.select(\n        attention_mask &gt; 0,\n        jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n        jnp.full(attention_mask.shape, jnp.finfo(\n            self.dtype).min).astype(self.dtype),\n    )\n\n    query_state, key_state, value_state = map(\n        lambda a: a.transpose(0, 2, 1, 3),\n        [query_state, key_state, value_state]\n    )\n\n    query_length, key_length = query_state.shape[-2], key_state.shape[-2]\n\n    attentions = self.attention_performer.__call__(\n        query_states=query_state,\n        key_states=key_state,\n        value_states=value_state,\n        bias=attention_bias,\n        causal=False,\n        use_pjit_attention_force=self.config.use_pjit_attention_force,\n        dropout_rng=dropout_rng,\n        deterministic=deterministic,\n        query_sequence_length=query_length,\n        key_value_sequence_length=key_length,\n        uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n    )\n    attentions.attention_outputs = attentions.attention_outputs.transpose(\n        0, 2, 1, 3)\n\n    attn_output = self._merge_heads(attentions.attention_outputs)\n    attn_output = self.o_proj(attn_output)\n    outputs = (\n        attn_output, attentions.attention_weights\n    )\n    return outputs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralDecoderLayer","title":"<code>FlaxMixtralDecoderLayer</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>class FlaxMixtralDecoderLayer(nn.Module):\n    config: MixtralConfig\n    layer_index: int\n    dtype: jnp.dtype = jnp.bfloat16\n    param_dtype: jnp.dtype = jnp.bfloat16\n    precision: Optional[Union[None, jax.lax.Precision]\n                        ] = jax.lax.Precision(\"fastest\")\n\n    def setup(self) -&gt; None:\n        self.self_attn = FlaxMixtralAttention(\n            config=self.config,\n            layer_index=self.layer_index,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        self.block_sparse_moe = FlaxMixtralSparseMoeBlock(\n            config=self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        self.input_layernorm = MixtralRMSNorm(\n            dim=self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype\n        )\n        self.post_attention_layernorm = MixtralRMSNorm(\n            dim=self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype\n        )\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            causal_mask: chex.Array,\n            position_ids: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = True,\n            output_router_logits: Optional[bool] = False,\n    ):\n        \"\"\"\n        The __call__ function is the main function of a TransformerEncoderLayer.\n        It takes in the following arguments:\n            hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed by all sublayers.\n            freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector, used for computing self-attention weights and biases in a more efficient manner than using position embeddings or sinusoidal positional encoding vectors would allow for [2]. This tensor has shape `(batch_size, num\n\n        :param self: Represent the instance of the class\n        :param hidden_states: chex.Array: Represent the input to the encoder layer\n        :param freq_cis: chex.Array: Pass the frequency information to the attention layer\n        :param attention_mask: chex.Array: Mask out the attention weights for certain positions\n        :param causal_mask: chex.Array: Mask the future tokens\n        :param position_ids: chex.Array: Indicate the position of each token in the sequence\n        :param deterministic: bool: Determine whether to use dropout or not\n        :param init_cache: bool: Initialize the cache for the self-attention layer\n        :param output_attentions: bool: Determine whether to return the attention weights or not\n        :return: A tuple of hidden_states and attention_output\n\n        \"\"\"\n        residual = hidden_states\n        hidden_states = self.input_layernorm(hidden_states)\n        hidden_states, self_attn_weights = self.self_attn(\n            hidden_states=hidden_states,\n            freq_cis=freq_cis,\n            attention_mask=attention_mask,\n            causal_mask=causal_mask,\n            position_ids=position_ids,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions\n        )\n\n        hidden_states = residual + hidden_states\n\n        residual = hidden_states\n        hidden_states = self.post_attention_layernorm(hidden_states)\n        hidden_states, router_logits = self.block_sparse_moe(hidden_states)\n        hidden_states = residual + hidden_states\n\n        outputs = (hidden_states,)\n        if output_attentions:\n            outputs += (self_attn_weights,)\n        if output_router_logits:\n            outputs += (router_logits,)\n        return outputs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralDecoderLayer.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, causal_mask, position_ids, deterministic=True, init_cache=False, output_attentions=True, output_router_logits=False)</code>","text":"<p>The call function is the main function of a TransformerEncoderLayer. It takes in the following arguments:     hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed by all sublayers.     freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector, used for computing self-attention weights and biases in a more efficient manner than using position embeddings or sinusoidal positional encoding vectors would allow for [2]. This tensor has shape `(batch_size, num</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Represent the input to the encoder layer</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass the frequency information to the attention layer</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the attention weights for certain positions</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask the future tokens</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Indicate the position of each token in the sequence</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the self-attention layer</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attention weights or not</p> <code>True</code> <p>Returns:</p> Type Description <p>A tuple of hidden_states and attention_output</p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        causal_mask: chex.Array,\n        position_ids: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = True,\n        output_router_logits: Optional[bool] = False,\n):\n    \"\"\"\n    The __call__ function is the main function of a TransformerEncoderLayer.\n    It takes in the following arguments:\n        hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed by all sublayers.\n        freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector, used for computing self-attention weights and biases in a more efficient manner than using position embeddings or sinusoidal positional encoding vectors would allow for [2]. This tensor has shape `(batch_size, num\n\n    :param self: Represent the instance of the class\n    :param hidden_states: chex.Array: Represent the input to the encoder layer\n    :param freq_cis: chex.Array: Pass the frequency information to the attention layer\n    :param attention_mask: chex.Array: Mask out the attention weights for certain positions\n    :param causal_mask: chex.Array: Mask the future tokens\n    :param position_ids: chex.Array: Indicate the position of each token in the sequence\n    :param deterministic: bool: Determine whether to use dropout or not\n    :param init_cache: bool: Initialize the cache for the self-attention layer\n    :param output_attentions: bool: Determine whether to return the attention weights or not\n    :return: A tuple of hidden_states and attention_output\n\n    \"\"\"\n    residual = hidden_states\n    hidden_states = self.input_layernorm(hidden_states)\n    hidden_states, self_attn_weights = self.self_attn(\n        hidden_states=hidden_states,\n        freq_cis=freq_cis,\n        attention_mask=attention_mask,\n        causal_mask=causal_mask,\n        position_ids=position_ids,\n        deterministic=deterministic,\n        init_cache=init_cache,\n        output_attentions=output_attentions\n    )\n\n    hidden_states = residual + hidden_states\n\n    residual = hidden_states\n    hidden_states = self.post_attention_layernorm(hidden_states)\n    hidden_states, router_logits = self.block_sparse_moe(hidden_states)\n    hidden_states = residual + hidden_states\n\n    outputs = (hidden_states,)\n    if output_attentions:\n        outputs += (self_attn_weights,)\n    if output_router_logits:\n        outputs += (router_logits,)\n    return outputs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralDecoderLayerCollection","title":"<code>FlaxMixtralDecoderLayerCollection</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>class FlaxMixtralDecoderLayerCollection(nn.Module):\n    config: MixtralConfig\n    dtype: jnp.dtype = jnp.bfloat16\n    param_dtype: jnp.dtype = jnp.bfloat16\n    precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\")\n\n    def setup(self) -&gt; None:\n        self.blocks = [\n            FlaxMixtralDecoderLayer(\n                layer_index=layer_index,\n                config=self.config,\n                dtype=self.dtype,\n                param_dtype=self.param_dtype,\n                precision=self.precision,\n                name=str(layer_index)\n            )\n\n            for layer_index in range(self.config.num_hidden_layers)\n        ]\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            causal_mask: chex.Array,\n            position_ids: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_hidden_states: Optional[bool] = False,\n            output_attentions: Optional[bool] = False,\n            output_router_logits: Optional[bool] = False,\n    ):\n        \"\"\"\n        The __call__ function is the main function of a TransformerEncoderLayer.\n        It takes in the following arguments:\n            hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed by all sublayers.\n            freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector, used for computing self-attention weights and biases in a more efficient manner than using position embeddings or sinusoidal positional encoding vectors would allow for [2]. This tensor has shape `(batch_size, num\n\n        :param self: Represent the instance of the class\n        :param hidden_states: chex.Array: Represent the input to the encoder layer\n        :param freq_cis: chex.Array: Pass the frequency information to the attention layer\n        :param attention_mask: chex.Array: Mask out the attention weights for certain positions\n        :param causal_mask: chex.Array: Mask the future tokens\n        :param position_ids: chex.Array: Indicate the position of each token in the sequence\n        :param deterministic: bool: Determine whether to use dropout or not\n        :param init_cache: bool: Initialize the cache for the self-attention layer\n        :param output_attentions: bool: Determine whether to return the attention weights or not\n        :return: A tuple of hidden_states, attention_output, all_hidden_states and all_router_logits\n\n        \"\"\"\n        all_hidden_states = () if output_hidden_states else None\n        all_self_attns = () if output_attentions else None\n        all_router_logits = () if output_router_logits else None\n\n        for block in self.blocks:\n            if output_hidden_states:\n                all_hidden_states += (hidden_states,)\n            layer_outputs = block(\n                hidden_states=hidden_states,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                output_attentions=output_attentions,\n                output_router_logits=output_router_logits,\n                init_cache=init_cache,\n                freq_cis=freq_cis,\n                causal_mask=causal_mask,\n                deterministic=deterministic,\n            )\n\n            hidden_states = layer_outputs[0]\n\n            if output_attentions:\n                all_self_attns += (layer_outputs[1],)\n\n            if output_router_logits:\n                all_router_logits += (layer_outputs[-1],)\n\n        outputs = (hidden_states,)\n        if output_attentions:\n            outputs += (all_self_attns,)\n        if output_hidden_states:\n            outputs += (all_hidden_states,)\n        if output_router_logits:\n            outputs += (all_router_logits,)\n        return outputs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralDecoderLayerCollection.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, causal_mask, position_ids, deterministic=True, init_cache=False, output_hidden_states=False, output_attentions=False, output_router_logits=False)</code>","text":"<p>The call function is the main function of a TransformerEncoderLayer. It takes in the following arguments:     hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed by all sublayers.     freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector, used for computing self-attention weights and biases in a more efficient manner than using position embeddings or sinusoidal positional encoding vectors would allow for [2]. This tensor has shape `(batch_size, num</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Represent the input to the encoder layer</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass the frequency information to the attention layer</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the attention weights for certain positions</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask the future tokens</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Indicate the position of each token in the sequence</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the self-attention layer</p> <code>False</code> <code>output_attentions</code> <code>Optional[bool]</code> <p>bool: Determine whether to return the attention weights or not</p> <code>False</code> <p>Returns:</p> Type Description <p>A tuple of hidden_states, attention_output, all_hidden_states and all_router_logits</p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        causal_mask: chex.Array,\n        position_ids: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_hidden_states: Optional[bool] = False,\n        output_attentions: Optional[bool] = False,\n        output_router_logits: Optional[bool] = False,\n):\n    \"\"\"\n    The __call__ function is the main function of a TransformerEncoderLayer.\n    It takes in the following arguments:\n        hidden_states (chex.Array): The input to the encoder layer, which is also its output after being processed by all sublayers.\n        freq_cis (chex.Array): A tensor containing frequency-domain representations of each token's context vector, used for computing self-attention weights and biases in a more efficient manner than using position embeddings or sinusoidal positional encoding vectors would allow for [2]. This tensor has shape `(batch_size, num\n\n    :param self: Represent the instance of the class\n    :param hidden_states: chex.Array: Represent the input to the encoder layer\n    :param freq_cis: chex.Array: Pass the frequency information to the attention layer\n    :param attention_mask: chex.Array: Mask out the attention weights for certain positions\n    :param causal_mask: chex.Array: Mask the future tokens\n    :param position_ids: chex.Array: Indicate the position of each token in the sequence\n    :param deterministic: bool: Determine whether to use dropout or not\n    :param init_cache: bool: Initialize the cache for the self-attention layer\n    :param output_attentions: bool: Determine whether to return the attention weights or not\n    :return: A tuple of hidden_states, attention_output, all_hidden_states and all_router_logits\n\n    \"\"\"\n    all_hidden_states = () if output_hidden_states else None\n    all_self_attns = () if output_attentions else None\n    all_router_logits = () if output_router_logits else None\n\n    for block in self.blocks:\n        if output_hidden_states:\n            all_hidden_states += (hidden_states,)\n        layer_outputs = block(\n            hidden_states=hidden_states,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            output_attentions=output_attentions,\n            output_router_logits=output_router_logits,\n            init_cache=init_cache,\n            freq_cis=freq_cis,\n            causal_mask=causal_mask,\n            deterministic=deterministic,\n        )\n\n        hidden_states = layer_outputs[0]\n\n        if output_attentions:\n            all_self_attns += (layer_outputs[1],)\n\n        if output_router_logits:\n            all_router_logits += (layer_outputs[-1],)\n\n    outputs = (hidden_states,)\n    if output_attentions:\n        outputs += (all_self_attns,)\n    if output_hidden_states:\n        outputs += (all_hidden_states,)\n    if output_router_logits:\n        outputs += (all_router_logits,)\n    return outputs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralForCausalLM","title":"<code>FlaxMixtralForCausalLM</code>","text":"<p>             Bases: <code>MixtralPreTrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>class FlaxMixtralForCausalLM(MixtralPreTrainedModel):\n    module_class = FlaxMixtralForCausalLMModule\n\n    def set_input_embeddings(self, value):\n        self.module.model.embed_tokens = value\n\n    def get_input_embeddings(self):\n        return self.module.model.embed_tokens\n\n    def set_decoder(self, decoder):\n        self.module.model = decoder\n\n    def get_decoder(self):\n        return self.module.model\n\n    def get_output_embeddings(self):\n        return self.module.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.module.lm_head = new_embeddings\n\n    def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n        \"\"\"\n        The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.\n\n        :param self: Access variables that belong to the class\n        :param input_ids: Pass in the input tokens\n        :param max_length: Set the length of the sequence to be generated\n        :param attention_mask: Optional[chex.Array]: Mask the attention weights\n        :return: A dictionary of the past_key_values, attention_mask and position ids\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n\n        past_key_values = self.init_cache(batch_size, max_length)\n        extended_attention_mask = jnp.ones(\n            (batch_size, max_length), dtype=\"i4\")\n        if attention_mask is not None:\n            position_ids = attention_mask.cumsum(axis=-1) - 1\n            extended_attention_mask = lax.dynamic_update_slice(\n                extended_attention_mask, attention_mask, (0, 0))\n        else:\n            position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[\n                                            None, :], (batch_size, seq_length))\n\n        return {\n            \"past_key_values\": past_key_values,\n            \"attention_mask\": extended_attention_mask,\n            \"position_ids\": position_ids,\n        }\n\n    def update_inputs_for_generation(self, model_outputs, model_kwargs):\n        model_kwargs[\"past_key_values\"] = model_outputs.past_key_values\n        model_kwargs[\"position_ids\"] = model_kwargs[\"position_ids\"][:, -1:] + 1\n        return model_kwargs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralForCausalLM.prepare_inputs_for_generation","title":"<code>prepare_inputs_for_generation(input_ids, max_length, attention_mask=None)</code>","text":"<p>The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>input_ids</code> <p>Pass in the input tokens</p> required <code>max_length</code> <p>Set the length of the sequence to be generated</p> required <code>attention_mask</code> <code>Optional[Array]</code> <p>Optional[chex.Array]: Mask the attention weights</p> <code>None</code> <p>Returns:</p> Type Description <p>A dictionary of the past_key_values, attention_mask and position ids</p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n    \"\"\"\n    The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.\n\n    :param self: Access variables that belong to the class\n    :param input_ids: Pass in the input tokens\n    :param max_length: Set the length of the sequence to be generated\n    :param attention_mask: Optional[chex.Array]: Mask the attention weights\n    :return: A dictionary of the past_key_values, attention_mask and position ids\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n\n    past_key_values = self.init_cache(batch_size, max_length)\n    extended_attention_mask = jnp.ones(\n        (batch_size, max_length), dtype=\"i4\")\n    if attention_mask is not None:\n        position_ids = attention_mask.cumsum(axis=-1) - 1\n        extended_attention_mask = lax.dynamic_update_slice(\n            extended_attention_mask, attention_mask, (0, 0))\n    else:\n        position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[\n                                        None, :], (batch_size, seq_length))\n\n    return {\n        \"past_key_values\": past_key_values,\n        \"attention_mask\": extended_attention_mask,\n        \"position_ids\": position_ids,\n    }\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.FlaxMixtralSparseMoeBlock","title":"<code>FlaxMixtralSparseMoeBlock</code>","text":"<p>             Bases: <code>Module</code></p> <p>This implementation is strictly equivalent to standard MoE with full capacity (no dropped tokens). It's faster since it formulates MoE operations in terms of block-sparse operations to accomodate imbalanced assignments of tokens to experts, whereas standard MoE either (1) drop tokens at the cost of reduced performance or (2) set capacity factor to number of experts and thus waste computation and memory on padding.</p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>class FlaxMixtralSparseMoeBlock(nn.Module):\n    \"\"\"\n    This implementation is\n    strictly equivalent to standard MoE with full capacity (no\n    dropped tokens). It's faster since it formulates MoE operations\n    in terms of block-sparse operations to accomodate imbalanced\n    assignments of tokens to experts, whereas standard MoE either\n    (1) drop tokens at the cost of reduced performance or (2) set\n    capacity factor to number of experts and thus waste computation\n    and memory on padding.\n    \"\"\"\n    config: MixtralConfig\n    dtype: jnp.dtype = jnp.bfloat16\n    param_dtype: jnp.dtype = jnp.bfloat16\n    precision: Optional[\n        Union[None, jax.lax.Precision]\n    ] = jax.lax.Precision(\"fastest\")\n\n    def setup(self) -&gt; None:\n        self.gate = nn.Dense(\n            self.config.num_local_experts,\n            use_bias=False,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision,\n            kernel_init=nn.initializers.normal(),\n        )\n\n        self.experts = FlaxMixtralBlocKSparesTop2MLPCollection(\n            config=self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n\n    def __call__(self, hidden_states: chex.Array) -&gt; Tuple[chex.Array, chex.Array]:\n        batch_size, sequence_length, hidden_dim = hidden_states.shape\n        hidden_states = hidden_states.reshape(-1, hidden_dim)\n\n        router_logits = self.gate(hidden_states).astype(\n            jnp.promote_types(self.dtype, jnp.float32)\n        )\n\n        routing_weights = jax.nn.softmax(\n            router_logits.astype(\n                jnp.promote_types(self.dtype, jnp.float32)\n            ), axis=1\n        )\n        routing_weights, selected_experts = jax.lax.top_k(\n            routing_weights,\n            k=self.config.num_experts_per_tok\n        )\n        routing_weights /= jnp.sum(\n            routing_weights,\n            axis=-1,\n            keepdims=True\n        )\n        routing_weights = routing_weights.astype(\n            hidden_states.dtype\n        )\n        expert_mask = jax.nn.one_hot(\n            selected_experts, num_classes=self.config.num_local_experts).transpose(2, 1, 0)\n\n        return self.experts(\n            expert_mask=expert_mask,\n            batch_size=batch_size,\n            sequence_length=sequence_length,\n            hidden_dim=hidden_dim,\n            hidden_states=hidden_states,\n            routing_weights=routing_weights\n        ), router_logits\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.MixtralPreTrainedModel","title":"<code>MixtralPreTrainedModel</code>","text":"<p>             Bases: <code>EasyDelFlaxPretrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>class MixtralPreTrainedModel(EasyDelFlaxPretrainedModel):\n    config_class: MixtralConfig = MixtralConfig\n    module_class: nn.Module = None\n    base_model_prefix = \"model\"\n\n    # main_input_name = \"input_ids\"\n\n    def __init__(\n            self,\n            config: MixtralConfig,\n            dtype: jnp.dtype = jnp.bfloat16,\n            param_dtype: jnp.dtype = jnp.bfloat16,\n            precision: Optional[jax.lax.Precision] = jax.lax.Precision(\n                \"fastest\"),\n            input_shape: Tuple[int, int] = (1, 1),\n            seed: int = 0,\n            _do_init: bool = False,\n            **kwargs\n    ):\n        module = self.module_class(\n            config=config,\n            dtype=dtype,\n            param_dtype=param_dtype,\n            precision=precision,\n            **kwargs\n        )\n\n        super().__init__(\n            dtype=dtype, _do_init=_do_init,\n            module=module, config=config, input_shape=input_shape,\n            seed=seed,\n        )\n\n    def init_weights(\n            self,\n            rng: jax.random.PRNGKey,\n            input_shape: Tuple,\n            params: FrozenDict = None\n    ) -&gt; FrozenDict:\n        \"\"\"\n        The init_weights function is used to initialize the weights of a model.\n        It takes in a rng, which is a random number generator key that can be used to generate random numbers.\n        The input_shape parameter specifies the shape of the inputs that will be fed into this model.\n        The params parameter allows you to pass in pre-trained weights for your model, if you have them available.\n\n        :param self: Access variables that belong to the class\n        :param rng: jax.random.PRNGKey: Initialize the weights of the model\n        :param input_shape: Tuple: Initialize the input_ids, attention_mask and position_ids\n        :param params: flax.core.FrozenDict: Pass in the parameters of a pre-trained model\n        :return: A frozendict of parameters\n        \"\"\"\n\n        self.config.initialization_of_moe = True\n        input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n        attention_mask = jnp.ones_like(input_ids, dtype=\"i4\")\n        position_ids = jnp.broadcast_to(\n            jnp.arange(jnp.atleast_2d(input_ids).shape[-1], dtype=\"i4\"),\n            input_shape,\n        )\n        params_rng, dropout_rng = jax.random.split(rng)\n        rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n        if self.config.add_cross_attention:\n            encoder_hidden_states = jnp.zeros(\n                input_shape + (self.config.hidden_size,))\n            encoder_attention_mask = attention_mask\n            module_init_outputs = self.module.init(\n                rngs,\n                input_ids,\n                attention_mask,\n                position_ids,\n                encoder_hidden_states,\n                encoder_attention_mask,\n                return_dict=False,\n            )\n        else:\n            module_init_outputs = self.module.init(\n                rngs,\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                return_dict=False\n            )\n        random_params = module_init_outputs[\"params\"]\n\n        self.config.initialization_of_moe = False\n        if params is not None:\n            random_params = flatten_dict(unfreeze(random_params))\n            params = flatten_dict(unfreeze(params))\n            for missing_key in self._missing_keys:\n                params[missing_key] = random_params[missing_key]\n            self._missing_keys = set()\n            return freeze(unflatten_dict(params))\n        else:\n            return random_params\n\n    def init_cache(self, batch_size, max_length):\n\n        input_ids = jnp.ones((batch_size, max_length))\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(\n            jnp.atleast_2d(input_ids).shape[-1]), input_ids.shape)\n\n        init_variables = self.module.init(\n            jax.random.PRNGKey(0), input_ids, attention_mask, position_ids, return_dict=False, init_cache=True\n        )\n        return init_variables[\"cache\"]\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: Optional[chex.Array] = None,\n            position_ids: Optional[chex.Array] = None,\n            params: dict = None,\n            past_key_values: dict = None,\n            dropout_rng: jax.random.PRNGKey = None,\n            train: bool = False,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            output_router_logits: Optional[bool] = None,\n            return_dict: Optional[bool] = None,\n            add_params_field: bool = False,\n            **kwargs\n    ):\n        \"\"\"\n        The __call__ function is the main function of a JAX module.\n        It takes as input:\n        - The parameters of the model (self.params)\n        - The inputs to the model (input_ids, attention_mask, position_ids)\n        - Whether we are training (train=True/False) and whether we want to return all hidden states and\n        attentions weights at each layer in addition to just the last layer output (output_hidden_states=True/False).\n\n        :param self: Represent the instance of the class\n        :param input_ids: Pass the input sequence to the model\n        :param attention_mask: Mask out the padding tokens\n        :param position_ids: Specify the position of each token in the sequence\n        :param params: dict: Pass in the parameters of the model\n        :param past_key_values: dict: Pass the past key values to the model\n        :param dropout_rng: jax.random.PRNGKey: Pass in a random number generator key to the model\n        :param train: bool: Determine whether to use dropout or not\n        :param output_attentions: Optional[bool]: Determine whether to return the attention weights\n        :param output_hidden_states: Optional[bool]: Determine whether to return the hidden states of all layers\n        :param return_dict: Optional[bool]: Return a dictionary of the outputs\n        :param add_params_field: bool: Add a params field to the inputs dictionary\n        :return: A tuple of (last_hidden_state, past_key_values)\n\n        \"\"\"\n\n        # TODO: Here needs to be fixed\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n        batch_size, sequence_length = input_ids.shape\n\n        if position_ids is None:\n            if past_key_values is not None:\n                raise ValueError(\n                    \"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n            position_ids = jnp.broadcast_to(jnp.arange(sequence_length)[\n                                            None, :], (batch_size, sequence_length))\n\n        if attention_mask is None:\n            attention_mask = jnp.ones((batch_size, sequence_length))\n\n        rng_s = {}\n        if dropout_rng is not None:\n            rng_s[\"dropout\"] = dropout_rng\n\n        inputs = {\n            \"params\": params or self.params} if add_params_field else params or self.params\n\n        if self.config.bits is not None:\n            rng_s['params'] = jax.random.key(0)\n        if past_key_values:\n            inputs[\"cache\"] = past_key_values\n            mutable = [\"cache\"]\n        else:\n            mutable = False\n\n        outputs = self.module.apply(\n            inputs,\n            jnp.array(input_ids, dtype=\"i4\"),  # input_ids: chex.Array\n            # attention_mask: Optional[chex.Array] = None\n            jnp.array(attention_mask, dtype=\"i4\"),\n            # position_ids: Optional[chex.Array] = None\n            jnp.array(position_ids, dtype=\"i4\"),\n            None,  # inputs_embeds: Optional[chex.Array] = None\n            output_attentions,  # output_attentions: Optional[bool] = None\n            # output_hidden_states: Optional[bool] = None\n            output_hidden_states,\n            # output_router_logits: Optional[bool] = None\n            output_router_logits,\n            False,  # init_cache: bool = False\n            not train,  # deterministic: bool = True\n            return_dict,  # return_dict: bool = True\n            rngs=rng_s,\n            mutable=mutable,\n        )\n\n        if past_key_values is not None and return_dict:\n            outputs, past_key_values = outputs\n            outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n            return outputs\n        elif past_key_values is not None and not return_dict:\n            outputs, past_key_values = outputs\n            outputs = outputs[:1] + \\\n                (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n        return outputs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.MixtralPreTrainedModel.__call__","title":"<code>__call__(input_ids, attention_mask=None, position_ids=None, params=None, past_key_values=None, dropout_rng=None, train=False, output_attentions=None, output_hidden_states=None, output_router_logits=None, return_dict=None, add_params_field=False, **kwargs)</code>","text":"<p>The call function is the main function of a JAX module. It takes as input: - The parameters of the model (self.params) - The inputs to the model (input_ids, attention_mask, position_ids) - Whether we are training (train=True/False) and whether we want to return all hidden states and attentions weights at each layer in addition to just the last layer output (output_hidden_states=True/False).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>input_ids</code> <code>Array</code> <p>Pass the input sequence to the model</p> required <code>attention_mask</code> <code>Optional[Array]</code> <p>Mask out the padding tokens</p> <code>None</code> <code>position_ids</code> <code>Optional[Array]</code> <p>Specify the position of each token in the sequence</p> <code>None</code> <code>params</code> <code>dict</code> <p>dict: Pass in the parameters of the model</p> <code>None</code> <code>past_key_values</code> <code>dict</code> <p>dict: Pass the past key values to the model</p> <code>None</code> <code>dropout_rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Pass in a random number generator key to the model</p> <code>None</code> <code>train</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>False</code> <code>output_attentions</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine whether to return the attention weights</p> <code>None</code> <code>output_hidden_states</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine whether to return the hidden states of all layers</p> <code>None</code> <code>return_dict</code> <code>Optional[bool]</code> <p>Optional[bool]: Return a dictionary of the outputs</p> <code>None</code> <code>add_params_field</code> <code>bool</code> <p>bool: Add a params field to the inputs dictionary</p> <code>False</code> <p>Returns:</p> Type Description <p>A tuple of (last_hidden_state, past_key_values)</p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: Optional[chex.Array] = None,\n        position_ids: Optional[chex.Array] = None,\n        params: dict = None,\n        past_key_values: dict = None,\n        dropout_rng: jax.random.PRNGKey = None,\n        train: bool = False,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        output_router_logits: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        add_params_field: bool = False,\n        **kwargs\n):\n    \"\"\"\n    The __call__ function is the main function of a JAX module.\n    It takes as input:\n    - The parameters of the model (self.params)\n    - The inputs to the model (input_ids, attention_mask, position_ids)\n    - Whether we are training (train=True/False) and whether we want to return all hidden states and\n    attentions weights at each layer in addition to just the last layer output (output_hidden_states=True/False).\n\n    :param self: Represent the instance of the class\n    :param input_ids: Pass the input sequence to the model\n    :param attention_mask: Mask out the padding tokens\n    :param position_ids: Specify the position of each token in the sequence\n    :param params: dict: Pass in the parameters of the model\n    :param past_key_values: dict: Pass the past key values to the model\n    :param dropout_rng: jax.random.PRNGKey: Pass in a random number generator key to the model\n    :param train: bool: Determine whether to use dropout or not\n    :param output_attentions: Optional[bool]: Determine whether to return the attention weights\n    :param output_hidden_states: Optional[bool]: Determine whether to return the hidden states of all layers\n    :param return_dict: Optional[bool]: Return a dictionary of the outputs\n    :param add_params_field: bool: Add a params field to the inputs dictionary\n    :return: A tuple of (last_hidden_state, past_key_values)\n\n    \"\"\"\n\n    # TODO: Here needs to be fixed\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n    batch_size, sequence_length = input_ids.shape\n\n    if position_ids is None:\n        if past_key_values is not None:\n            raise ValueError(\n                \"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n        position_ids = jnp.broadcast_to(jnp.arange(sequence_length)[\n                                        None, :], (batch_size, sequence_length))\n\n    if attention_mask is None:\n        attention_mask = jnp.ones((batch_size, sequence_length))\n\n    rng_s = {}\n    if dropout_rng is not None:\n        rng_s[\"dropout\"] = dropout_rng\n\n    inputs = {\n        \"params\": params or self.params} if add_params_field else params or self.params\n\n    if self.config.bits is not None:\n        rng_s['params'] = jax.random.key(0)\n    if past_key_values:\n        inputs[\"cache\"] = past_key_values\n        mutable = [\"cache\"]\n    else:\n        mutable = False\n\n    outputs = self.module.apply(\n        inputs,\n        jnp.array(input_ids, dtype=\"i4\"),  # input_ids: chex.Array\n        # attention_mask: Optional[chex.Array] = None\n        jnp.array(attention_mask, dtype=\"i4\"),\n        # position_ids: Optional[chex.Array] = None\n        jnp.array(position_ids, dtype=\"i4\"),\n        None,  # inputs_embeds: Optional[chex.Array] = None\n        output_attentions,  # output_attentions: Optional[bool] = None\n        # output_hidden_states: Optional[bool] = None\n        output_hidden_states,\n        # output_router_logits: Optional[bool] = None\n        output_router_logits,\n        False,  # init_cache: bool = False\n        not train,  # deterministic: bool = True\n        return_dict,  # return_dict: bool = True\n        rngs=rng_s,\n        mutable=mutable,\n    )\n\n    if past_key_values is not None and return_dict:\n        outputs, past_key_values = outputs\n        outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n        return outputs\n    elif past_key_values is not None and not return_dict:\n        outputs, past_key_values = outputs\n        outputs = outputs[:1] + \\\n            (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n    return outputs\n</code></pre>"},{"location":"generated-modules-mixtral-modelling_mixtral_flax/#lib.python.EasyDel.modules.mixtral.modelling_mixtral_flax.MixtralPreTrainedModel.init_weights","title":"<code>init_weights(rng, input_shape, params=None)</code>","text":"<p>The init_weights function is used to initialize the weights of a model. It takes in a rng, which is a random number generator key that can be used to generate random numbers. The input_shape parameter specifies the shape of the inputs that will be fed into this model. The params parameter allows you to pass in pre-trained weights for your model, if you have them available.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Initialize the weights of the model</p> required <code>input_shape</code> <code>Tuple</code> <p>Tuple: Initialize the input_ids, attention_mask and position_ids</p> required <code>params</code> <code>FrozenDict</code> <p>flax.core.FrozenDict: Pass in the parameters of a pre-trained model</p> <code>None</code> <p>Returns:</p> Type Description <code>FrozenDict</code> <p>A frozendict of parameters</p> Source code in <code>lib/python/EasyDel/modules/mixtral/modelling_mixtral_flax.py</code> <pre><code>def init_weights(\n        self,\n        rng: jax.random.PRNGKey,\n        input_shape: Tuple,\n        params: FrozenDict = None\n) -&gt; FrozenDict:\n    \"\"\"\n    The init_weights function is used to initialize the weights of a model.\n    It takes in a rng, which is a random number generator key that can be used to generate random numbers.\n    The input_shape parameter specifies the shape of the inputs that will be fed into this model.\n    The params parameter allows you to pass in pre-trained weights for your model, if you have them available.\n\n    :param self: Access variables that belong to the class\n    :param rng: jax.random.PRNGKey: Initialize the weights of the model\n    :param input_shape: Tuple: Initialize the input_ids, attention_mask and position_ids\n    :param params: flax.core.FrozenDict: Pass in the parameters of a pre-trained model\n    :return: A frozendict of parameters\n    \"\"\"\n\n    self.config.initialization_of_moe = True\n    input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n    attention_mask = jnp.ones_like(input_ids, dtype=\"i4\")\n    position_ids = jnp.broadcast_to(\n        jnp.arange(jnp.atleast_2d(input_ids).shape[-1], dtype=\"i4\"),\n        input_shape,\n    )\n    params_rng, dropout_rng = jax.random.split(rng)\n    rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n    if self.config.add_cross_attention:\n        encoder_hidden_states = jnp.zeros(\n            input_shape + (self.config.hidden_size,))\n        encoder_attention_mask = attention_mask\n        module_init_outputs = self.module.init(\n            rngs,\n            input_ids,\n            attention_mask,\n            position_ids,\n            encoder_hidden_states,\n            encoder_attention_mask,\n            return_dict=False,\n        )\n    else:\n        module_init_outputs = self.module.init(\n            rngs,\n            input_ids=input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            return_dict=False\n        )\n    random_params = module_init_outputs[\"params\"]\n\n    self.config.initialization_of_moe = False\n    if params is not None:\n        random_params = flatten_dict(unfreeze(random_params))\n        params = flatten_dict(unfreeze(params))\n        for missing_key in self._missing_keys:\n            params[missing_key] = random_params[missing_key]\n        self._missing_keys = set()\n        return freeze(unflatten_dict(params))\n    else:\n        return random_params\n</code></pre>"},{"location":"generated-modules-mosaic_mpt-modelling_mpt_flax/","title":"modules.mosaic_mpt.modelling_mpt_flax","text":""},{"location":"generated-modules-mosaic_mpt-modelling_mpt_flax/#lib.python.EasyDel.modules.mosaic_mpt.modelling_mpt_flax.FlaxMptAttention","title":"<code>FlaxMptAttention</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/mosaic_mpt/modelling_mpt_flax.py</code> <pre><code>class FlaxMptAttention(nn.Module):\n    config: MptConfig\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self) -&gt; None:\n\n        self.w_qkv = nn.Dense(\n            self.config.d_model * 3,\n            kernel_init=jax.nn.initializers.normal(),\n            use_bias=self.config.use_bias,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method),\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision)\n        self.wo = nn.Dense(\n            self.config.d_model,\n            kernel_init=jax.nn.initializers.normal(),\n            use_bias=self.config.use_bias,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.attention_performer = EasyAttention(\n            attn_type=\"normal\",\n            block_k_major=self.config.block_k_major,\n            block_b=self.config.block_b,\n            block_q=self.config.block_q,\n            block_k=self.config.block_k,\n            block_q_major_dkv=self.config.block_q_major_dkv,\n            block_k_major_dkv=self.config.block_k_major_dkv,\n            block_k_major_dq=self.config.block_k_major_dq,\n            block_k_dkv=self.config.block_k_dkv,\n            block_q_dkv=self.config.block_q_dkv,\n            block_q_dq=self.config.block_q_dq,\n            block_k_dq=self.config.block_k_dq,\n            num_attention_heads=self.config.num_attention_heads,\n            attention_dropout=self.config.attention_dropout,\n            head_dims=self.head_dim,\n            attention_partition_spec=self.config.attention_partition_spec,\n            use_shard_map=self.config.use_shard_map,\n            precision=self.precision,\n            force_float32_tpu=True,\n            attn_mechanism=self.config.attn_mechanism,\n            dtype=self.dtype,\n            bias_partition_spec=self.config.bias_partition_spec,\n            key_partition_spec=self.config.key_partition_spec,\n            query_partition_spec=self.config.query_partition_spec,\n            value_partition_spec=self.config.value_partition_spec,\n            mesh=self.config.jax_mesh(),\n            sm_scale=1 # TOBE CHANGED\n        )\n        if self.config.qk_ln:\n            self.q_ln = nn.LayerNorm(use_bias=self.config.use_norm_bias)\n            self.k_ln = nn.LayerNorm(use_bias=self.config.use_norm_bias)\n        self.causal_mask = nn.make_causal_mask(jnp.ones((1, self.config.max_seq_len)))\n\n    @nn.compact\n    def _concatenate_to_cache(self, key, query, value, attention_mask):\n        is_initialized = self.has_variable('cache', 'key')\n        cache_key = self.variable('cache', 'key', jnp.zeros, key.shape, key.dtype)\n        cache_value = self.variable('cache', 'value', jnp.zeros, value.shape, value.dtype)\n        cache_index = self.variable('cache', 'index', lambda: jnp.array(0, dtype=jnp.int32))\n        if is_initialized:\n            *b, s, h, d = cache_key.value.shape\n            cur_index = cache_index.value\n            indices = (0,) * len(b) + (cur_index, 0, 0)\n            key = jax.lax.dynamic_update_slice(cache_key.value, key, indices)\n            value = jax.lax.dynamic_update_slice(cache_value.value, value, indices)\n            cache_value.value = value\n            cache_key.value = key\n            num_updated_vector = query.shape[1]\n            cache_index.value = cache_index.value + num_updated_vector\n            pad_mask = jnp.broadcast_to(\n                jnp.arange(s) &lt; cur_index + num_updated_vector,\n                tuple(b) + (1, num_updated_vector, s),\n            )\n\n            attention_mask = nn.combine_masks(pad_mask, attention_mask)\n        return key, value, attention_mask\n\n    def __call__(self,\n                 hidden_states: chex.Array,\n                 attention_mask: chex.Array,\n                 position_ids: chex.Array,\n                 attn_bias: chex.Array = None,\n                 init_cache: bool = False\n                 ):\n\n        \"\"\"\n        The __call__ function is the main function of a JAX module.\n        It takes in inputs and returns outputs, just like any other Python function.\n        The difference is that __call__ can also take in state (e.g., parameters) from the module itself,\n        and it can update that state as part of its computation.\n\n        :param self: Access variables that belong to the class\n        :param hidden_states: chex.Array: Pass the input to the attention layer\n        :param attention_mask: chex.Array: Mask out certain positions in the sequence\n        :param position_ids: chex.Array: Specify the position of each token in the sequence\n        :param attn_bias: chex.Array: Add a bias to the attention scores\n        :param init_cache: bool: Initialize the cache\n        :return: The output of the attention layer\n\n        \"\"\"\n        inp_shape = hidden_states.shape\n        b, s, ds = inp_shape\n        qkv = self.w_qkv(hidden_states)\n        q, k, v = jnp.split(qkv, 3, -1)\n        if self.config.qk_ln:\n            q = self.q_ln(q)\n            k = self.k_ln(k)\n        if self.config.use_pjit_attention_force:\n            q = with_sharding_constraint(q, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n            k = with_sharding_constraint(k, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n            v = with_sharding_constraint(v, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n        q = rearrange(q, 'b s (h d) -&gt; b s h d', h=self.config.n_heads)\n        k = rearrange(k, 'b s (h d) -&gt; b s h d', h=self.config.n_heads)\n        v = rearrange(v, 'b s (h d) -&gt; b s h d', h=self.config.n_heads)\n        attention_mask = attention_mask.reshape(b, 1, 1, -1)\n        if self.has_variable('cache', 'key') or init_cache:\n            k, v, attention_mask = self._concatenate_to_cache(key=k, value=v, query=q, attention_mask=attention_mask)\n        # TODO: MPT WONT WORK CAUSE OF NEW ATTENTION MEC ON FJFORMER\n        q_l = q.shape[1]\n        k_l = k.shape[1]\n        dropout_rng = None\n        deterministic = False\n        if deterministic:\n            dropout_rng = self.make_rng(\"dropout\")\n\n        d = q.shape[-1]\n        attn_output = jnp.einsum('...qhd,...khd-&gt;...hqk', q, k, precision=self.precision) * jax.lax.rsqrt(\n            jnp.asarray(d).astype(v.dtype))\n        if self.config.use_pjit_attention_force:\n            attn_output = with_sharding_constraint(attn_output, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", None, None))\n        if attn_bias is not None:\n            attn_output += attn_bias[:, :, :, :attn_output.shape[-1]]\n        mask = jnp.where(self.causal_mask == 1, 0, jnp.finfo(attn_output).min)\n        if attention_mask is not None:\n            attention_mask = jnp.where(\n                attention_mask == 1,\n                0,\n                jnp.finfo(attn_output).min\n            )\n            attn_output += attention_mask\n        attn_output += mask[:, :, :attn_output.shape[-2], :attn_output.shape[-1]]\n        attn_output = nn.softmax(attn_output, -1)\n        attn_output = jnp.einsum('...hqk,...khd-&gt;...qhd', attn_output, v)\n        return self.wo(attn_output.reshape(inp_shape))\n</code></pre>"},{"location":"generated-modules-mosaic_mpt-modelling_mpt_flax/#lib.python.EasyDel.modules.mosaic_mpt.modelling_mpt_flax.FlaxMptAttention.__call__","title":"<code>__call__(hidden_states, attention_mask, position_ids, attn_bias=None, init_cache=False)</code>","text":"<p>The call function is the main function of a JAX module. It takes in inputs and returns outputs, just like any other Python function. The difference is that call can also take in state (e.g., parameters) from the module itself, and it can update that state as part of its computation.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass the input to the attention layer</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out certain positions in the sequence</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in the sequence</p> required <code>attn_bias</code> <code>Array</code> <p>chex.Array: Add a bias to the attention scores</p> <code>None</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache</p> <code>False</code> <p>Returns:</p> Type Description <p>The output of the attention layer</p> Source code in <code>lib/python/EasyDel/modules/mosaic_mpt/modelling_mpt_flax.py</code> <pre><code>def __call__(self,\n             hidden_states: chex.Array,\n             attention_mask: chex.Array,\n             position_ids: chex.Array,\n             attn_bias: chex.Array = None,\n             init_cache: bool = False\n             ):\n\n    \"\"\"\n    The __call__ function is the main function of a JAX module.\n    It takes in inputs and returns outputs, just like any other Python function.\n    The difference is that __call__ can also take in state (e.g., parameters) from the module itself,\n    and it can update that state as part of its computation.\n\n    :param self: Access variables that belong to the class\n    :param hidden_states: chex.Array: Pass the input to the attention layer\n    :param attention_mask: chex.Array: Mask out certain positions in the sequence\n    :param position_ids: chex.Array: Specify the position of each token in the sequence\n    :param attn_bias: chex.Array: Add a bias to the attention scores\n    :param init_cache: bool: Initialize the cache\n    :return: The output of the attention layer\n\n    \"\"\"\n    inp_shape = hidden_states.shape\n    b, s, ds = inp_shape\n    qkv = self.w_qkv(hidden_states)\n    q, k, v = jnp.split(qkv, 3, -1)\n    if self.config.qk_ln:\n        q = self.q_ln(q)\n        k = self.k_ln(k)\n    if self.config.use_pjit_attention_force:\n        q = with_sharding_constraint(q, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n        k = with_sharding_constraint(k, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n        v = with_sharding_constraint(v, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n    q = rearrange(q, 'b s (h d) -&gt; b s h d', h=self.config.n_heads)\n    k = rearrange(k, 'b s (h d) -&gt; b s h d', h=self.config.n_heads)\n    v = rearrange(v, 'b s (h d) -&gt; b s h d', h=self.config.n_heads)\n    attention_mask = attention_mask.reshape(b, 1, 1, -1)\n    if self.has_variable('cache', 'key') or init_cache:\n        k, v, attention_mask = self._concatenate_to_cache(key=k, value=v, query=q, attention_mask=attention_mask)\n    # TODO: MPT WONT WORK CAUSE OF NEW ATTENTION MEC ON FJFORMER\n    q_l = q.shape[1]\n    k_l = k.shape[1]\n    dropout_rng = None\n    deterministic = False\n    if deterministic:\n        dropout_rng = self.make_rng(\"dropout\")\n\n    d = q.shape[-1]\n    attn_output = jnp.einsum('...qhd,...khd-&gt;...hqk', q, k, precision=self.precision) * jax.lax.rsqrt(\n        jnp.asarray(d).astype(v.dtype))\n    if self.config.use_pjit_attention_force:\n        attn_output = with_sharding_constraint(attn_output, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", None, None))\n    if attn_bias is not None:\n        attn_output += attn_bias[:, :, :, :attn_output.shape[-1]]\n    mask = jnp.where(self.causal_mask == 1, 0, jnp.finfo(attn_output).min)\n    if attention_mask is not None:\n        attention_mask = jnp.where(\n            attention_mask == 1,\n            0,\n            jnp.finfo(attn_output).min\n        )\n        attn_output += attention_mask\n    attn_output += mask[:, :, :attn_output.shape[-2], :attn_output.shape[-1]]\n    attn_output = nn.softmax(attn_output, -1)\n    attn_output = jnp.einsum('...hqk,...khd-&gt;...qhd', attn_output, v)\n    return self.wo(attn_output.reshape(inp_shape))\n</code></pre>"},{"location":"generated-modules-mosaic_mpt-mosaic_configuration/","title":"modules.mosaic_mpt.mosaic_configuration","text":""},{"location":"generated-modules-opt-modelling_opt_flax/","title":"modules.opt.modelling_opt_flax","text":"<p>Flax OPT model.</p>"},{"location":"generated-modules-opt-modelling_opt_flax/#lib.python.EasyDel.modules.opt.modelling_opt_flax.FlaxOPTLearnedPositionalEmbedding","title":"<code>FlaxOPTLearnedPositionalEmbedding</code>","text":"<p>             Bases: <code>Embed</code></p> Source code in <code>lib/python/EasyDel/modules/opt/modelling_opt_flax.py</code> <pre><code>class FlaxOPTLearnedPositionalEmbedding(nn.Embed):\n\n    def setup(self):\n        self.offset = 2\n        self.embedding = self.param(\n            \"embedding\", self.embedding_init, (self.num_embeddings + self.offset, self.features), self.param_dtype\n        )\n\n    def __call__(self, positions):\n        \"\"\"`input_ids_shape` is expected to be [bsz x seqlen].\"\"\"\n\n        return super().__call__(positions + self.offset)\n</code></pre>"},{"location":"generated-modules-opt-modelling_opt_flax/#lib.python.EasyDel.modules.opt.modelling_opt_flax.FlaxOPTLearnedPositionalEmbedding.__call__","title":"<code>__call__(positions)</code>","text":"<p><code>input_ids_shape</code> is expected to be [bsz x seqlen].</p> Source code in <code>lib/python/EasyDel/modules/opt/modelling_opt_flax.py</code> <pre><code>def __call__(self, positions):\n    \"\"\"`input_ids_shape` is expected to be [bsz x seqlen].\"\"\"\n\n    return super().__call__(positions + self.offset)\n</code></pre>"},{"location":"generated-modules-opt-opt_configuration/","title":"modules.opt.opt_configuration","text":""},{"location":"generated-modules-palm-modelling_palm_flax/","title":"modules.palm.modelling_palm_flax","text":""},{"location":"generated-modules-palm-palm_configuration/","title":"modules.palm.palm_configuration","text":""},{"location":"generated-modules-phi-modelling_phi_flax/","title":"modules.phi.modelling_phi_flax","text":""},{"location":"generated-modules-phi-modelling_phi_flax/#lib.python.EasyDel.modules.phi.modelling_phi_flax.FlaxPhiAttention","title":"<code>FlaxPhiAttention</code>","text":"<p>             Bases: <code>Module</code></p> <p>Multi-headed attention from 'Attention Is All You Need' paper</p> Source code in <code>lib/python/EasyDel/modules/phi/modelling_phi_flax.py</code> <pre><code>class FlaxPhiAttention(nn.Module):\n    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n    config: PhiConfig\n    layer_idx: Optional[int] = None\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\")\n\n    def setup(self):\n        config = self.config\n        self.attention_dropout = config.attention_dropout\n        self.hidden_size = config.hidden_size\n        self.num_heads = config.num_attention_heads\n        self.head_dim = self.hidden_size // self.num_heads\n        self.num_key_value_heads = config.num_key_value_heads\n        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n        self.max_position_embeddings = config.max_position_embeddings\n        self.rope_theta = config.rope_theta\n        self.partial_rotary_factor = config.partial_rotary_factor\n        self.is_causal = True\n\n        if (self.head_dim * self.num_heads) != self.hidden_size:\n            raise ValueError(\n                f\"hidden_size must be divisible by num_heads (got `hidden_size`: {self.hidden_size}\"\n                f\" and `num_heads`: {self.num_heads}).\"\n            )\n\n        dense_class = functools.partial(\n            nn.Dense,\n            use_bias=True,\n            precision=self.precision,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            kernel_init=jax.nn.initializers.normal(self.config.initializer_range),\n            **get_dot_general_by_bits(self.config.bits)\n        )\n\n        self.q_proj = dense_class(self.num_heads * self.head_dim)\n        self.k_proj = dense_class(self.num_key_value_heads * self.head_dim)\n        self.v_proj = dense_class(self.num_key_value_heads * self.head_dim)\n        self.dense = dense_class(self.hidden_size)\n        self.rotary = FlaxPhiEmbedding(self.dtype)\n        self.qk_layernorm = config.qk_layernorm\n        if self.qk_layernorm:\n            self.q_layernorm = nn.LayerNorm(\n                epsilon=config.layer_norm_eps,\n                dtype=self.dtype,\n                param_dtype=self.param_dtype,\n                use_bias=True\n            )\n            self.k_layernorm = nn.LayerNorm(\n                epsilon=config.layer_norm_eps,\n                dtype=self.dtype,\n                param_dtype=self.param_dtype,\n                use_bias=True\n            )\n\n        self.attention_performer = EasyAttention(\n            attn_type=\"normal\",\n            block_k_major=self.config.block_k_major,\n            block_b=self.config.block_b,\n            block_q=self.config.block_q,\n            block_k=self.config.block_k,\n            block_q_major_dkv=self.config.block_q_major_dkv,\n            block_k_major_dkv=self.config.block_k_major_dkv,\n            block_k_major_dq=self.config.block_k_major_dq,\n            block_k_dkv=self.config.block_k_dkv,\n            block_q_dkv=self.config.block_q_dkv,\n            block_q_dq=self.config.block_q_dq,\n            block_k_dq=self.config.block_k_dq,\n            num_attention_heads=self.config.num_attention_heads,\n            attention_dropout=self.config.attention_dropout,\n            head_dims=self.head_dim,\n            attention_partition_spec=self.config.attention_partition_spec,\n            use_shard_map=self.config.use_shard_map,\n            precision=self.precision,\n            force_float32_tpu=True,\n            attn_mechanism=self.config.attn_mechanism,\n            dtype=self.dtype,\n            bias_partition_spec=self.config.bias_partition_spec,\n            key_partition_spec=self.config.key_partition_spec,\n            query_partition_spec=self.config.query_partition_spec,\n            value_partition_spec=self.config.value_partition_spec,\n            mesh=self.config.jax_mesh(),\n            sm_scale=1 / math.sqrt(self.head_dim)\n        )\n\n    def _merge_heads(self, hidden_states):\n        return hidden_states.reshape(hidden_states.shape[:2] + (self.hidden_size,))\n\n    @nn.compact\n    def _concatenate_to_cache(self, key, value, query, attention_mask):\n        \"\"\"\n        The _concatenate_to_cache function is used to concatenate the key and value vectors\n        of a query with those of previous queries. This allows for the attention mechanism to\n        look at all previous queries when computing its output. The function takes in three\n        arguments: key, value, and query. It also uses two variables that are stored in the cache:\n        cached_key and cached_value.\n\n        :param self: Access the variables stored in the cache\n        :param key: Store the keys of the encoder-decoder attention\n        :param value: Initialize the cached_value variable\n        :param query: Determine the number of cache vectors to update\n        :param attention_mask: Mask out the padded vectors in the cache\n        :return: The key, value and attention_mask\n        \"\"\"\n        is_initialized = self.has_variable(\"cache\", \"cached_key\")\n        cached_key = self.variable(\n            \"cache\", \"cached_key\", jnp.zeros, key.shape, key.dtype)\n        cached_value = self.variable(\n            \"cache\", \"cached_value\", jnp.zeros, value.shape, value.dtype)\n        cache_index = self.variable(\n            \"cache\", \"cache_index\", lambda: jnp.array(0, dtype=jnp.int32))\n\n        if is_initialized:\n            *batch_dims, max_length, num_heads, depth_per_head = cached_key.value.shape\n            cur_index = cache_index.value\n            indices = (0,) * len(batch_dims) + (cur_index, 0, 0)\n            key = lax.dynamic_update_slice(cached_key.value, key, indices)\n            value = lax.dynamic_update_slice(\n                cached_value.value, value, indices)\n            cached_key.value = key\n            cached_value.value = value\n            num_updated_cache_vectors = query.shape[1]\n            cache_index.value = cache_index.value + num_updated_cache_vectors\n\n            pad_mask = jnp.broadcast_to(\n                jnp.arange(max_length) &lt; cur_index + num_updated_cache_vectors,\n                tuple(batch_dims) + (1, num_updated_cache_vectors, max_length),\n            )\n            attention_mask = combine_masks(pad_mask, attention_mask)\n        return key, value, attention_mask\n\n    @staticmethod\n    def _t(query, key, value):\n        \"\"\"\n        The _t function transposes the query, key and value matrices.\n\n        :param query: Get the attention weights for each of the heads\n        :param key: Determine the number of heads\n        :param value: Store the values of the input\n        :return: The transpose of the query, key and value matrices\n\n        \"\"\"\n        return jnp.transpose(query, (0, 2, 1, 3)), jnp.transpose(key, (0, 2, 1, 3)), jnp.transpose(value, (0, 2, 1, 3))\n\n    def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n        \"\"\"\n        The apply_rotary function is a modified version of the apply_attention function in the BertModel class.\n        The main difference is that it takes in an additional argument, freq_cis, which are used to calculate\n        the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.\n\n        :param self: Access variables that belong to the class\n        :param batch_size: Reshape the query, key and value tensors\n        :param sequence_length: Reshape the query, key and value tensors\n        :param query: Calculate the attention weights\n        :param key: Calculate the attention\n        :param value: Compute the attention weights\n        :param freq_cis: Calculate the frequency of each word in the vocabulary\n        :param position_ids: Identify the position of each token in the sequence\n        :return: A tuple of 3 tensors: query, key and value\n\n        \"\"\"\n        query = query.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_attention_heads,\n            self.head_dim\n        )\n        key = key.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_key_value_heads,\n            self.head_dim\n        )\n        value = value.reshape(\n            batch_size,\n            sequence_length,\n            self.config.num_key_value_heads,\n            self.head_dim\n        )\n\n        query, key, value = self._t(query, key, value)\n        query, key = self.rotary(\n            position_ids=position_ids, query=query, key=key, freq_cis=freq_cis\n        )\n        key = repeat_kv_bnsh(key, self.num_key_value_groups)\n        value = repeat_kv_bnsh(value, self.num_key_value_groups)\n        return self._t(query, key, value)\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: Tuple[chex.Array, chex.Array],\n            attention_mask: Optional[chex.Array],\n            position_ids: Optional[chex.Array],\n            causal_mask: Optional[chex.Array],\n            deterministic: bool = True,\n            output_attentions: bool = False,\n            init_cache: bool = False,\n    ):\n        batch_size, sequence_length = hidden_states.shape[:2]\n        (\n            query_states,\n            key_states,\n            value_states\n        ) = self.q_proj(\n            hidden_states\n        ), self.k_proj(\n            hidden_states\n        ), self.v_proj(\n            hidden_states\n        )\n\n        if self.qk_layernorm:\n            query_states = self.q_layernorm(query_states)\n            key_states = self.k_layernorm(key_states)\n\n        if self.config.use_pjit_attention_force:\n            query_states = with_sharding_constraint(\n                query_states, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\")\n            )\n            key_states = with_sharding_constraint(\n                key_states, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\")\n            )\n            value_states = with_sharding_constraint(\n                value_states, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\")\n            )\n\n        query_states = query_states.reshape(\n            batch_size, sequence_length, self.config.num_attention_heads, self.head_dim\n        )\n        key_states = key_states.reshape(\n            batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim\n        )\n        value_states = value_states.reshape(\n            batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim\n        )\n\n        query_states, key_states, value_states = self.apply_rotary(\n            query=query_states,\n            key=key_states,\n            value=value_states,\n            position_ids=position_ids,\n            freq_cis=freq_cis,\n            batch_size=batch_size,\n            sequence_length=sequence_length\n        )\n        assert_msg = (\n            \"num_attention_heads repeat wont work likely\\n\"\n            f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n            f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n        )\n\n        assert query_states.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert key_states.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert value_states.shape[-2] == self.config.num_attention_heads, assert_msg\n\n        query_length, key_length = query_states.shape[1], key_states.shape[1]\n\n        if self.has_variable(\"cache\", \"cached_key\"):\n            mask_shift = self.variables[\"cache\"][\"cache_index\"]\n            max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n            causal_mask = lax.dynamic_slice(\n                causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                     query_length, max_decoder_length)\n            )\n        else:\n            causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n        batch_size = hidden_states.shape[0]\n        causal_mask = jnp.broadcast_to(\n            causal_mask, (batch_size,) + causal_mask.shape[1:])\n        attention_mask = jnp.broadcast_to(jnp.expand_dims(\n            attention_mask, axis=(-3, -2)), causal_mask.shape)\n        attention_mask = combine_masks(attention_mask, causal_mask)\n        if attention_mask.ndim == 2:\n            attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n\n        dropout_rng = None\n\n        if not deterministic and self.config.attention_dropout &gt; 0.0:\n            dropout_rng = self.make_rng(\"dropout\")\n\n        if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n            key_states, value_states, attention_mask = self._concatenate_to_cache(\n                key_states,\n                value_states,\n                query_states,\n                attention_mask\n            )\n        attention_bias = lax.select(\n            attention_mask &gt; 0,\n            jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n            jnp.full(attention_mask.shape, jnp.finfo(\n                self.dtype).min).astype(self.dtype),\n        )\n        query_states, key_states, value_states = map(\n            lambda a: a.transpose(0, 2, 1, 3),\n            [query_states, key_states, value_states]\n        )\n\n        query_length, key_length = query_states.shape[-2], key_states.shape[-2]\n\n        attentions = self.attention_performer.__call__(\n            query_states=query_states,\n            key_states=key_states,\n            value_states=value_states,\n            bias=attention_bias,\n            causal=False,\n            use_pjit_attention_force=self.config.use_pjit_attention_force,\n            dropout_rng=dropout_rng,\n            deterministic=deterministic,\n            query_sequence_length=query_length,\n            key_value_sequence_length=key_length,\n            uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n        )\n        attentions.attention_outputs = attentions.attention_outputs.transpose(0, 2, 1, 3)\n        attn_output = self._merge_heads(attentions.attention_outputs)\n        attn_output = self.dense(attn_output)\n\n        outputs = (attn_output, attentions.attention_weights) if output_attentions else (attn_output,)\n        return outputs\n</code></pre>"},{"location":"generated-modules-phi-modelling_phi_flax/#lib.python.EasyDel.modules.phi.modelling_phi_flax.FlaxPhiAttention.apply_rotary","title":"<code>apply_rotary(batch_size, sequence_length, query, key, value, freq_cis, position_ids)</code>","text":"<p>The apply_rotary function is a modified version of the apply_attention function in the BertModel class. The main difference is that it takes in an additional argument, freq_cis, which are used to calculate the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>batch_size</code> <p>Reshape the query, key and value tensors</p> required <code>sequence_length</code> <p>Reshape the query, key and value tensors</p> required <code>query</code> <p>Calculate the attention weights</p> required <code>key</code> <p>Calculate the attention</p> required <code>value</code> <p>Compute the attention weights</p> required <code>freq_cis</code> <p>Calculate the frequency of each word in the vocabulary</p> required <code>position_ids</code> <p>Identify the position of each token in the sequence</p> required <p>Returns:</p> Type Description <p>A tuple of 3 tensors: query, key and value</p> Source code in <code>lib/python/EasyDel/modules/phi/modelling_phi_flax.py</code> <pre><code>def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n    \"\"\"\n    The apply_rotary function is a modified version of the apply_attention function in the BertModel class.\n    The main difference is that it takes in an additional argument, freq_cis, which are used to calculate\n    the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.\n\n    :param self: Access variables that belong to the class\n    :param batch_size: Reshape the query, key and value tensors\n    :param sequence_length: Reshape the query, key and value tensors\n    :param query: Calculate the attention weights\n    :param key: Calculate the attention\n    :param value: Compute the attention weights\n    :param freq_cis: Calculate the frequency of each word in the vocabulary\n    :param position_ids: Identify the position of each token in the sequence\n    :return: A tuple of 3 tensors: query, key and value\n\n    \"\"\"\n    query = query.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_attention_heads,\n        self.head_dim\n    )\n    key = key.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_key_value_heads,\n        self.head_dim\n    )\n    value = value.reshape(\n        batch_size,\n        sequence_length,\n        self.config.num_key_value_heads,\n        self.head_dim\n    )\n\n    query, key, value = self._t(query, key, value)\n    query, key = self.rotary(\n        position_ids=position_ids, query=query, key=key, freq_cis=freq_cis\n    )\n    key = repeat_kv_bnsh(key, self.num_key_value_groups)\n    value = repeat_kv_bnsh(value, self.num_key_value_groups)\n    return self._t(query, key, value)\n</code></pre>"},{"location":"generated-modules-phi-modelling_phi_flax/#lib.python.EasyDel.modules.phi.modelling_phi_flax.FlaxPhiMLP","title":"<code>FlaxPhiMLP</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/phi/modelling_phi_flax.py</code> <pre><code>class FlaxPhiMLP(nn.Module):\n    config: PhiConfig\n    layer_idx: Optional[int] = None\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\")\n\n    \"\"\"Multi-Layer Perceptron.\n    Reference:\n        Attention Is All You Need.\n        https://arxiv.org/pdf/1706.03762.pdf.\n    \"\"\"\n\n    def setup(\n            self\n    ) -&gt; None:\n        self.fc1 = nn.Dense(\n            self.config.intermediate_size,\n            kernel_init=nn.initializers.normal(self.config.initializer_range),\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        self.fc2 = nn.Dense(\n            self.config.n_embd,\n            kernel_init=nn.initializers.normal(self.config.initializer_range),\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        self.act = ACT2FN[self.config.hidden_act]\n\n    def __call__(self, hidden_states: Array) -&gt; Array:\n        return self.fc2(self.act(self.fc1(hidden_states)))\n</code></pre>"},{"location":"generated-modules-phi-modelling_phi_flax/#lib.python.EasyDel.modules.phi.modelling_phi_flax.FlaxPhiMLP.precision","title":"<code>precision: Optional[jax.lax.Precision] = jax.lax.Precision('fastest')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Multi-Layer Perceptron. Reference:     Attention Is All You Need.     https://arxiv.org/pdf/1706.03762.pdf.</p>"},{"location":"generated-modules-phi-modelling_phi_flax/#lib.python.EasyDel.modules.phi.modelling_phi_flax.FlaxPhiPreTrainedModel","title":"<code>FlaxPhiPreTrainedModel</code>","text":"<p>             Bases: <code>EasyDelFlaxPretrainedModel</code></p> <p>Phi pre-trained model.</p> Source code in <code>lib/python/EasyDel/modules/phi/modelling_phi_flax.py</code> <pre><code>class FlaxPhiPreTrainedModel(EasyDelFlaxPretrainedModel):\n    \"\"\"Phi pre-trained model.\"\"\"\n    module_class = None\n    config_class = PhiConfig\n    base_model_prefix = \"transformer\"\n\n    def __init__(\n            self,\n            config: PhiConfig,\n            dtype: jnp.dtype = jnp.float32,\n            param_dtype: jnp.dtype = jnp.float32,\n            precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\"),\n            input_shape=(1, 1),\n            seed: int = 42,\n            _do_init: bool = False\n    ) -&gt; None:\n        module = self.module_class(\n            config=config,\n            dtype=dtype,\n            param_dtype=param_dtype,\n            precision=precision\n        )\n        super().__init__(\n            config=config,\n            module=module,\n            input_shape=input_shape,\n            _do_init=_do_init,\n            seed=seed\n        )\n\n    def init_cache(self, batch_size, max_length):\n\n        input_ids = jnp.ones((batch_size, max_length))\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(\n            jnp.atleast_2d(input_ids).shape[-1]), input_ids.shape)\n\n        init_variables = self.module.init(\n            jax.random.PRNGKey(0), input_ids, attention_mask, position_ids, return_dict=False, init_cache=True\n        )\n        return init_variables[\"cache\"]\n\n    def init_weights(self, rng: jax.random.PRNGKey, input_shape: Tuple, params: FrozenDict = None) -&gt; FrozenDict:\n        input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n        attention_mask = jnp.ones_like(input_ids)\n        params_rng, dropout_rng = jax.random.split(rng)\n        rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n        module_init_outputs = self.module.init(rngs, input_ids, attention_mask)\n\n        random_params = module_init_outputs[\"params\"]\n\n        if params is not None:\n            random_params = flatten_dict(unfreeze(random_params))\n            params = flatten_dict(unfreeze(params))\n            for missing_key in self._missing_keys:\n                params[missing_key] = random_params[missing_key]\n            self._missing_keys = set()\n            return freeze(unflatten_dict(params))\n        else:\n            return random_params\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array = None,\n            position_ids: chex.Array = None,\n            params: dict = None,\n            past_key_values: dict = None,\n            dropout_rng: jax.random.PRNGKey = None,\n            train: bool = False,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            return_dict: Optional[bool] = True,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None,\n            add_params_field: bool = False,\n            **kwargs\n    ):\n\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n        batch_size, sequence_length = input_ids.shape\n\n        assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n\n        if attention_mask is None:\n            attention_mask = jnp.ones((batch_size, sequence_length))\n\n        rngs = {}\n        if dropout_rng is not None:\n            rngs[\"dropout\"] = dropout_rng\n\n        if self.config.bits is not None:\n            rngs['params'] = jax.random.key(0)\n\n        inputs = {\"params\": params or self.params} if add_params_field else params or self.params\n\n        if past_key_values:\n            inputs[\"cache\"] = past_key_values\n            mutable = [\"cache\"]\n        else:\n            mutable = False\n\n        outputs = self.module.apply(\n            inputs,\n            input_ids=input_ids,\n            inputs_embeds=None,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            extra_embedding=extra_embedding,\n            deterministic=not train,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            init_cache=False,\n            return_dict=return_dict,\n            rngs=rngs,\n            mutable=mutable,\n        )\n\n        if past_key_values is not None and return_dict:\n            outputs, past_key_values = outputs\n            outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n            return outputs\n        elif past_key_values is not None and not return_dict:\n            outputs, past_key_values = outputs\n            outputs = outputs[:1] + (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n        return outputs\n</code></pre>"},{"location":"generated-modules-phi-phi_configuration/","title":"modules.phi.phi_configuration","text":""},{"location":"generated-modules-phi-phi_configuration/#lib.python.EasyDel.modules.phi.phi_configuration.PhiConfig","title":"<code>PhiConfig</code>","text":"<p>             Bases: <code>EasyDelPretrainedConfig</code></p> <p>Phi configuration.</p> Source code in <code>lib/python/EasyDel/modules/phi/phi_configuration.py</code> <pre><code>class PhiConfig(EasyDelPretrainedConfig):\n    \"\"\"Phi configuration.\"\"\"\n\n    model_type = \"phi\"\n    attribute_map = {\n        \"max_position_embeddings\": \"n_positions\",\n        \"hidden_size\": \"n_embd\",\n        \"num_attention_heads\": \"num_attention_heads\",\n        \"num_hidden_layers\": \"num_hidden_layers\",\n    }\n\n    def __init__(\n            self,\n            vocab_size=51200,\n            hidden_size=2048,\n            intermediate_size=8192,\n            num_hidden_layers=24,\n            num_attention_heads=32,\n            num_key_value_heads=None,\n            resid_pdrop=0.0,\n            embd_pdrop=0.0,\n            attention_dropout=0.0,\n            hidden_act=\"gelu_new\",\n            max_position_embeddings=2048,\n            initializer_range=0.02,\n            layer_norm_eps=1e-5,\n            use_cache=True,\n            tie_word_embeddings=False,\n            rope_theta=10000.0,\n            rope_scaling=None,\n            partial_rotary_factor=0.5,\n            qk_layernorm=False,\n            bos_token_id=1,\n            eos_token_id=2,\n            bits: Optional[int] = None,\n            gradient_checkpointing: str = \"nothing_saveable\",\n            use_pjit_attention_force: bool = False,\n            **kwargs\n    ) -&gt; None:\n        self.vocab_size = vocab_size\n        self.hidden_size = hidden_size\n        self.intermediate_size = intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n\n        self.num_key_value_heads = num_key_value_heads\n        self.resid_pdrop = resid_pdrop\n        self.embd_pdrop = embd_pdrop\n        self.attention_dropout = attention_dropout\n        self.hidden_act = hidden_act\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.use_cache = use_cache\n        self.rope_theta = rope_theta\n        self.rope_scaling = rope_scaling\n        self.partial_rotary_factor = partial_rotary_factor\n        self.qk_layernorm = qk_layernorm\n        self.bits = bits\n        self.gradient_checkpointing = gradient_checkpointing\n        self.use_pjit_attention_force = use_pjit_attention_force\n        super().__init__(\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs\n        )\n\n    def add_jax_args(\n            self,\n            bits: Optional[int] = None,\n            gradient_checkpointing: str = \"nothing_saveable\",\n            use_pjit_attention_force: bool = False,\n            **kwargs\n    ):\n        self.bits = bits\n        self.gradient_checkpointing = gradient_checkpointing\n        self.use_pjit_attention_force = use_pjit_attention_force\n        for k, v in kwargs.items():\n            if not hasattr(self, k):\n                setattr(self, k, v)\n\n    def get_partition_rules(self, fully_sharded_data_parallel: bool = True):\n        return (\n            (\n                \".*\", PartitionSpec((\"fsdp\", \"sp\"))\n             ),\n        )\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/","title":"modules.qwen2.modelling_qwen_flax","text":""},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2Attention","title":"<code>FlaxQwen2Attention</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2Attention(nn.Module):\n    config: Qwen2Config\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        config = self.config\n        self.hidden_size = config.hidden_size\n        self.head_dim = self.config.hidden_size // self.config.num_attention_heads\n        self.num_key_value_groups = self.config.num_attention_heads // self.config.num_key_value_heads\n\n        if self.num_key_value_groups == 1:\n            assert self.config.num_attention_heads == self.config.num_key_value_heads\n        self.q_proj = nn.Dense(\n            config.num_attention_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=True,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range\n            ),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.k_proj = nn.Dense(\n            config.num_key_value_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=True,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range\n            ),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.v_proj = nn.Dense(\n            config.num_key_value_heads * self.head_dim,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=True,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range\n            ),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.o_proj = nn.Dense(\n            config.hidden_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range\n            ),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n\n        self.rotary = FlaxQwen2Embedding(self.dtype)\n        self.attention_performer = EasyAttention(\n            attn_type=\"normal\",\n            block_k_major=self.config.block_k_major,\n            block_b=self.config.block_b,\n            block_q=self.config.block_q,\n            block_k=self.config.block_k,\n            block_q_major_dkv=self.config.block_q_major_dkv,\n            block_k_major_dkv=self.config.block_k_major_dkv,\n            block_k_major_dq=self.config.block_k_major_dq,\n            block_k_dkv=self.config.block_k_dkv,\n            block_q_dkv=self.config.block_q_dkv,\n            block_q_dq=self.config.block_q_dq,\n            block_k_dq=self.config.block_k_dq,\n            num_attention_heads=self.config.num_attention_heads,\n            attention_dropout=self.config.attention_dropout,\n            head_dims=self.head_dim,\n            attention_partition_spec=self.config.attention_partition_spec,\n            use_shard_map=self.config.use_shard_map,\n            precision=self.precision,\n            force_float32_tpu=True,\n            attn_mechanism=self.config.attn_mechanism,\n            dtype=self.dtype,\n            bias_partition_spec=self.config.bias_partition_spec,\n            key_partition_spec=self.config.key_partition_spec,\n            query_partition_spec=self.config.query_partition_spec,\n            value_partition_spec=self.config.value_partition_spec,\n            mesh=self.config.jax_mesh(),\n            sm_scale=1 / math.sqrt(self.head_dim)\n        )\n        self.resid_dropout = nn.Dropout(rate=config.resid_pdrop)\n\n    def _merge_heads(self, hidden_states):\n        return hidden_states.reshape(hidden_states.shape[:2] + (self.hidden_size,))\n\n    @nn.compact\n    def _concatenate_to_cache(self, key, value, query, attention_mask):\n        \"\"\"\n        The _concatenate_to_cache function is used to concatenate the key and value vectors\n        of a query with those of previous queries. This allows for the attention mechanism to\n        look at all previous queries when computing its output. The function takes in three\n        arguments: key, value, and query. It also uses two variables that are stored in the cache:\n        cached_key and cached_value.\n\n        :param self: Access the variables stored in the cache\n        :param key: Store the keys of the encoder-decoder attention\n        :param value: Initialize the cached_value variable\n        :param query: Determine the number of cache vectors to update\n        :param attention_mask: Mask out the padded vectors in the cache\n        :return: The key, value and attention_mask\n\n        \"\"\"\n        is_initialized = self.has_variable(\"cache\", \"cached_key\")\n        cached_key = self.variable(\n            \"cache\", \"cached_key\", jnp.zeros, key.shape, key.dtype)\n        cached_value = self.variable(\n            \"cache\", \"cached_value\", jnp.zeros, value.shape, value.dtype)\n        cache_index = self.variable(\n            \"cache\", \"cache_index\", lambda: jnp.array(0, dtype=jnp.int32))\n\n        if is_initialized:\n            *batch_dims, max_length, num_heads, depth_per_head = cached_key.value.shape\n            cur_index = cache_index.value\n            indices = (0,) * len(batch_dims) + (cur_index, 0, 0)\n            key = lax.dynamic_update_slice(cached_key.value, key, indices)\n            value = lax.dynamic_update_slice(\n                cached_value.value, value, indices)\n            cached_key.value = key\n            cached_value.value = value\n            num_updated_cache_vectors = query.shape[1]\n            cache_index.value = cache_index.value + num_updated_cache_vectors\n\n            pad_mask = jnp.broadcast_to(\n                jnp.arange(max_length) &lt; cur_index + num_updated_cache_vectors,\n                tuple(batch_dims) + (1, num_updated_cache_vectors, max_length),\n            )\n            attention_mask = combine_masks(pad_mask, attention_mask)\n        return key, value, attention_mask\n\n    @staticmethod\n    def _t(query, key, value):\n        \"\"\"\n        The _t function transposes the query, key and value matrices.\n\n        :param query: Get the attention weights for each of the heads\n        :param key: Determine the number of heads\n        :param value: Store the values of the input\n        :return: The transpose of the query, key and value matrices\n\n        \"\"\"\n        return jnp.transpose(query, (0, 2, 1, 3)), jnp.transpose(key, (0, 2, 1, 3)), jnp.transpose(value, (0, 2, 1, 3))\n\n    def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n        \"\"\"\n        The apply_rotary function is a modified version of the apply_attention function in the BertModel class.\n        The main difference is that it takes in an additional argument, freq_cis, which are used to calculate\n        the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.\n\n        :param self: Access variables that belong to the class\n        :param batch_size: Reshape the query, key and value tensors\n        :param sequence_length: Reshape the query, key and value tensors\n        :param query: Calculate the attention weights\n        :param key: Calculate the attention\n        :param value: Compute the attention weights\n        :param freq_cis: Calculate the frequency of each word in the vocabulary\n        :param position_ids: Identify the position of each token in the sequence\n        :return: A tuple of 3 tensors: query, key and value\n\n        \"\"\"\n        query = query.reshape(batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n        key = key.reshape(batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n        value = value.reshape(batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n        query, key, value = self._t(query, key, value)\n        query, key = self.rotary(\n            position_ids=position_ids, query=query, key=key, freq_cis=freq_cis\n        )\n        key = repeat_kv_bnsh(key, self.num_key_value_groups)\n        value = repeat_kv_bnsh(value, self.num_key_value_groups)\n        return self._t(query, key, value)\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            causal_mask: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            fcm_mask=None,\n    ):\n        \"\"\"\n\n        The __call__ function is the main function of a JAX module. It defines how the module behaves when called\n        with inputs. The __call__ function can be thought of as a &amp;quot;forward pass&amp;quot; through the model,\n        and it should return all outputs that are needed for training or inference.\n\n        :param self: Access variables that belong to the class\n        :param hidden_states: chex.Array: Pass the hidden states of the previous layer\n        :param freq_cis: chex.Array: Pass in the frequency coefficients for each position\n        :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n        :param position_ids: chex.Array: Determine the position of each token in a sequence\n        :param causal_mask: chex.Array: Mask out the future tokens in the decoder\n        :param deterministic: bool: Determine whether to use dropout or not\n        :param init_cache: bool: Initialize the cache\n        :param output_attentions: bool: Determine whether to return the attention weights or not\n        :param fcm_mask: Mask out the attention weights between the input and output tokens\n        :param : Determine if the attention is causal or not\n        :return: A tuple of two arrays\n\n        \"\"\"\n        batch_size, sequence_length = hidden_states.shape[:2]\n        query_state, key_state, value_state = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(\n            hidden_states)\n\n        if self.config.use_pjit_attention_force:\n            query_state = with_sharding_constraint(query_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n            key_state = with_sharding_constraint(key_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n            value_state = with_sharding_constraint(value_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n\n        query_state = query_state.reshape(batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n        key_state = key_state.reshape(batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n        value_state = value_state.reshape(batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n        query_state, key_state, value_state = self.apply_rotary(\n            query=query_state,\n            key=key_state,\n            value=value_state,\n            position_ids=position_ids,\n            freq_cis=freq_cis,\n            batch_size=batch_size,\n            sequence_length=sequence_length\n        )\n\n        assert_msg = (\n            \"num_attention_heads repeat wont work likely\\n\"\n            f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n            f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n        )\n\n        assert query_state.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert key_state.shape[-2] == self.config.num_attention_heads, assert_msg\n        assert value_state.shape[-2] == self.config.num_attention_heads, assert_msg\n\n        query_length, key_length = query_state.shape[1], key_state.shape[1]\n\n        if self.has_variable(\"cache\", \"cached_key\"):\n            mask_shift = self.variables[\"cache\"][\"cache_index\"]\n            max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n            causal_mask = lax.dynamic_slice(\n                causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                     query_length, max_decoder_length)\n            )\n        else:\n            causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n        batch_size = hidden_states.shape[0]\n        causal_mask = jnp.broadcast_to(\n            causal_mask, (batch_size,) + causal_mask.shape[1:])\n        attention_mask = jnp.broadcast_to(jnp.expand_dims(\n            attention_mask, axis=(-3, -2)), causal_mask.shape)\n        attention_mask = combine_masks(attention_mask, causal_mask, fcm_mask)\n        if attention_mask.ndim == 2:\n            attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n\n        dropout_rng = None\n\n        if not deterministic and self.config.attention_dropout &gt; 0.0:\n            dropout_rng = self.make_rng(\"dropout\")\n\n        if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n            key_state, value_state, attention_mask = self._concatenate_to_cache(\n                key_state,\n                value_state,\n                query_state,\n                attention_mask\n            )\n\n        attention_bias = lax.select(\n            attention_mask &gt; 0,\n            jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n            jnp.full(attention_mask.shape, jnp.finfo(\n                self.dtype).min).astype(self.dtype),\n        )\n\n        query_state, key_state, value_state = map(\n            lambda a: a.transpose(0, 2, 1, 3),\n            [query_state, key_state, value_state]\n        )\n\n        query_length, key_length = query_state.shape[-2], key_state.shape[-2]\n\n        attentions = self.attention_performer.__call__(\n            query_states=query_state,\n            key_states=key_state,\n            value_states=value_state,\n            bias=attention_bias,\n            causal=False,\n            use_pjit_attention_force=self.config.use_pjit_attention_force,\n            dropout_rng=dropout_rng,\n            deterministic=deterministic,\n            query_sequence_length=query_length,\n            key_value_sequence_length=key_length,\n            uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n        )\n        attentions.attention_outputs = attentions.attention_outputs.transpose(0, 2, 1, 3)\n\n        attn_output = self._merge_heads(attentions.attention_outputs)\n        attn_output = self.o_proj(attn_output)\n\n        attn_output = self.resid_dropout(\n            attn_output, deterministic=deterministic)\n        outputs = (\n            attn_output, attentions.attention_weights\n        ) if output_attentions else (\n            attn_output,\n        )\n        return outputs\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2Attention.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, position_ids, causal_mask, deterministic=True, init_cache=False, output_attentions=False, fcm_mask=None)</code>","text":"<p>The call function is the main function of a JAX module. It defines how the module behaves when called with inputs. The call function can be thought of as a \"forward pass\" through the model, and it should return all outputs that are needed for training or inference.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass the hidden states of the previous layer</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass in the frequency coefficients for each position</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out certain tokens in the input sequence</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Determine the position of each token in a sequence</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask out the future tokens in the decoder</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attention weights or not</p> <code>False</code> <code>fcm_mask</code> <p>Mask out the attention weights between the input and output tokens</p> <code>None</code> <code></code> <p>Determine if the attention is causal or not</p> required <p>Returns:</p> Type Description <p>A tuple of two arrays</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        causal_mask: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        fcm_mask=None,\n):\n    \"\"\"\n\n    The __call__ function is the main function of a JAX module. It defines how the module behaves when called\n    with inputs. The __call__ function can be thought of as a &amp;quot;forward pass&amp;quot; through the model,\n    and it should return all outputs that are needed for training or inference.\n\n    :param self: Access variables that belong to the class\n    :param hidden_states: chex.Array: Pass the hidden states of the previous layer\n    :param freq_cis: chex.Array: Pass in the frequency coefficients for each position\n    :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n    :param position_ids: chex.Array: Determine the position of each token in a sequence\n    :param causal_mask: chex.Array: Mask out the future tokens in the decoder\n    :param deterministic: bool: Determine whether to use dropout or not\n    :param init_cache: bool: Initialize the cache\n    :param output_attentions: bool: Determine whether to return the attention weights or not\n    :param fcm_mask: Mask out the attention weights between the input and output tokens\n    :param : Determine if the attention is causal or not\n    :return: A tuple of two arrays\n\n    \"\"\"\n    batch_size, sequence_length = hidden_states.shape[:2]\n    query_state, key_state, value_state = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(\n        hidden_states)\n\n    if self.config.use_pjit_attention_force:\n        query_state = with_sharding_constraint(query_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n        key_state = with_sharding_constraint(key_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n        value_state = with_sharding_constraint(value_state, PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\"))\n\n    query_state = query_state.reshape(batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n    key_state = key_state.reshape(batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n    value_state = value_state.reshape(batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n    query_state, key_state, value_state = self.apply_rotary(\n        query=query_state,\n        key=key_state,\n        value=value_state,\n        position_ids=position_ids,\n        freq_cis=freq_cis,\n        batch_size=batch_size,\n        sequence_length=sequence_length\n    )\n\n    assert_msg = (\n        \"num_attention_heads repeat wont work likely\\n\"\n        f\"INFO :\\n\\trepeat_kv_bnsh Used with num_key_value_groups = {self.num_key_value_groups}\\n\\t\"\n        f\"NH : {self.config.num_attention_heads} KVH : {self.config.num_attention_heads}\"\n    )\n\n    assert query_state.shape[-2] == self.config.num_attention_heads, assert_msg\n    assert key_state.shape[-2] == self.config.num_attention_heads, assert_msg\n    assert value_state.shape[-2] == self.config.num_attention_heads, assert_msg\n\n    query_length, key_length = query_state.shape[1], key_state.shape[1]\n\n    if self.has_variable(\"cache\", \"cached_key\"):\n        mask_shift = self.variables[\"cache\"][\"cache_index\"]\n        max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n        causal_mask = lax.dynamic_slice(\n            causal_mask, (0, 0, mask_shift, 0), (1, 1,\n                                                 query_length, max_decoder_length)\n        )\n    else:\n        causal_mask = causal_mask[:, :, :query_length, :key_length]\n\n    batch_size = hidden_states.shape[0]\n    causal_mask = jnp.broadcast_to(\n        causal_mask, (batch_size,) + causal_mask.shape[1:])\n    attention_mask = jnp.broadcast_to(jnp.expand_dims(\n        attention_mask, axis=(-3, -2)), causal_mask.shape)\n    attention_mask = combine_masks(attention_mask, causal_mask, fcm_mask)\n    if attention_mask.ndim == 2:\n        attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n\n    dropout_rng = None\n\n    if not deterministic and self.config.attention_dropout &gt; 0.0:\n        dropout_rng = self.make_rng(\"dropout\")\n\n    if self.has_variable(\"cache\", \"cached_key\") or init_cache:\n        key_state, value_state, attention_mask = self._concatenate_to_cache(\n            key_state,\n            value_state,\n            query_state,\n            attention_mask\n        )\n\n    attention_bias = lax.select(\n        attention_mask &gt; 0,\n        jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n        jnp.full(attention_mask.shape, jnp.finfo(\n            self.dtype).min).astype(self.dtype),\n    )\n\n    query_state, key_state, value_state = map(\n        lambda a: a.transpose(0, 2, 1, 3),\n        [query_state, key_state, value_state]\n    )\n\n    query_length, key_length = query_state.shape[-2], key_state.shape[-2]\n\n    attentions = self.attention_performer.__call__(\n        query_states=query_state,\n        key_states=key_state,\n        value_states=value_state,\n        bias=attention_bias,\n        causal=False,\n        use_pjit_attention_force=self.config.use_pjit_attention_force,\n        dropout_rng=dropout_rng,\n        deterministic=deterministic,\n        query_sequence_length=query_length,\n        key_value_sequence_length=key_length,\n        uses_cache=self.has_variable(\"cache\", \"cached_key\") or init_cache,\n    )\n    attentions.attention_outputs = attentions.attention_outputs.transpose(0, 2, 1, 3)\n\n    attn_output = self._merge_heads(attentions.attention_outputs)\n    attn_output = self.o_proj(attn_output)\n\n    attn_output = self.resid_dropout(\n        attn_output, deterministic=deterministic)\n    outputs = (\n        attn_output, attentions.attention_weights\n    ) if output_attentions else (\n        attn_output,\n    )\n    return outputs\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2Attention.apply_rotary","title":"<code>apply_rotary(batch_size, sequence_length, query, key, value, freq_cis, position_ids)</code>","text":"<p>The apply_rotary function is a modified version of the apply_attention function in the BertModel class. The main difference is that it takes in an additional argument, freq_cis, which are used to calculate the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>batch_size</code> <p>Reshape the query, key and value tensors</p> required <code>sequence_length</code> <p>Reshape the query, key and value tensors</p> required <code>query</code> <p>Calculate the attention weights</p> required <code>key</code> <p>Calculate the attention</p> required <code>value</code> <p>Compute the attention weights</p> required <code>freq_cis</code> <p>Calculate the frequency of each word in the vocabulary</p> required <code>position_ids</code> <p>Identify the position of each token in the sequence</p> required <p>Returns:</p> Type Description <p>A tuple of 3 tensors: query, key and value</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def apply_rotary(self, batch_size, sequence_length, query, key, value, freq_cis, position_ids):\n    \"\"\"\n    The apply_rotary function is a modified version of the apply_attention function in the BertModel class.\n    The main difference is that it takes in an additional argument, freq_cis, which are used to calculate\n    the rotary attention weights. The other differences are minor and mostly related to reshaping tensors.\n\n    :param self: Access variables that belong to the class\n    :param batch_size: Reshape the query, key and value tensors\n    :param sequence_length: Reshape the query, key and value tensors\n    :param query: Calculate the attention weights\n    :param key: Calculate the attention\n    :param value: Compute the attention weights\n    :param freq_cis: Calculate the frequency of each word in the vocabulary\n    :param position_ids: Identify the position of each token in the sequence\n    :return: A tuple of 3 tensors: query, key and value\n\n    \"\"\"\n    query = query.reshape(batch_size, sequence_length, self.config.num_attention_heads, self.head_dim)\n    key = key.reshape(batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n    value = value.reshape(batch_size, sequence_length, self.config.num_key_value_heads, self.head_dim)\n\n    query, key, value = self._t(query, key, value)\n    query, key = self.rotary(\n        position_ids=position_ids, query=query, key=key, freq_cis=freq_cis\n    )\n    key = repeat_kv_bnsh(key, self.num_key_value_groups)\n    value = repeat_kv_bnsh(value, self.num_key_value_groups)\n    return self._t(query, key, value)\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2Block","title":"<code>FlaxQwen2Block</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2Block(nn.Module):\n    config: Qwen2Config\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self) -&gt; None:\n        attn_block = FlaxQwen2Attention\n        if self.config.gradient_checkpointing != \"\":\n            attn_block = nn_partitioning.remat(\n                FlaxQwen2Attention, static_argnums=(5, 6, 7),\n                policy=get_gradient_checkpoint_policy(\n                    self.config.gradient_checkpointing)\n            )\n\n        self.self_attn = attn_block(\n            self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        mlp_block = FlaxQwen2MLP\n\n        if self.config.gradient_checkpointing != \"\":\n            mlp_block = nn_partitioning.remat(\n                FlaxQwen2MLP, static_argnums=(1,),\n                policy=get_gradient_checkpoint_policy(\n                    self.config.gradient_checkpointing)\n            )\n\n        self.mlp = mlp_block(\n            self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision,\n        )\n        self.input_layernorm = Qwen2RMSNorm(\n            self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n        )\n        self.post_attention_layernorm = Qwen2RMSNorm(\n            self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n\n        )\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            causal_mask: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            fcm_mask: Optional[jnp.ndarray] = None,\n    ):\n        \"\"\"\n        The __call__ function is the main function of a TransformerEncoderLayer.\n        It takes in hidden states, frequency-domain inputs, and masks as input. It then\n        applies self-attention to the hidden states using those inputs and returns an\n        output tensor with shape (batch_size, sequence_length, model_dim).\n\n        :param self: Refer to the class instance itself\n        :param hidden_states: chex.Array: Pass in the hidden state of the previous layer\n        :param freq_cis: chex.Array: Pass in the frequency information\n        :param attention_mask: chex.Array: Mask out the attention weights for padding tokens\n        :param position_ids: chex.Array: Determine the position of each token in the sequence\n        :param causal_mask: chex.Array: Mask the attention weights\n        :param deterministic: bool: Control whether the dropout is applied or not\n        :param init_cache: bool: Initialize the cache in the attention layer\n        :param output_attentions: bool: Return the attention weights\n        :param fcm_mask: Optional[jnp.ndarray]: Mask the self-attention\n        :param : Control the dropout in the self attention layer\n        :return: A tuple of two items\n\n        \"\"\"\n        attn_outputs = self.self_attn(\n            self.input_layernorm(hidden_states),\n            freq_cis,\n            attention_mask,\n            position_ids,\n            causal_mask,\n            deterministic,\n            init_cache,\n            output_attentions,\n            fcm_mask,\n        )\n        attn_output = attn_outputs[0]\n        hidden_states = hidden_states + attn_output\n\n        feed_forward_input = self.post_attention_layernorm(hidden_states)\n\n        if self.config.use_sacn_mlp:\n            feed_forward_input = einops.rearrange(\n                feed_forward_input,\n                '... (b s) d -&gt; ... b s d',\n                b=self.config.scan_mlp_chunk_size\n            )\n\n            def mlp_forward(mlp, carry, x):\n                return None, mlp(x, deterministic)\n\n            scan_axis = feed_forward_input.ndim - 3\n\n            _, feed_forward_hidden_states = nn.scan(\n                mlp_forward,\n                variable_broadcast=\"params\",\n                split_rngs={\"params\": False, \"dropout\": True},\n                in_axes=scan_axis,\n                out_axes=scan_axis,\n            )(self.mlp, None, feed_forward_input)\n            feed_forward_hidden_states = einops.rearrange(\n                feed_forward_hidden_states,\n                '... b s d -&gt; ... (b s) d'\n            )\n        else:\n            feed_forward_hidden_states = self.mlp(\n                feed_forward_input,\n                deterministic,\n            )\n\n        hidden_states = hidden_states + feed_forward_hidden_states\n\n        return (hidden_states,) + attn_outputs[1:]\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2Block.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, position_ids, causal_mask, deterministic=True, init_cache=False, output_attentions=False, fcm_mask=None)</code>","text":"<p>The call function is the main function of a TransformerEncoderLayer. It takes in hidden states, frequency-domain inputs, and masks as input. It then applies self-attention to the hidden states using those inputs and returns an output tensor with shape (batch_size, sequence_length, model_dim).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the class instance itself</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass in the hidden state of the previous layer</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass in the frequency information</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the attention weights for padding tokens</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Determine the position of each token in the sequence</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask the attention weights</p> required <code>deterministic</code> <code>bool</code> <p>bool: Control whether the dropout is applied or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache in the attention layer</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Return the attention weights</p> <code>False</code> <code>fcm_mask</code> <code>Optional[ndarray]</code> <p>Optional[jnp.ndarray]: Mask the self-attention</p> <code>None</code> <code></code> <p>Control the dropout in the self attention layer</p> required <p>Returns:</p> Type Description <p>A tuple of two items</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        causal_mask: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        fcm_mask: Optional[jnp.ndarray] = None,\n):\n    \"\"\"\n    The __call__ function is the main function of a TransformerEncoderLayer.\n    It takes in hidden states, frequency-domain inputs, and masks as input. It then\n    applies self-attention to the hidden states using those inputs and returns an\n    output tensor with shape (batch_size, sequence_length, model_dim).\n\n    :param self: Refer to the class instance itself\n    :param hidden_states: chex.Array: Pass in the hidden state of the previous layer\n    :param freq_cis: chex.Array: Pass in the frequency information\n    :param attention_mask: chex.Array: Mask out the attention weights for padding tokens\n    :param position_ids: chex.Array: Determine the position of each token in the sequence\n    :param causal_mask: chex.Array: Mask the attention weights\n    :param deterministic: bool: Control whether the dropout is applied or not\n    :param init_cache: bool: Initialize the cache in the attention layer\n    :param output_attentions: bool: Return the attention weights\n    :param fcm_mask: Optional[jnp.ndarray]: Mask the self-attention\n    :param : Control the dropout in the self attention layer\n    :return: A tuple of two items\n\n    \"\"\"\n    attn_outputs = self.self_attn(\n        self.input_layernorm(hidden_states),\n        freq_cis,\n        attention_mask,\n        position_ids,\n        causal_mask,\n        deterministic,\n        init_cache,\n        output_attentions,\n        fcm_mask,\n    )\n    attn_output = attn_outputs[0]\n    hidden_states = hidden_states + attn_output\n\n    feed_forward_input = self.post_attention_layernorm(hidden_states)\n\n    if self.config.use_sacn_mlp:\n        feed_forward_input = einops.rearrange(\n            feed_forward_input,\n            '... (b s) d -&gt; ... b s d',\n            b=self.config.scan_mlp_chunk_size\n        )\n\n        def mlp_forward(mlp, carry, x):\n            return None, mlp(x, deterministic)\n\n        scan_axis = feed_forward_input.ndim - 3\n\n        _, feed_forward_hidden_states = nn.scan(\n            mlp_forward,\n            variable_broadcast=\"params\",\n            split_rngs={\"params\": False, \"dropout\": True},\n            in_axes=scan_axis,\n            out_axes=scan_axis,\n        )(self.mlp, None, feed_forward_input)\n        feed_forward_hidden_states = einops.rearrange(\n            feed_forward_hidden_states,\n            '... b s d -&gt; ... (b s) d'\n        )\n    else:\n        feed_forward_hidden_states = self.mlp(\n            feed_forward_input,\n            deterministic,\n        )\n\n    hidden_states = hidden_states + feed_forward_hidden_states\n\n    return (hidden_states,) + attn_outputs[1:]\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2BlockCollection","title":"<code>FlaxQwen2BlockCollection</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2BlockCollection(nn.Module):\n    config: Qwen2Config\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        self.blocks = [\n            FlaxQwen2Block(\n                self.config,\n                name=str(i),\n                dtype=self.dtype,\n                param_dtype=self.param_dtype,\n                precision=self.precision\n            )\n            for i in range(\n                self.config.num_hidden_layers\n            )\n        ]\n\n    def __call__(\n            self,\n            hidden_states: chex.Array,\n            freq_cis: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            causal_mask: chex.Array,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n    ):\n        \"\"\"\n        The __call__ function is the main function of a JAX nn.Module.\n        It defines how the module behaves when called as a function, and it's what you'll use to call your model\n         in training loops or inference scripts.\n        The __call__ method should take all inputs that are necessary for computing outputs from the module,\n        and return all outputs that are computed by this module.\n\n        :param self: Represent the instance of the class\n        :param hidden_states: chex.Array: Pass the input tensor to the encoder\n        :param freq_cis: chex.Array: Pass in the frequency of each token\n        :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n        :param position_ids: chex.Array: Specify the position of each token in a sequence\n        :param causal_mask: chex.Array: Mask the attention weights\n        :param deterministic: bool: Determine whether the model is in training or evaluation mode\n        :param init_cache: bool: Initialize the cache for each layer\n        :param output_attentions: bool: Determine whether to output the attention weights\n        :param output_hidden_states: bool: Determine whether to return the hidden states of each layer\n        :param return_dict: bool: Return a dictionary of the outputs\n        :param : Determine whether to use the forgetful causal mask\n        :return: A tuple of 3 values\n\n        \"\"\"\n        all_attentions = () if output_attentions else None\n        all_hidden_states = () if output_hidden_states else None\n\n        if not deterministic and self.config.fcm_max_ratio &gt; 0:\n            # Apply forgetful causal mask\n            batch_size, seq_length = hidden_states.shape[0], hidden_states.shape[1]\n            fcm_ratio = jax.random.uniform(\n                self.make_rng('fcm'), shape=(batch_size, 1, 1, 1),\n                minval=self.config.fcm_min_ratio,\n                maxval=self.config.fcm_max_ratio\n            )\n            fcm_mask = jax.random.uniform(\n                self.make_rng('fcm'),\n                shape=(batch_size, 1, seq_length, seq_length)\n            ) &gt; fcm_ratio\n            fcm_mask = fcm_mask.at[:, :, :, 0].set(True)\n            fcm_mask = fcm_mask.astype('bool')\n        else:\n            fcm_mask = None\n\n        for block in self.blocks:\n            if output_hidden_states:\n                all_hidden_states += (hidden_states,)\n\n            layer_outputs = block(\n                hidden_states=hidden_states,\n                freq_cis=freq_cis,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                causal_mask=causal_mask,\n                deterministic=deterministic,\n                init_cache=init_cache,\n                output_attentions=output_attentions,\n                fcm_mask=fcm_mask,\n            )\n            hidden_states = layer_outputs[0]\n\n            if output_attentions:\n                all_attentions += (layer_outputs[1],)\n\n        outputs = (hidden_states, all_hidden_states, all_attentions)\n\n        return outputs\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2BlockCollection.__call__","title":"<code>__call__(hidden_states, freq_cis, attention_mask, position_ids, causal_mask, deterministic=True, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True)</code>","text":"<p>The call function is the main function of a JAX nn.Module. It defines how the module behaves when called as a function, and it's what you'll use to call your model  in training loops or inference scripts. The call method should take all inputs that are necessary for computing outputs from the module, and return all outputs that are computed by this module.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass the input tensor to the encoder</p> required <code>freq_cis</code> <code>Array</code> <p>chex.Array: Pass in the frequency of each token</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out certain tokens in the input sequence</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in a sequence</p> required <code>causal_mask</code> <code>Array</code> <p>chex.Array: Mask the attention weights</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether the model is in training or evaluation mode</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for each layer</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to output the attention weights</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Determine whether to return the hidden states of each layer</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of the outputs</p> <code>True</code> <code></code> <p>Determine whether to use the forgetful causal mask</p> required <p>Returns:</p> Type Description <p>A tuple of 3 values</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __call__(\n        self,\n        hidden_states: chex.Array,\n        freq_cis: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        causal_mask: chex.Array,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n):\n    \"\"\"\n    The __call__ function is the main function of a JAX nn.Module.\n    It defines how the module behaves when called as a function, and it's what you'll use to call your model\n     in training loops or inference scripts.\n    The __call__ method should take all inputs that are necessary for computing outputs from the module,\n    and return all outputs that are computed by this module.\n\n    :param self: Represent the instance of the class\n    :param hidden_states: chex.Array: Pass the input tensor to the encoder\n    :param freq_cis: chex.Array: Pass in the frequency of each token\n    :param attention_mask: chex.Array: Mask out certain tokens in the input sequence\n    :param position_ids: chex.Array: Specify the position of each token in a sequence\n    :param causal_mask: chex.Array: Mask the attention weights\n    :param deterministic: bool: Determine whether the model is in training or evaluation mode\n    :param init_cache: bool: Initialize the cache for each layer\n    :param output_attentions: bool: Determine whether to output the attention weights\n    :param output_hidden_states: bool: Determine whether to return the hidden states of each layer\n    :param return_dict: bool: Return a dictionary of the outputs\n    :param : Determine whether to use the forgetful causal mask\n    :return: A tuple of 3 values\n\n    \"\"\"\n    all_attentions = () if output_attentions else None\n    all_hidden_states = () if output_hidden_states else None\n\n    if not deterministic and self.config.fcm_max_ratio &gt; 0:\n        # Apply forgetful causal mask\n        batch_size, seq_length = hidden_states.shape[0], hidden_states.shape[1]\n        fcm_ratio = jax.random.uniform(\n            self.make_rng('fcm'), shape=(batch_size, 1, 1, 1),\n            minval=self.config.fcm_min_ratio,\n            maxval=self.config.fcm_max_ratio\n        )\n        fcm_mask = jax.random.uniform(\n            self.make_rng('fcm'),\n            shape=(batch_size, 1, seq_length, seq_length)\n        ) &gt; fcm_ratio\n        fcm_mask = fcm_mask.at[:, :, :, 0].set(True)\n        fcm_mask = fcm_mask.astype('bool')\n    else:\n        fcm_mask = None\n\n    for block in self.blocks:\n        if output_hidden_states:\n            all_hidden_states += (hidden_states,)\n\n        layer_outputs = block(\n            hidden_states=hidden_states,\n            freq_cis=freq_cis,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            causal_mask=causal_mask,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            fcm_mask=fcm_mask,\n        )\n        hidden_states = layer_outputs[0]\n\n        if output_attentions:\n            all_attentions += (layer_outputs[1],)\n\n    outputs = (hidden_states, all_hidden_states, all_attentions)\n\n    return outputs\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2ForCausalLM","title":"<code>FlaxQwen2ForCausalLM</code>","text":"<p>             Bases: <code>FlaxQwen2PreTrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2ForCausalLM(FlaxQwen2PreTrainedModel):\n    module_class = FlaxQwen2ForCausalLMModule\n\n    def set_input_embeddings(self, value):\n        self.module.model.embed_tokens = value\n\n    def get_input_embeddings(self):\n        return self.module.model.embed_tokens\n\n    def set_decoder(self, decoder):\n        self.module.model = decoder\n\n    def get_decoder(self):\n        return self.module.model\n\n    def get_output_embeddings(self):\n        return self.module.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.module.lm_head = new_embeddings\n\n    def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n        \"\"\"\n        The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.\n\n        :param self: Access variables that belong to the class\n        :param input_ids: Pass in the input tokens\n        :param max_length: Set the length of the sequence to be generated\n        :param attention_mask: Optional[chex.Array]: Mask the attention weights\n        :return: A dictionary of the past_key_values, attention_mask and position ids\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n\n        past_key_values = self.init_cache(batch_size, max_length)\n        extended_attention_mask = jnp.ones(\n            (batch_size, max_length), dtype=\"i4\")\n        if attention_mask is not None:\n            position_ids = attention_mask.cumsum(axis=-1) - 1\n            extended_attention_mask = lax.dynamic_update_slice(\n                extended_attention_mask, attention_mask, (0, 0))\n        else:\n            position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[\n                                            None, :], (batch_size, seq_length))\n\n        return {\n            \"past_key_values\": past_key_values,\n            \"attention_mask\": extended_attention_mask,\n            \"position_ids\": position_ids,\n        }\n\n    def update_inputs_for_generation(self, model_outputs, model_kwargs):\n        model_kwargs[\"past_key_values\"] = model_outputs.past_key_values\n        model_kwargs[\"position_ids\"] = model_kwargs[\"position_ids\"][:, -1:] + 1\n        return model_kwargs\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2ForCausalLM.prepare_inputs_for_generation","title":"<code>prepare_inputs_for_generation(input_ids, max_length, attention_mask=None)</code>","text":"<p>The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>input_ids</code> <p>Pass in the input tokens</p> required <code>max_length</code> <p>Set the length of the sequence to be generated</p> required <code>attention_mask</code> <code>Optional[Array]</code> <p>Optional[chex.Array]: Mask the attention weights</p> <code>None</code> <p>Returns:</p> Type Description <p>A dictionary of the past_key_values, attention_mask and position ids</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def prepare_inputs_for_generation(self, input_ids, max_length, attention_mask: Optional[chex.Array] = None):\n    \"\"\"\n    The prepare_inputs_for_generation function is used to prepare the inputs for a generation task.\n\n    :param self: Access variables that belong to the class\n    :param input_ids: Pass in the input tokens\n    :param max_length: Set the length of the sequence to be generated\n    :param attention_mask: Optional[chex.Array]: Mask the attention weights\n    :return: A dictionary of the past_key_values, attention_mask and position ids\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n\n    past_key_values = self.init_cache(batch_size, max_length)\n    extended_attention_mask = jnp.ones(\n        (batch_size, max_length), dtype=\"i4\")\n    if attention_mask is not None:\n        position_ids = attention_mask.cumsum(axis=-1) - 1\n        extended_attention_mask = lax.dynamic_update_slice(\n            extended_attention_mask, attention_mask, (0, 0))\n    else:\n        position_ids = jnp.broadcast_to(jnp.arange(seq_length, dtype=\"i4\")[\n                                        None, :], (batch_size, seq_length))\n\n    return {\n        \"past_key_values\": past_key_values,\n        \"attention_mask\": extended_attention_mask,\n        \"position_ids\": position_ids,\n    }\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2ForCausalLMModule","title":"<code>FlaxQwen2ForCausalLMModule</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2ForCausalLMModule(nn.Module):\n    config: Qwen2Config\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        self.model = FlaxQwen2Module(\n            self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision,\n        )\n\n        self.lm_head = nn.Dense(\n            self.config.vocab_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(stddev=self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array = None,\n            position_ids: chex.Array = None,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n    ):\n        \"\"\"\n        The __call__ function is the main function of a Flax module. It takes in inputs and returns outputs.\n\n        :param self: Refer to the object itself\n        :param input_ids: chex.Array: Pass the input token ids to the model\n        :param attention_mask: chex.Array: Mask out the padding tokens\n        :param position_ids: chex.Array: Specify the position of each token in the input sequence\n        :param deterministic: bool: Control whether the model is trained or not\n        :param init_cache: bool: Initialize the cache for the decoder\n        :param output_attentions: bool: Return the attention weights\n        :param output_hidden_states: bool: Determine whether to return the hidden states\n        :param return_dict: bool: Return a dictionary of the outputs or not\n        :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of the word that we want to predict\n        :param None]]: Pass in the extra embedding\n        :return: The logits and the hidden states\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n        if attention_mask is None:\n            attention_mask = jnp.ones_like(input_ids)\n        if position_ids is None:\n            position_ids = jnp.broadcast_to(\n                jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n                (batch_size, seq_length)\n            )\n        outputs = self.model(\n            input_ids,\n            attention_mask,\n            position_ids,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            extra_embedding=extra_embedding\n        )\n\n        hidden_states = outputs[0]\n\n        if self.config.tie_word_embeddings:\n            shared_kernel = self.model.variables[\"params\"][\"embed_tokens\"][\"embedding\"].T\n            lm_logits = self.lm_head.apply(\n                {\"params\": {\"kernel\": shared_kernel}}, hidden_states)\n        else:\n            lm_logits = self.lm_head(hidden_states)\n\n        lm_logits = lm_logits.astype(jnp.float32)\n\n        if not return_dict:\n            return (lm_logits,) + outputs[1:]\n\n        return FlaxCausalLMOutput(logits=lm_logits, hidden_states=outputs.hidden_states, attentions=outputs.attentions)\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2ForCausalLMModule.__call__","title":"<code>__call__(input_ids, attention_mask=None, position_ids=None, deterministic=True, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True, extra_embedding=None)</code>","text":"<p>The call function is the main function of a Flax module. It takes in inputs and returns outputs.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass the input token ids to the model</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the padding tokens</p> <code>None</code> <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in the input sequence</p> <code>None</code> <code>deterministic</code> <code>bool</code> <p>bool: Control whether the model is trained or not</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the decoder</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Return the attention weights</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Determine whether to return the hidden states</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of the outputs or not</p> <code>True</code> <code>extra_embedding</code> <code>Optional[Union[ndarray, None]]</code> <p>Optional[Union[jnp.ndarray: Pass in the embedding of the word that we want to predict</p> <code>None</code> <code>None]]</code> <p>Pass in the extra embedding</p> required <p>Returns:</p> Type Description <p>The logits and the hidden states</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array = None,\n        position_ids: chex.Array = None,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n):\n    \"\"\"\n    The __call__ function is the main function of a Flax module. It takes in inputs and returns outputs.\n\n    :param self: Refer to the object itself\n    :param input_ids: chex.Array: Pass the input token ids to the model\n    :param attention_mask: chex.Array: Mask out the padding tokens\n    :param position_ids: chex.Array: Specify the position of each token in the input sequence\n    :param deterministic: bool: Control whether the model is trained or not\n    :param init_cache: bool: Initialize the cache for the decoder\n    :param output_attentions: bool: Return the attention weights\n    :param output_hidden_states: bool: Determine whether to return the hidden states\n    :param return_dict: bool: Return a dictionary of the outputs or not\n    :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of the word that we want to predict\n    :param None]]: Pass in the extra embedding\n    :return: The logits and the hidden states\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n    if attention_mask is None:\n        attention_mask = jnp.ones_like(input_ids)\n    if position_ids is None:\n        position_ids = jnp.broadcast_to(\n            jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n            (batch_size, seq_length)\n        )\n    outputs = self.model(\n        input_ids,\n        attention_mask,\n        position_ids,\n        deterministic=deterministic,\n        init_cache=init_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n        extra_embedding=extra_embedding\n    )\n\n    hidden_states = outputs[0]\n\n    if self.config.tie_word_embeddings:\n        shared_kernel = self.model.variables[\"params\"][\"embed_tokens\"][\"embedding\"].T\n        lm_logits = self.lm_head.apply(\n            {\"params\": {\"kernel\": shared_kernel}}, hidden_states)\n    else:\n        lm_logits = self.lm_head(hidden_states)\n\n    lm_logits = lm_logits.astype(jnp.float32)\n\n    if not return_dict:\n        return (lm_logits,) + outputs[1:]\n\n    return FlaxCausalLMOutput(logits=lm_logits, hidden_states=outputs.hidden_states, attentions=outputs.attentions)\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2ForSequenceClassificationModule","title":"<code>FlaxQwen2ForSequenceClassificationModule</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2ForSequenceClassificationModule(nn.Module):\n    num_classes: int\n    config: Qwen2Config\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n        \"\"\"\n        The setup function is called once at the beginning of training.\n        It initializes the model and optimizer, and sets up any other state that needs to be initialized.\n\n        :param self: Access variables that belong to the class\n        :return: A tuple of the model and the classifier\n        \"\"\"\n        self.model = FlaxQwen2Module(self.config, dtype=self.dtype)\n        self.classifier = nn.Dense(\n            self.num_classes,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                stddev=self.config.initializer_range),\n            precision=self.precision,\n        )\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array = None,\n            position_ids: chex.Array = None,\n            deterministic: bool = True,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n    ):\n        \"\"\"\n        The __call__ function is the main function of a Flax module.\n        It takes in all the inputs to the model and returns all outputs from it.\n        The __call__ function can be called directly on an instance of a class, or by using parentheses after an instance:\n            &amp;gt;&amp;gt;&amp;gt; my_model = MyModel()  # instantiate your model class\n            &amp;gt;&amp;gt;&amp;gt; output = my_model(input)  # call your model with input data as arguments to __call__\n\n        :param self: Refer to the class instance\n        :param input_ids: chex.Array: Pass the input to the model\n        :param attention_mask: chex.Array: Specify which tokens are masked\n        :param position_ids: chex.Array: Specify the position of each token in the sequence\n        :param deterministic: bool: Control whether the model is run in deterministic or stochastic mode\n        :param init_cache: bool: Initialize the cache for the transformer\n        :param output_attentions: bool: Return the attention weights\n        :param output_hidden_states: bool: Return the hidden states of all layers\n        :param return_dict: bool: Return a dictionary of outputs\n        :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of a new word\n        :param None]]: Pass the extra embedding to the model\n        :return: A tuple of logits and hidden_states\n\n        \"\"\"\n        batch_size, seq_length = input_ids.shape\n        if attention_mask is None:\n            attention_mask = jnp.ones_like(input_ids)\n        if position_ids is None:\n            position_ids = jnp.broadcast_to(\n                jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n                (batch_size, seq_length)\n            )\n        outputs = self.model(\n            input_ids,\n            attention_mask,\n            position_ids,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            extra_embedding=extra_embedding\n        )\n\n        hidden_states = outputs[0]\n        prediction = self.classifier(hidden_states)\n        if return_dict:\n            return FlaxSequenceClassifierOutput(\n                logits=prediction,\n                hidden_states=hidden_states\n            )\n        else:\n            return prediction,\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2ForSequenceClassificationModule.__call__","title":"<code>__call__(input_ids, attention_mask=None, position_ids=None, deterministic=True, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True, extra_embedding=None)</code>","text":"<p>The call function is the main function of a Flax module. It takes in all the inputs to the model and returns all outputs from it. The call function can be called directly on an instance of a class, or by using parentheses after an instance:     &gt;&gt;&gt; my_model = MyModel()  # instantiate your model class     &gt;&gt;&gt; output = my_model(input)  # call your model with input data as arguments to call</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the class instance</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass the input to the model</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Specify which tokens are masked</p> <code>None</code> <code>position_ids</code> <code>Array</code> <p>chex.Array: Specify the position of each token in the sequence</p> <code>None</code> <code>deterministic</code> <code>bool</code> <p>bool: Control whether the model is run in deterministic or stochastic mode</p> <code>True</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache for the transformer</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Return the attention weights</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Return the hidden states of all layers</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of outputs</p> <code>True</code> <code>extra_embedding</code> <code>Optional[Union[ndarray, None]]</code> <p>Optional[Union[jnp.ndarray: Pass in the embedding of a new word</p> <code>None</code> <code>None]]</code> <p>Pass the extra embedding to the model</p> required <p>Returns:</p> Type Description <p>A tuple of logits and hidden_states</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array = None,\n        position_ids: chex.Array = None,\n        deterministic: bool = True,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n):\n    \"\"\"\n    The __call__ function is the main function of a Flax module.\n    It takes in all the inputs to the model and returns all outputs from it.\n    The __call__ function can be called directly on an instance of a class, or by using parentheses after an instance:\n        &amp;gt;&amp;gt;&amp;gt; my_model = MyModel()  # instantiate your model class\n        &amp;gt;&amp;gt;&amp;gt; output = my_model(input)  # call your model with input data as arguments to __call__\n\n    :param self: Refer to the class instance\n    :param input_ids: chex.Array: Pass the input to the model\n    :param attention_mask: chex.Array: Specify which tokens are masked\n    :param position_ids: chex.Array: Specify the position of each token in the sequence\n    :param deterministic: bool: Control whether the model is run in deterministic or stochastic mode\n    :param init_cache: bool: Initialize the cache for the transformer\n    :param output_attentions: bool: Return the attention weights\n    :param output_hidden_states: bool: Return the hidden states of all layers\n    :param return_dict: bool: Return a dictionary of outputs\n    :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of a new word\n    :param None]]: Pass the extra embedding to the model\n    :return: A tuple of logits and hidden_states\n\n    \"\"\"\n    batch_size, seq_length = input_ids.shape\n    if attention_mask is None:\n        attention_mask = jnp.ones_like(input_ids)\n    if position_ids is None:\n        position_ids = jnp.broadcast_to(\n            jnp.clip(jnp.cumsum(attention_mask, axis=-1) - 1, a_min=0),\n            (batch_size, seq_length)\n        )\n    outputs = self.model(\n        input_ids,\n        attention_mask,\n        position_ids,\n        deterministic=deterministic,\n        init_cache=init_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n        extra_embedding=extra_embedding\n    )\n\n    hidden_states = outputs[0]\n    prediction = self.classifier(hidden_states)\n    if return_dict:\n        return FlaxSequenceClassifierOutput(\n            logits=prediction,\n            hidden_states=hidden_states\n        )\n    else:\n        return prediction,\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2ForSequenceClassificationModule.setup","title":"<code>setup()</code>","text":"<p>The setup function is called once at the beginning of training. It initializes the model and optimizer, and sets up any other state that needs to be initialized.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <p>Returns:</p> Type Description <p>A tuple of the model and the classifier</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def setup(self):\n    \"\"\"\n    The setup function is called once at the beginning of training.\n    It initializes the model and optimizer, and sets up any other state that needs to be initialized.\n\n    :param self: Access variables that belong to the class\n    :return: A tuple of the model and the classifier\n    \"\"\"\n    self.model = FlaxQwen2Module(self.config, dtype=self.dtype)\n    self.classifier = nn.Dense(\n        self.num_classes,\n        dtype=self.dtype,\n        param_dtype=self.param_dtype,\n        use_bias=False,\n        kernel_init=jax.nn.initializers.normal(\n            stddev=self.config.initializer_range),\n        precision=self.precision,\n    )\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2MLP","title":"<code>FlaxQwen2MLP</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2MLP(nn.Module):\n    config: Qwen2Config\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self) -&gt; None:\n        config = self.config\n\n        self.gate_proj = nn.Dense(\n            config.intermediate_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range\n            ),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.down_proj = nn.Dense(\n            config.hidden_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.up_proj = nn.Dense(\n            config.intermediate_size,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(\n                self.config.initializer_range),\n            precision=self.precision,\n            **get_dot_general_by_bits(self.config.bits, self.config.easy_method)\n        )\n        self.dropout = nn.Dropout(rate=self.config.resid_pdrop)\n\n    def __call__(self, x: jnp.ndarray, deterministic: bool = True) -&gt; jnp.ndarray:\n        \"\"\"\n        The __call__ function is the main function of a class.\n        It is called when an instance of the class (an object) is invoked as a function, i.e., obj(arguments).\n        The __call__ method enables instances of a class to be called like standard Python functions.\n\n        :param self: Represent the instance of the class\n        :param x: jnp.ndarray: Pass in the input to the layer\n        :param deterministic: bool: Determine whether to use dropout\n        :return: A tensor that is the result of applying a dropout function to x\n\n        \"\"\"\n        x = self.down_proj(nn.silu(self.gate_proj(x)) * self.up_proj(x))\n        x = self.dropout(x, deterministic=deterministic)\n        return x\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2MLP.__call__","title":"<code>__call__(x, deterministic=True)</code>","text":"<p>The call function is the main function of a class. It is called when an instance of the class (an object) is invoked as a function, i.e., obj(arguments). The call method enables instances of a class to be called like standard Python functions.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>x</code> <code>ndarray</code> <p>jnp.ndarray: Pass in the input to the layer</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A tensor that is the result of applying a dropout function to x</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __call__(self, x: jnp.ndarray, deterministic: bool = True) -&gt; jnp.ndarray:\n    \"\"\"\n    The __call__ function is the main function of a class.\n    It is called when an instance of the class (an object) is invoked as a function, i.e., obj(arguments).\n    The __call__ method enables instances of a class to be called like standard Python functions.\n\n    :param self: Represent the instance of the class\n    :param x: jnp.ndarray: Pass in the input to the layer\n    :param deterministic: bool: Determine whether to use dropout\n    :return: A tensor that is the result of applying a dropout function to x\n\n    \"\"\"\n    x = self.down_proj(nn.silu(self.gate_proj(x)) * self.up_proj(x))\n    x = self.dropout(x, deterministic=deterministic)\n    return x\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2Module","title":"<code>FlaxQwen2Module</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2Module(nn.Module):\n    config: Qwen2Config\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[Union[jax.lax.Precision, str]] = None\n\n    def setup(self):\n\n        self.embed_tokens = nn.Embed(\n            self.config.vocab_size,\n            self.config.hidden_size,\n            embedding_init=jax.nn.initializers.normal(\n                stddev=self.config.initializer_range\n            ),\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n        )\n        self.dropout = nn.Dropout(rate=self.config.embd_pdrop)\n        self.layers = FlaxQwen2BlockCollection(\n            self.config,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision\n        )\n        self.norm = Qwen2RMSNorm(\n            self.config.hidden_size,\n            eps=self.config.rms_norm_eps,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype\n        )\n        config = self.config\n        self.causal_mask = make_causal_mask(\n            jnp.ones((1, config.max_position_embeddings))\n        )\n\n        initial_rope_kwargs = dict(\n            rope_type=\"none\"\n        )\n        if config.rope_scaling is not None:\n            scaling_type = config.rope_scaling[\"type\"]\n            scaling_factor = config.rope_scaling[\"factor\"]\n            initial_rope_kwargs = dict(\n                scaling_factor=scaling_factor,\n                rope_type=scaling_type\n            )\n        self.freq_cis = precompute_freq_cis(\n            max_position_embeddings=config.max_position_embeddings,\n            dim=config.hidden_size // config.num_attention_heads,\n            base=config.rope_theta,\n            **initial_rope_kwargs\n        )\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array,\n            position_ids: chex.Array,\n            deterministic: bool = True,\n            inputs_embeds: chex.Array = None,\n            init_cache: bool = False,\n            output_attentions: bool = False,\n            output_hidden_states: bool = False,\n            return_dict: bool = True,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n    ):\n        \"\"\"\n        The __call__ function is the main function of a Flax model. It takes in input_ids, attention_mask, and position_ids\n        and returns the output of the model. The __call__ function also has optional arguments that can be used to control\n        the behavior of the model (e.g., deterministic=True). These optional arguments are passed as keyword arguments when\n        calling a Flax model.\n\n        :param self: Represent the instance of the class\n        :param input_ids: chex.Array: Pass in the input token ids\n        :param attention_mask: chex.Array: Mask out the padding tokens\n        :param position_ids: chex.Array: Indicate the position of each token in a sequence\n        :param deterministic: bool: Control whether dropout is applied or not\n        :param inputs_embeds: chex.Array: Pass in the embeddings of the input tokens\n        :param init_cache: bool: Initialize the cache\n        :param output_attentions: bool: Determine whether to return the attentions or not\n        :param output_hidden_states: bool: Determine whether to return hidden states\n        :param return_dict: bool: Return a dictionary of the output or not\n        :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of the\n        :param None]]: Pass in the extra embedding\n        :return: A tuple of:\n\n        \"\"\"\n        if inputs_embeds is None:\n            inputs_embeds = self.embed_tokens(input_ids.astype(\"i4\"))\n\n        batch_size, sequence_length, _ = inputs_embeds.shape\n\n        assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n        inputs_embeds = inputs_embeds + extra_embedding if extra_embedding is not None else inputs_embeds\n        hidden_states = self.dropout(\n            inputs_embeds, deterministic=deterministic)\n\n        outputs = self.layers(\n            hidden_states=hidden_states,\n            freq_cis=self.freq_cis,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            causal_mask=self.causal_mask,\n            deterministic=deterministic,\n            init_cache=init_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n\n        hidden_states = outputs[0]\n        hidden_states = self.norm(hidden_states)\n\n        if output_hidden_states:\n            all_hidden_states = outputs[1] + (hidden_states,)\n            outputs = (hidden_states, all_hidden_states) + outputs[2:]\n        else:\n            outputs = (hidden_states,) + outputs[1:]\n\n        if not return_dict:\n            return tuple(v for v in outputs if v is not None)\n\n        return FlaxBaseModelOutput(\n            last_hidden_state=hidden_states,\n            hidden_states=outputs[1],\n            attentions=outputs[-1],\n        )\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2Module.__call__","title":"<code>__call__(input_ids, attention_mask, position_ids, deterministic=True, inputs_embeds=None, init_cache=False, output_attentions=False, output_hidden_states=False, return_dict=True, extra_embedding=None)</code>","text":"<p>The call function is the main function of a Flax model. It takes in input_ids, attention_mask, and position_ids and returns the output of the model. The call function also has optional arguments that can be used to control the behavior of the model (e.g., deterministic=True). These optional arguments are passed as keyword arguments when calling a Flax model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass in the input token ids</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out the padding tokens</p> required <code>position_ids</code> <code>Array</code> <p>chex.Array: Indicate the position of each token in a sequence</p> required <code>deterministic</code> <code>bool</code> <p>bool: Control whether dropout is applied or not</p> <code>True</code> <code>inputs_embeds</code> <code>Array</code> <p>chex.Array: Pass in the embeddings of the input tokens</p> <code>None</code> <code>init_cache</code> <code>bool</code> <p>bool: Initialize the cache</p> <code>False</code> <code>output_attentions</code> <code>bool</code> <p>bool: Determine whether to return the attentions or not</p> <code>False</code> <code>output_hidden_states</code> <code>bool</code> <p>bool: Determine whether to return hidden states</p> <code>False</code> <code>return_dict</code> <code>bool</code> <p>bool: Return a dictionary of the output or not</p> <code>True</code> <code>extra_embedding</code> <code>Optional[Union[ndarray, None]]</code> <p>Optional[Union[jnp.ndarray: Pass in the embedding of the</p> <code>None</code> <code>None]]</code> <p>Pass in the extra embedding</p> required <p>Returns:</p> Type Description <p>A tuple of:</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array,\n        position_ids: chex.Array,\n        deterministic: bool = True,\n        inputs_embeds: chex.Array = None,\n        init_cache: bool = False,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        extra_embedding: Optional[Union[jnp.ndarray, None]] = None\n):\n    \"\"\"\n    The __call__ function is the main function of a Flax model. It takes in input_ids, attention_mask, and position_ids\n    and returns the output of the model. The __call__ function also has optional arguments that can be used to control\n    the behavior of the model (e.g., deterministic=True). These optional arguments are passed as keyword arguments when\n    calling a Flax model.\n\n    :param self: Represent the instance of the class\n    :param input_ids: chex.Array: Pass in the input token ids\n    :param attention_mask: chex.Array: Mask out the padding tokens\n    :param position_ids: chex.Array: Indicate the position of each token in a sequence\n    :param deterministic: bool: Control whether dropout is applied or not\n    :param inputs_embeds: chex.Array: Pass in the embeddings of the input tokens\n    :param init_cache: bool: Initialize the cache\n    :param output_attentions: bool: Determine whether to return the attentions or not\n    :param output_hidden_states: bool: Determine whether to return hidden states\n    :param return_dict: bool: Return a dictionary of the output or not\n    :param extra_embedding: Optional[Union[jnp.ndarray: Pass in the embedding of the\n    :param None]]: Pass in the extra embedding\n    :return: A tuple of:\n\n    \"\"\"\n    if inputs_embeds is None:\n        inputs_embeds = self.embed_tokens(input_ids.astype(\"i4\"))\n\n    batch_size, sequence_length, _ = inputs_embeds.shape\n\n    assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n    inputs_embeds = inputs_embeds + extra_embedding if extra_embedding is not None else inputs_embeds\n    hidden_states = self.dropout(\n        inputs_embeds, deterministic=deterministic)\n\n    outputs = self.layers(\n        hidden_states=hidden_states,\n        freq_cis=self.freq_cis,\n        attention_mask=attention_mask,\n        position_ids=position_ids,\n        causal_mask=self.causal_mask,\n        deterministic=deterministic,\n        init_cache=init_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n\n    hidden_states = outputs[0]\n    hidden_states = self.norm(hidden_states)\n\n    if output_hidden_states:\n        all_hidden_states = outputs[1] + (hidden_states,)\n        outputs = (hidden_states, all_hidden_states) + outputs[2:]\n    else:\n        outputs = (hidden_states,) + outputs[1:]\n\n    if not return_dict:\n        return tuple(v for v in outputs if v is not None)\n\n    return FlaxBaseModelOutput(\n        last_hidden_state=hidden_states,\n        hidden_states=outputs[1],\n        attentions=outputs[-1],\n    )\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2PreTrainedModel","title":"<code>FlaxQwen2PreTrainedModel</code>","text":"<p>             Bases: <code>EasyDelFlaxPretrainedModel</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>class FlaxQwen2PreTrainedModel(EasyDelFlaxPretrainedModel):\n    config_class = Qwen2Config\n    base_model_prefix = \"model\"\n    module_class: nn.Module = None\n\n    def __init__(\n            self,\n            config: Qwen2Config,\n            input_shape: Tuple = (1, 1),\n            seed: int = 0,\n            dtype: jnp.dtype = jnp.float32,\n            _do_init: bool = True,\n            **kwargs,\n    ):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the instance of the class, and defines what happens when it's created.\n        The __init__ function can take arguments, but self is always required (it refers to the instance of the object).\n\n\n        :param self: Refer to the object itself\n        :param config: Qwen2Config: Pass the configuration to the module\n        :param input_shape: Tuple: Specify the shape of the input to the model\n        :param seed: int: Set the seed for random number generation\n        :param dtype: jnp.dtype: Specify the data type of the input\n        :param _do_init: bool: Control whether the module is initialized or not\n        :param kwargs: Pass in any additional parameters that the module_class might need\n        :param : Specify the number of layers in the network\n        :return: The super() of the class\n\n        \"\"\"\n        module = self.module_class(config=config, dtype=dtype, **kwargs)\n        super().__init__(config, module, input_shape=input_shape, seed=seed, dtype=dtype, _do_init=_do_init)\n\n    def init_weights(self, rng: jax.random.PRNGKey, input_shape: Tuple, params: FrozenDict = None) -&gt; FrozenDict:\n        \"\"\"\n        The init_weights function is used to initialize the weights of a model.\n\n        :param self: Access variables that belong to the class\n        :param rng: jax.random.PRNGKey: Initialize the weights of the model\n        :param input_shape: Tuple: Specify the shape of the input tensor\n        :param params: FrozenDict: Pass in the parameters of a pre-trained model\n        :return: A frozendict of parameters\n\n        \"\"\"\n        input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(jnp.atleast_2d(input_ids).shape[-1]), input_shape)\n        params_rng, dropout_rng = jax.random.split(rng)\n        rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n        if self.config.add_cross_attention:\n            encoder_hidden_states = jnp.zeros(\n                input_shape + (self.config.hidden_size,))\n            encoder_attention_mask = attention_mask\n            module_init_outputs = self.module.init(\n                rngs,\n                input_ids,\n                attention_mask,\n                position_ids,\n                encoder_hidden_states,\n                encoder_attention_mask,\n                return_dict=False,\n            )\n        else:\n            module_init_outputs = self.module.init(\n                rngs, input_ids, attention_mask, position_ids, return_dict=False)\n\n        random_params = module_init_outputs[\"params\"]\n\n        if params is not None:\n            random_params = flatten_dict(unfreeze(random_params))\n            params = flatten_dict(unfreeze(params))\n            for missing_key in self._missing_keys:\n                params[missing_key] = random_params[missing_key]\n            self._missing_keys = set()\n            return freeze(unflatten_dict(params))\n        else:\n            return random_params\n\n    def init_cache(self, batch_size, max_length):\n        \"\"\"\n        The init_cache function is used to initialize the cache for a given batch size and sequence length.\n        The cache is a dictionary that contains all the intermediate states from each layer in the model.\n        This allows us to run inference on multiple batches without having to re-run forward passes through every layer in\n        the model, which would be very slow.\n\n        :param self: Access the module\n        :param batch_size: Define the batch size of the input tensors\n        :param max_length: Set the length of the input sequence\n        :return: A dictionary with the following keys:\n\n        \"\"\"\n        input_ids = jnp.ones((batch_size, max_length))\n        attention_mask = jnp.ones_like(input_ids)\n        position_ids = jnp.broadcast_to(jnp.arange(\n            jnp.atleast_2d(input_ids).shape[-1]), input_ids.shape)\n\n        init_variables = self.module.init(\n            jax.random.PRNGKey(0), input_ids, attention_mask, position_ids, return_dict=False, init_cache=True\n        )\n        return init_variables[\"cache\"]\n\n    def __call__(\n            self,\n            input_ids: chex.Array,\n            attention_mask: chex.Array = None,\n            position_ids: chex.Array = None,\n            params: dict = None,\n            past_key_values: dict = None,\n            dropout_rng: jax.random.PRNGKey = None,\n            train: bool = False,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            return_dict: Optional[bool] = None,\n            extra_embedding: Optional[Union[jnp.ndarray, None]] = None,\n            add_params_field: bool = False,\n            **kwargs\n    ):\n        \"\"\"\n        The __call__ function is the main function of a JAX module.\n        It takes in inputs and returns outputs, but it also has some other important features:\n        - It can take in mutable state (e.g., past_key_values) that will be updated during the call and returned at the end.\n        - It can take in random number generators (rngs) that are used to generate random numbers for dropout or sampling operations.\n\n        :param self: Represent the instance of the class\n        :param input_ids: chex.Array: Pass in the input tokens\n        :param attention_mask: chex.Array: Mask out certain tokens in the input\n        :param position_ids: chex.Array: Create the positional embeddings\n        :param params: dict: Pass in the parameters of the model\n        :param past_key_values: dict: Pass in the past key values from a previous call to __call__\n        :param dropout_rng: jax.random.PRNGKey: Make sure that the dropout is applied in a random way\n        :param train: bool: Determine whether to use dropout or not\n        :param output_attentions: Optional[bool]: Determine whether to return the attention weights\n        :param output_hidden_states: Optional[bool]: Return the hidden states of all layers\n        :param return_dict: Optional[bool]: Determine whether to return a dictionary or not\n        :param extra_embedding: Optional[Union[jnp.ndarray,None]]: Pass in the embedding for the input_ids\n        :param add_params_field: bool: Add the params field to the inputs dictionary\n        :return: A tuple of the following:\n\n        \"\"\"\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n        batch_size, sequence_length = input_ids.shape\n\n        assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n\n        if position_ids is None:\n            if past_key_values is not None:\n                raise ValueError(\n                    \"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n            position_ids = jnp.broadcast_to(jnp.arange(sequence_length)[\n                                            None, :], (batch_size, sequence_length))\n\n        if attention_mask is None:\n            attention_mask = jnp.ones((batch_size, sequence_length))\n\n        rngs = {}\n        if dropout_rng is not None:\n            rngs[\"dropout\"] = dropout_rng\n\n        if self.config.bits is not None:\n            rngs['params'] = jax.random.key(0)\n\n        inputs = {\n            \"params\": params or self.params\n        } if add_params_field else params or self.params\n\n        if past_key_values:\n            inputs[\"cache\"] = past_key_values\n            mutable = [\"cache\"]\n        else:\n            mutable = False\n\n        outputs = self.module.apply(\n            inputs,\n            jnp.array(input_ids, dtype=\"i4\"),\n            jnp.array(attention_mask, dtype=\"i4\"),\n            jnp.array(position_ids, dtype=\"i4\"),\n            not train,\n            False,\n            output_attentions,\n            output_hidden_states,\n            return_dict,\n            extra_embedding,\n            rngs=rngs,\n            mutable=mutable,\n        )\n\n        if past_key_values is not None and return_dict:\n            outputs, past_key_values = outputs\n            outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n            return outputs\n        elif past_key_values is not None and not return_dict:\n            outputs, past_key_values = outputs\n            outputs = outputs[:1] + \\\n                      (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n        return outputs\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2PreTrainedModel.__call__","title":"<code>__call__(input_ids, attention_mask=None, position_ids=None, params=None, past_key_values=None, dropout_rng=None, train=False, output_attentions=None, output_hidden_states=None, return_dict=None, extra_embedding=None, add_params_field=False, **kwargs)</code>","text":"<p>The call function is the main function of a JAX module. It takes in inputs and returns outputs, but it also has some other important features: - It can take in mutable state (e.g., past_key_values) that will be updated during the call and returned at the end. - It can take in random number generators (rngs) that are used to generate random numbers for dropout or sampling operations.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass in the input tokens</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask out certain tokens in the input</p> <code>None</code> <code>position_ids</code> <code>Array</code> <p>chex.Array: Create the positional embeddings</p> <code>None</code> <code>params</code> <code>dict</code> <p>dict: Pass in the parameters of the model</p> <code>None</code> <code>past_key_values</code> <code>dict</code> <p>dict: Pass in the past key values from a previous call to call</p> <code>None</code> <code>dropout_rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Make sure that the dropout is applied in a random way</p> <code>None</code> <code>train</code> <code>bool</code> <p>bool: Determine whether to use dropout or not</p> <code>False</code> <code>output_attentions</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine whether to return the attention weights</p> <code>None</code> <code>output_hidden_states</code> <code>Optional[bool]</code> <p>Optional[bool]: Return the hidden states of all layers</p> <code>None</code> <code>return_dict</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine whether to return a dictionary or not</p> <code>None</code> <code>extra_embedding</code> <code>Optional[Union[ndarray, None]]</code> <p>Optional[Union[jnp.ndarray,None]]: Pass in the embedding for the input_ids</p> <code>None</code> <code>add_params_field</code> <code>bool</code> <p>bool: Add the params field to the inputs dictionary</p> <code>False</code> <p>Returns:</p> Type Description <p>A tuple of the following:</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __call__(\n        self,\n        input_ids: chex.Array,\n        attention_mask: chex.Array = None,\n        position_ids: chex.Array = None,\n        params: dict = None,\n        past_key_values: dict = None,\n        dropout_rng: jax.random.PRNGKey = None,\n        train: bool = False,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        extra_embedding: Optional[Union[jnp.ndarray, None]] = None,\n        add_params_field: bool = False,\n        **kwargs\n):\n    \"\"\"\n    The __call__ function is the main function of a JAX module.\n    It takes in inputs and returns outputs, but it also has some other important features:\n    - It can take in mutable state (e.g., past_key_values) that will be updated during the call and returned at the end.\n    - It can take in random number generators (rngs) that are used to generate random numbers for dropout or sampling operations.\n\n    :param self: Represent the instance of the class\n    :param input_ids: chex.Array: Pass in the input tokens\n    :param attention_mask: chex.Array: Mask out certain tokens in the input\n    :param position_ids: chex.Array: Create the positional embeddings\n    :param params: dict: Pass in the parameters of the model\n    :param past_key_values: dict: Pass in the past key values from a previous call to __call__\n    :param dropout_rng: jax.random.PRNGKey: Make sure that the dropout is applied in a random way\n    :param train: bool: Determine whether to use dropout or not\n    :param output_attentions: Optional[bool]: Determine whether to return the attention weights\n    :param output_hidden_states: Optional[bool]: Return the hidden states of all layers\n    :param return_dict: Optional[bool]: Determine whether to return a dictionary or not\n    :param extra_embedding: Optional[Union[jnp.ndarray,None]]: Pass in the embedding for the input_ids\n    :param add_params_field: bool: Add the params field to the inputs dictionary\n    :return: A tuple of the following:\n\n    \"\"\"\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.return_dict\n\n    batch_size, sequence_length = input_ids.shape\n\n    assert sequence_length &lt;= self.config.max_position_embeddings, \"Maximum Position Embedding Reached !\"\n\n    if position_ids is None:\n        if past_key_values is not None:\n            raise ValueError(\n                \"Make sure to provide `position_ids` when passing `past_key_values`.\")\n\n        position_ids = jnp.broadcast_to(jnp.arange(sequence_length)[\n                                        None, :], (batch_size, sequence_length))\n\n    if attention_mask is None:\n        attention_mask = jnp.ones((batch_size, sequence_length))\n\n    rngs = {}\n    if dropout_rng is not None:\n        rngs[\"dropout\"] = dropout_rng\n\n    if self.config.bits is not None:\n        rngs['params'] = jax.random.key(0)\n\n    inputs = {\n        \"params\": params or self.params\n    } if add_params_field else params or self.params\n\n    if past_key_values:\n        inputs[\"cache\"] = past_key_values\n        mutable = [\"cache\"]\n    else:\n        mutable = False\n\n    outputs = self.module.apply(\n        inputs,\n        jnp.array(input_ids, dtype=\"i4\"),\n        jnp.array(attention_mask, dtype=\"i4\"),\n        jnp.array(position_ids, dtype=\"i4\"),\n        not train,\n        False,\n        output_attentions,\n        output_hidden_states,\n        return_dict,\n        extra_embedding,\n        rngs=rngs,\n        mutable=mutable,\n    )\n\n    if past_key_values is not None and return_dict:\n        outputs, past_key_values = outputs\n        outputs[\"past_key_values\"] = unfreeze(past_key_values[\"cache\"])\n        return outputs\n    elif past_key_values is not None and not return_dict:\n        outputs, past_key_values = outputs\n        outputs = outputs[:1] + \\\n                  (unfreeze(past_key_values[\"cache\"]),) + outputs[1:]\n\n    return outputs\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2PreTrainedModel.__init__","title":"<code>__init__(config, input_shape=(1, 1), seed=0, dtype=jnp.float32, _do_init=True, **kwargs)</code>","text":"<p>The init function is called when the class is instantiated. It sets up the instance of the class, and defines what happens when it's created. The init function can take arguments, but self is always required (it refers to the instance of the object).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>config</code> <code>Qwen2Config</code> <p>Qwen2Config: Pass the configuration to the module</p> required <code>input_shape</code> <code>Tuple</code> <p>Tuple: Specify the shape of the input to the model</p> <code>(1, 1)</code> <code>seed</code> <code>int</code> <p>int: Set the seed for random number generation</p> <code>0</code> <code>dtype</code> <code>dtype</code> <p>jnp.dtype: Specify the data type of the input</p> <code>float32</code> <code>_do_init</code> <code>bool</code> <p>bool: Control whether the module is initialized or not</p> <code>True</code> <code>kwargs</code> <p>Pass in any additional parameters that the module_class might need</p> <code>{}</code> <code></code> <p>Specify the number of layers in the network</p> required <p>Returns:</p> Type Description <p>The super() of the class</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def __init__(\n        self,\n        config: Qwen2Config,\n        input_shape: Tuple = (1, 1),\n        seed: int = 0,\n        dtype: jnp.dtype = jnp.float32,\n        _do_init: bool = True,\n        **kwargs,\n):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up the instance of the class, and defines what happens when it's created.\n    The __init__ function can take arguments, but self is always required (it refers to the instance of the object).\n\n\n    :param self: Refer to the object itself\n    :param config: Qwen2Config: Pass the configuration to the module\n    :param input_shape: Tuple: Specify the shape of the input to the model\n    :param seed: int: Set the seed for random number generation\n    :param dtype: jnp.dtype: Specify the data type of the input\n    :param _do_init: bool: Control whether the module is initialized or not\n    :param kwargs: Pass in any additional parameters that the module_class might need\n    :param : Specify the number of layers in the network\n    :return: The super() of the class\n\n    \"\"\"\n    module = self.module_class(config=config, dtype=dtype, **kwargs)\n    super().__init__(config, module, input_shape=input_shape, seed=seed, dtype=dtype, _do_init=_do_init)\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2PreTrainedModel.init_cache","title":"<code>init_cache(batch_size, max_length)</code>","text":"<p>The init_cache function is used to initialize the cache for a given batch size and sequence length. The cache is a dictionary that contains all the intermediate states from each layer in the model. This allows us to run inference on multiple batches without having to re-run forward passes through every layer in the model, which would be very slow.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the module</p> required <code>batch_size</code> <p>Define the batch size of the input tensors</p> required <code>max_length</code> <p>Set the length of the input sequence</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys:</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def init_cache(self, batch_size, max_length):\n    \"\"\"\n    The init_cache function is used to initialize the cache for a given batch size and sequence length.\n    The cache is a dictionary that contains all the intermediate states from each layer in the model.\n    This allows us to run inference on multiple batches without having to re-run forward passes through every layer in\n    the model, which would be very slow.\n\n    :param self: Access the module\n    :param batch_size: Define the batch size of the input tensors\n    :param max_length: Set the length of the input sequence\n    :return: A dictionary with the following keys:\n\n    \"\"\"\n    input_ids = jnp.ones((batch_size, max_length))\n    attention_mask = jnp.ones_like(input_ids)\n    position_ids = jnp.broadcast_to(jnp.arange(\n        jnp.atleast_2d(input_ids).shape[-1]), input_ids.shape)\n\n    init_variables = self.module.init(\n        jax.random.PRNGKey(0), input_ids, attention_mask, position_ids, return_dict=False, init_cache=True\n    )\n    return init_variables[\"cache\"]\n</code></pre>"},{"location":"generated-modules-qwen2-modelling_qwen_flax/#lib.python.EasyDel.modules.qwen2.modelling_qwen_flax.FlaxQwen2PreTrainedModel.init_weights","title":"<code>init_weights(rng, input_shape, params=None)</code>","text":"<p>The init_weights function is used to initialize the weights of a model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>rng</code> <code>PRNGKey</code> <p>jax.random.PRNGKey: Initialize the weights of the model</p> required <code>input_shape</code> <code>Tuple</code> <p>Tuple: Specify the shape of the input tensor</p> required <code>params</code> <code>FrozenDict</code> <p>FrozenDict: Pass in the parameters of a pre-trained model</p> <code>None</code> <p>Returns:</p> Type Description <code>FrozenDict</code> <p>A frozendict of parameters</p> Source code in <code>lib/python/EasyDel/modules/qwen2/modelling_qwen_flax.py</code> <pre><code>def init_weights(self, rng: jax.random.PRNGKey, input_shape: Tuple, params: FrozenDict = None) -&gt; FrozenDict:\n    \"\"\"\n    The init_weights function is used to initialize the weights of a model.\n\n    :param self: Access variables that belong to the class\n    :param rng: jax.random.PRNGKey: Initialize the weights of the model\n    :param input_shape: Tuple: Specify the shape of the input tensor\n    :param params: FrozenDict: Pass in the parameters of a pre-trained model\n    :return: A frozendict of parameters\n\n    \"\"\"\n    input_ids = jnp.zeros(input_shape, dtype=\"i4\")\n    attention_mask = jnp.ones_like(input_ids)\n    position_ids = jnp.broadcast_to(jnp.arange(jnp.atleast_2d(input_ids).shape[-1]), input_shape)\n    params_rng, dropout_rng = jax.random.split(rng)\n    rngs = {\"params\": params_rng, \"dropout\": dropout_rng}\n\n    if self.config.add_cross_attention:\n        encoder_hidden_states = jnp.zeros(\n            input_shape + (self.config.hidden_size,))\n        encoder_attention_mask = attention_mask\n        module_init_outputs = self.module.init(\n            rngs,\n            input_ids,\n            attention_mask,\n            position_ids,\n            encoder_hidden_states,\n            encoder_attention_mask,\n            return_dict=False,\n        )\n    else:\n        module_init_outputs = self.module.init(\n            rngs, input_ids, attention_mask, position_ids, return_dict=False)\n\n    random_params = module_init_outputs[\"params\"]\n\n    if params is not None:\n        random_params = flatten_dict(unfreeze(random_params))\n        params = flatten_dict(unfreeze(params))\n        for missing_key in self._missing_keys:\n            params[missing_key] = random_params[missing_key]\n        self._missing_keys = set()\n        return freeze(unflatten_dict(params))\n    else:\n        return random_params\n</code></pre>"},{"location":"generated-modules-qwen2-qwen_configuration/","title":"modules.qwen2.qwen_configuration","text":""},{"location":"generated-modules-qwen2-qwen_configuration/#lib.python.EasyDel.modules.qwen2.qwen_configuration.Qwen2Config","title":"<code>Qwen2Config</code>","text":"<p>             Bases: <code>EasyDelPretrainedConfig</code></p> Source code in <code>lib/python/EasyDel/modules/qwen2/qwen_configuration.py</code> <pre><code>class Qwen2Config(EasyDelPretrainedConfig):\n    model_type = \"qwen2\"\n\n    def __init__(\n            self,\n            vocab_size=151936,\n            hidden_size=4096,\n            intermediate_size=22016,\n            num_hidden_layers=32,\n            num_attention_heads=32,\n            num_key_value_heads=32,\n            hidden_act=\"silu\",\n            max_position_embeddings=32768,\n            initializer_range=0.02,\n            rms_norm_eps=1e-6,\n            use_cache=True,\n            tie_word_embeddings=False,\n            rope_theta=10000.0,\n            use_sliding_window=False,\n            sliding_window=4096,\n            max_window_layers=28,\n            attention_dropout=0.0,\n            resid_pdrop: float = 0.0,\n            embd_pdrop: float = 0.0,\n            gradient_checkpointing: str = \"nothing_saveable\",\n            fcm_min_ratio: float = 0.0,\n            fcm_max_ratio: float = 0.0,\n            use_pjit_attention_force: bool = False,\n            use_sacn_mlp: bool = False,\n            scan_mlp_chunk_size: int = 1024,\n            number_rep_kv: int = 1,\n            bits: Optional[int] = None,\n            scan_layers: bool = True,\n            rope_scaling: Optional[Mapping[str, str | float]] = None,\n            **kwargs,\n    ):\n        self.vocab_size = vocab_size\n        self.max_position_embeddings = max_position_embeddings\n        self.hidden_size = hidden_size\n        self.intermediate_size = intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.use_sliding_window = use_sliding_window\n        self.sliding_window = sliding_window\n        self.max_window_layers = max_window_layers\n\n        # for backward compatibility\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n\n        self.rope_scaling = rope_scaling\n        self.num_key_value_heads = num_key_value_heads\n        self.hidden_act = hidden_act\n        self.initializer_range = initializer_range\n        self.rms_norm_eps = rms_norm_eps\n        self.use_cache = use_cache\n        self.rope_theta = rope_theta\n        self.scan_layers = scan_layers\n        self.embd_pdrop = embd_pdrop\n        self.number_rep_kv = number_rep_kv\n        self.resid_pdrop = resid_pdrop\n        self.attention_dropout = attention_dropout\n        self.tie_word_embeddings = tie_word_embeddings\n        self.gradient_checkpointing = gradient_checkpointing\n        self.fcm_min_ratio = fcm_min_ratio\n        self.fcm_max_ratio = fcm_max_ratio\n        self.use_pjit_attention_force = use_pjit_attention_force\n        self.use_sacn_mlp = use_sacn_mlp\n        self.scan_mlp_chunk_size = scan_mlp_chunk_size\n        self.bits = bits\n        super().__init__(\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs,\n        )\n\n    def get_partition_rules(self, fully_sharded_data_parallel: bool = True):\n        \"\"\"\n        The get_partition_rules function is used to define the partitioning scheme for a model.\n        It returns a list of tuples, where each tuple contains two elements:\n            1) A regex string that matches the name of one or more parameters in the model.\n            2) A PartitionScheme object that defines how those parameters should be partitioned across devices.\n\n        :param fully_sharded_data_parallel: bool: Determine whether to partition the model fully or not\n        :return: A list of tuples\n\n        \"\"\"\n        return (\n\n            (\"model/embed_tokens/embedding\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n            (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n            (\"self_attn/o_proj/kernel\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n            (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n            (\"mlp/down_proj/kernel\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n            (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n\n            (\"input_layernorm/kernel\", PartitionSpec(None)),\n            (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n            (\"model/norm/kernel\", PartitionSpec(None)),\n            (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n            (\".*\", PartitionSpec(None)),\n        ) if not fully_sharded_data_parallel else (\n\n            (\"model/embed_tokens/embedding\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n            (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"self_attn/o_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/down_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n            (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n            (\"input_layernorm/kernel\", PartitionSpec(None)),\n            (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n            (\"model/norm/kernel\", PartitionSpec(None)),\n            (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n            (\".*\", PartitionSpec((\"fsdp\", \"sp\"))),\n        )\n\n    def add_jax_args(\n            self,\n            resid_pdrop: float = 0.0,\n            embd_pdrop: float = 0.0,\n            attention_dropout: float = 0.0,\n            tie_word_embeddings: bool = False,\n            gradient_checkpointing: str = \"nothing_saveable\",\n            fcm_min_ratio: float = 0.0,\n            fcm_max_ratio: float = 0.0,\n            use_pjit_attention_force: bool = False,\n            use_sacn_mlp: bool = False,\n            scan_mlp_chunk_size: int = 1024,\n            number_rep_kv: int = 1,\n            bits: Optional[int] = None,\n            rope_theta: float = 10000.,\n            hidden_act: str = \"silu\",\n            scan_layers: bool = True,\n            rope_scaling: Optional[Mapping[str, str | float]] = None,\n            **kwargs,\n    ):\n        \"\"\"\n        The add_jax_args function adds the following arguments to the Transformer class:\n\n        :param self: Refer to the current object\n        :param resid_pdrop: float: Set the dropout rate for residual connections\n        :param embd_pdrop: float: Set the probability of dropping an embedding\n        :param attention_dropout: float: Set the probability of dropping out the attention layer\n        :param tie_word_embeddings: bool: Tie the word embeddings to the decoder\n        :param gradient_checkpointing: str: Control the amount of memory used by jax\n        :param fcm_min_ratio: float: Control the minimum ratio of the number of chunks to be used in flash-based computation\n        :param fcm_max_ratio: float: Set the maximum ratio of the number of input tokens to output tokens\n        :param use_pjit_attention_force: bool: Determine if the attention force is used\n        :param use_sacn_mlp: bool: Determine whether to use the scan_mlp function or not\n        :param scan_mlp_chunk_size: int: Set the chunk size for scan_mlp\n        :param number_rep_kv: int: Determine how many times the key and value vectors are repeated\n        :param bits: Optional[int]: Determine the number of bits used in the quantization\n        :param rope_theta: float : rope_theta for compute rope\n        :param attention_bias: bool : whenever to use attention bias or no\n        :param hidden_act: str : hidden_act for mlp\n        :param scan_layers: bool: Determine whether to use scan layers or not\n        :return: The following:\n\n        \"\"\"\n        self.scan_layers = scan_layers\n        self.embd_pdrop = embd_pdrop\n        self.number_rep_kv = number_rep_kv\n        self.resid_pdrop = resid_pdrop\n        self.rope_theta = rope_theta\n        self.rope_scaling = rope_scaling\n        self.attention_dropout = attention_dropout\n        self.hidden_act = hidden_act\n        self.tie_word_embeddings = tie_word_embeddings\n        self.gradient_checkpointing = gradient_checkpointing\n        self.fcm_min_ratio = fcm_min_ratio\n        self.fcm_max_ratio = fcm_max_ratio\n        self.use_pjit_attention_force = use_pjit_attention_force\n\n        self.use_sacn_mlp = use_sacn_mlp\n        self.scan_mlp_chunk_size = scan_mlp_chunk_size\n        self.bits = bits\n\n    @staticmethod\n    def get_weight_decay_exclusions():\n        return tuple()\n\n    @staticmethod\n    def rng_keys():\n        return \"params\", \"dropout\", \"fcm\"\n</code></pre>"},{"location":"generated-modules-qwen2-qwen_configuration/#lib.python.EasyDel.modules.qwen2.qwen_configuration.Qwen2Config.add_jax_args","title":"<code>add_jax_args(resid_pdrop=0.0, embd_pdrop=0.0, attention_dropout=0.0, tie_word_embeddings=False, gradient_checkpointing='nothing_saveable', fcm_min_ratio=0.0, fcm_max_ratio=0.0, use_pjit_attention_force=False, use_sacn_mlp=False, scan_mlp_chunk_size=1024, number_rep_kv=1, bits=None, rope_theta=10000.0, hidden_act='silu', scan_layers=True, rope_scaling=None, **kwargs)</code>","text":"<p>The add_jax_args function adds the following arguments to the Transformer class:</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the current object</p> required <code>resid_pdrop</code> <code>float</code> <p>float: Set the dropout rate for residual connections</p> <code>0.0</code> <code>embd_pdrop</code> <code>float</code> <p>float: Set the probability of dropping an embedding</p> <code>0.0</code> <code>attention_dropout</code> <code>float</code> <p>float: Set the probability of dropping out the attention layer</p> <code>0.0</code> <code>tie_word_embeddings</code> <code>bool</code> <p>bool: Tie the word embeddings to the decoder</p> <code>False</code> <code>gradient_checkpointing</code> <code>str</code> <p>str: Control the amount of memory used by jax</p> <code>'nothing_saveable'</code> <code>fcm_min_ratio</code> <code>float</code> <p>float: Control the minimum ratio of the number of chunks to be used in flash-based computation</p> <code>0.0</code> <code>fcm_max_ratio</code> <code>float</code> <p>float: Set the maximum ratio of the number of input tokens to output tokens</p> <code>0.0</code> <code>use_pjit_attention_force</code> <code>bool</code> <p>bool: Determine if the attention force is used</p> <code>False</code> <code>use_sacn_mlp</code> <code>bool</code> <p>bool: Determine whether to use the scan_mlp function or not</p> <code>False</code> <code>scan_mlp_chunk_size</code> <code>int</code> <p>int: Set the chunk size for scan_mlp</p> <code>1024</code> <code>number_rep_kv</code> <code>int</code> <p>int: Determine how many times the key and value vectors are repeated</p> <code>1</code> <code>bits</code> <code>Optional[int]</code> <p>Optional[int]: Determine the number of bits used in the quantization</p> <code>None</code> <code>rope_theta</code> <code>float</code> <p>float : rope_theta for compute rope</p> <code>10000.0</code> <code>attention_bias</code> <p>bool : whenever to use attention bias or no</p> required <code>hidden_act</code> <code>str</code> <p>str : hidden_act for mlp</p> <code>'silu'</code> <code>scan_layers</code> <code>bool</code> <p>bool: Determine whether to use scan layers or not</p> <code>True</code> <p>Returns:</p> Type Description <p>The following:</p> Source code in <code>lib/python/EasyDel/modules/qwen2/qwen_configuration.py</code> <pre><code>def add_jax_args(\n        self,\n        resid_pdrop: float = 0.0,\n        embd_pdrop: float = 0.0,\n        attention_dropout: float = 0.0,\n        tie_word_embeddings: bool = False,\n        gradient_checkpointing: str = \"nothing_saveable\",\n        fcm_min_ratio: float = 0.0,\n        fcm_max_ratio: float = 0.0,\n        use_pjit_attention_force: bool = False,\n        use_sacn_mlp: bool = False,\n        scan_mlp_chunk_size: int = 1024,\n        number_rep_kv: int = 1,\n        bits: Optional[int] = None,\n        rope_theta: float = 10000.,\n        hidden_act: str = \"silu\",\n        scan_layers: bool = True,\n        rope_scaling: Optional[Mapping[str, str | float]] = None,\n        **kwargs,\n):\n    \"\"\"\n    The add_jax_args function adds the following arguments to the Transformer class:\n\n    :param self: Refer to the current object\n    :param resid_pdrop: float: Set the dropout rate for residual connections\n    :param embd_pdrop: float: Set the probability of dropping an embedding\n    :param attention_dropout: float: Set the probability of dropping out the attention layer\n    :param tie_word_embeddings: bool: Tie the word embeddings to the decoder\n    :param gradient_checkpointing: str: Control the amount of memory used by jax\n    :param fcm_min_ratio: float: Control the minimum ratio of the number of chunks to be used in flash-based computation\n    :param fcm_max_ratio: float: Set the maximum ratio of the number of input tokens to output tokens\n    :param use_pjit_attention_force: bool: Determine if the attention force is used\n    :param use_sacn_mlp: bool: Determine whether to use the scan_mlp function or not\n    :param scan_mlp_chunk_size: int: Set the chunk size for scan_mlp\n    :param number_rep_kv: int: Determine how many times the key and value vectors are repeated\n    :param bits: Optional[int]: Determine the number of bits used in the quantization\n    :param rope_theta: float : rope_theta for compute rope\n    :param attention_bias: bool : whenever to use attention bias or no\n    :param hidden_act: str : hidden_act for mlp\n    :param scan_layers: bool: Determine whether to use scan layers or not\n    :return: The following:\n\n    \"\"\"\n    self.scan_layers = scan_layers\n    self.embd_pdrop = embd_pdrop\n    self.number_rep_kv = number_rep_kv\n    self.resid_pdrop = resid_pdrop\n    self.rope_theta = rope_theta\n    self.rope_scaling = rope_scaling\n    self.attention_dropout = attention_dropout\n    self.hidden_act = hidden_act\n    self.tie_word_embeddings = tie_word_embeddings\n    self.gradient_checkpointing = gradient_checkpointing\n    self.fcm_min_ratio = fcm_min_ratio\n    self.fcm_max_ratio = fcm_max_ratio\n    self.use_pjit_attention_force = use_pjit_attention_force\n\n    self.use_sacn_mlp = use_sacn_mlp\n    self.scan_mlp_chunk_size = scan_mlp_chunk_size\n    self.bits = bits\n</code></pre>"},{"location":"generated-modules-qwen2-qwen_configuration/#lib.python.EasyDel.modules.qwen2.qwen_configuration.Qwen2Config.get_partition_rules","title":"<code>get_partition_rules(fully_sharded_data_parallel=True)</code>","text":"<p>The get_partition_rules function is used to define the partitioning scheme for a model. It returns a list of tuples, where each tuple contains two elements:     1) A regex string that matches the name of one or more parameters in the model.     2) A PartitionScheme object that defines how those parameters should be partitioned across devices.</p> <p>Parameters:</p> Name Type Description Default <code>fully_sharded_data_parallel</code> <code>bool</code> <p>bool: Determine whether to partition the model fully or not</p> <code>True</code> <p>Returns:</p> Type Description <p>A list of tuples</p> Source code in <code>lib/python/EasyDel/modules/qwen2/qwen_configuration.py</code> <pre><code>def get_partition_rules(self, fully_sharded_data_parallel: bool = True):\n    \"\"\"\n    The get_partition_rules function is used to define the partitioning scheme for a model.\n    It returns a list of tuples, where each tuple contains two elements:\n        1) A regex string that matches the name of one or more parameters in the model.\n        2) A PartitionScheme object that defines how those parameters should be partitioned across devices.\n\n    :param fully_sharded_data_parallel: bool: Determine whether to partition the model fully or not\n    :return: A list of tuples\n\n    \"\"\"\n    return (\n\n        (\"model/embed_tokens/embedding\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n        (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n        (\"self_attn/o_proj/kernel\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n        (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n        (\"mlp/down_proj/kernel\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n        (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n\n        (\"input_layernorm/kernel\", PartitionSpec(None)),\n        (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n        (\"model/norm/kernel\", PartitionSpec(None)),\n        (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n        (\".*\", PartitionSpec(None)),\n    ) if not fully_sharded_data_parallel else (\n\n        (\"model/embed_tokens/embedding\", PartitionSpec(\"tp\", (\"fsdp\", \"sp\"))),\n\n        (\"self_attn/(q_proj|k_proj|v_proj)/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"self_attn/o_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"mlp/gate_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/down_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n        (\"mlp/up_proj/kernel\", PartitionSpec((\"fsdp\", \"sp\"))),\n\n        (\"input_layernorm/kernel\", PartitionSpec(None)),\n        (\"post_attention_layernorm/kernel\", PartitionSpec(None)),\n\n        (\"model/norm/kernel\", PartitionSpec(None)),\n        (\"lm_head/kernel\", PartitionSpec((\"fsdp\", \"sp\"), \"tp\")),\n        (\".*\", PartitionSpec((\"fsdp\", \"sp\"))),\n    )\n</code></pre>"},{"location":"generated-modules-roberta-modelling_roberta_flax/","title":"modules.roberta.modelling_roberta_flax","text":""},{"location":"generated-modules-roberta-roberta_configuration/","title":"modules.roberta.roberta_configuration","text":""},{"location":"generated-modules-t5-modelling_t5_flax/","title":"modules.t5.modelling_t5_flax","text":"<p>Flax T5 model.</p>"},{"location":"generated-modules-t5-modelling_t5_flax/#lib.python.EasyDel.modules.t5.modelling_t5_flax.FlaxT5Attention","title":"<code>FlaxT5Attention</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/modules/t5/modelling_t5_flax.py</code> <pre><code>class FlaxT5Attention(nn.Module):\n    config: T5Config\n    has_relative_attention_bias: bool = False\n    causal: bool = False\n    dtype: jnp.dtype = jnp.bfloat16  # the dtype of the computation\n\n    def setup(self):\n        self.relative_attention_num_buckets = self.config.relative_attention_num_buckets\n        self.relative_attention_max_distance = self.config.relative_attention_max_distance\n        self.d_model = self.config.d_model\n        self.key_value_proj_dim = self.config.d_kv\n        self.n_heads = self.config.num_heads\n        self.dropout = self.config.dropout_rate\n        self.inner_dim = self.n_heads * self.key_value_proj_dim\n\n        q_init_std = self.config.initializer_factor * ((self.inner_dim * self.key_value_proj_dim) ** -0.5)\n        kv_init_std = self.config.initializer_factor * (self.inner_dim ** -0.5)\n        o_init_std = self.config.initializer_factor * (self.inner_dim ** -0.5)\n\n        self.q = nn.Dense(\n            self.inner_dim,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(q_init_std),\n            dtype=self.dtype,\n        )\n        self.k = nn.Dense(\n            self.inner_dim,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(kv_init_std),\n            dtype=self.dtype,\n        )\n        self.v = nn.Dense(\n            self.inner_dim,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(kv_init_std),\n            dtype=self.dtype,\n        )\n        self.o = nn.Dense(\n            self.d_model,\n            use_bias=False,\n            kernel_init=jax.nn.initializers.normal(o_init_std),\n            dtype=self.dtype,\n        )\n\n        if self.has_relative_attention_bias:\n            self.relative_attention_bias = nn.Embed(\n                self.relative_attention_num_buckets,\n                self.n_heads,\n                embedding_init=jax.nn.initializers.normal(kv_init_std),\n                dtype=self.dtype,\n            )\n\n    @staticmethod\n    def _relative_position_bucket(relative_position, bidirectional=True, num_buckets=32, max_distance=128):\n\n        relative_buckets = 0\n        if bidirectional:\n            num_buckets //= 2\n            relative_buckets += (relative_position &gt; 0) * num_buckets\n            relative_position = jnp.abs(relative_position)\n        else:\n            relative_position = -jnp.clip(relative_position, a_max=0)\n        # now relative_position is in the range [0, inf)\n\n        # half of the buckets are for exact increments in positions\n        max_exact = num_buckets // 2\n        is_small = relative_position &lt; max_exact\n\n        relative_position_if_large = max_exact + (\n                jnp.log(relative_position / max_exact) / jnp.log(max_distance / max_exact) * (num_buckets - max_exact)\n        )\n        relative_position_if_large = jnp.clip(relative_position_if_large, a_max=num_buckets - 1)\n\n        relative_buckets += jnp.where(is_small, relative_position, relative_position_if_large)\n\n        return relative_buckets.astype(\"i4\")\n\n    def compute_bias(self, query_length, key_length):\n        \"\"\"Compute binned relative position bias\"\"\"\n        context_position = jnp.arange(query_length, dtype=\"i4\")[:, None]\n        memory_position = jnp.arange(key_length, dtype=\"i4\")[None, :]\n\n        relative_position = memory_position - context_position\n        relative_position_bucket = self._relative_position_bucket(\n            relative_position,\n            bidirectional=(not self.causal),\n            num_buckets=self.relative_attention_num_buckets,\n            max_distance=self.relative_attention_max_distance,\n        )\n\n        values = self.relative_attention_bias(relative_position_bucket)\n        values = values.transpose((2, 0, 1))[None, :, :, :]\n        return values\n\n    def _split_heads(self, hidden_states):\n        return hidden_states.reshape(hidden_states.shape[:2] + (self.n_heads, self.key_value_proj_dim))\n\n    def _merge_heads(self, hidden_states):\n        return hidden_states.reshape(hidden_states.shape[:2] + (self.inner_dim,))\n\n    @nn.compact\n    def _concatenate_to_cache(self, key, value, query, attention_mask):\n\n        is_initialized = self.has_variable(\"cache\", \"cached_key\")\n        cached_key = self.variable(\"cache\", \"cached_key\", jnp.zeros, key.shape, key.dtype)\n        cached_value = self.variable(\"cache\", \"cached_value\", jnp.zeros, value.shape, value.dtype)\n        cache_index = self.variable(\"cache\", \"cache_index\", lambda: jax.Array(0, dtype=jnp.int32))\n\n        if is_initialized:\n            *batch_dims, max_length, num_heads, depth_per_head = cached_key.value.shape\n            # update key, value caches with our new 1d spatial slices\n            cur_index = cache_index.value\n            indices = (0,) * len(batch_dims) + (cur_index, 0, 0)\n            key = jax.lax.dynamic_update_slice(cached_key.value, key, indices)\n            value = jax.lax.dynamic_update_slice(cached_value.value, value, indices)\n            cached_key.value = key\n            cached_value.value = value\n            num_updated_cache_vectors = query.shape[1]\n            cache_index.value = cache_index.value + num_updated_cache_vectors\n            # causal mask for cached decoder self-attention: our single query position should only attend to those key positions\n            # that have already been generated and cached, not the remaining zero elements.\n            pad_mask = jnp.broadcast_to(\n                jnp.arange(max_length) &lt; cur_index + num_updated_cache_vectors,\n                tuple(batch_dims) + (1, num_updated_cache_vectors, max_length),\n            )\n            attention_mask = combine_masks(pad_mask, attention_mask)\n        return key, value, attention_mask\n\n    def _create_position_bias(\n            self, key_states, query_states, attention_mask, init_cache, seq_length, causal_attention_mask_shift\n    ):\n        cache_is_filled = self.causal and self.has_variable(\"cache\", \"cached_key\") and (not init_cache)\n        key_length = key_states.shape[1]\n        query_length = key_length if cache_is_filled else query_states.shape[1]\n\n        if self.has_relative_attention_bias:\n            position_bias = self.compute_bias(query_length, key_length)\n        elif attention_mask is not None:\n            position_bias = jnp.zeros_like(attention_mask)\n        else:\n            position_bias = jnp.zeros((1, self.n_heads, query_length, key_length), dtype=self.dtype)\n\n        # if key and values are already calculated, only the last query position bias should be taken\n        if cache_is_filled:\n            max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n            position_bias = jax.lax.dynamic_slice(\n                position_bias,\n                (0, 0, causal_attention_mask_shift, 0),\n                (1, self.n_heads, seq_length, max_decoder_length),\n            )\n        return position_bias\n\n    def __call__(\n            self,\n            hidden_states,\n            attention_mask=None,\n            key_value_states=None,\n            position_bias=None,\n            use_cache=False,\n            output_attentions=False,\n            deterministic=True,\n            init_cache=False,\n    ):\n\n        batch_size, seq_length = hidden_states.shape[:2]\n\n        # q, k, v projections\n        query_states = self.q(hidden_states)  # (batch_size, n_heads, seq_length, dim_per_head)\n        key_states = self.k(hidden_states) if key_value_states is None else self.k(key_value_states)\n        value_states = self.v(hidden_states) if key_value_states is None else self.v(key_value_states)\n        if self.config.use_pjit_attention_force:\n            query_states = with_sharding_constraint(query_states, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n            key_states = with_sharding_constraint(key_states, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n            value_states = with_sharding_constraint(value_states, PartitionSpec((\"dp\", \"fsdp\"), None, \"sp\"))\n\n        # reshape to (batch_size, seq_length, n_heads, head_dim)\n        query_states = self._split_heads(query_states)\n        key_states = self._split_heads(key_states)\n        value_states = self._split_heads(value_states)\n\n        # counter-act scaling in dot_product_attention_weights function\n        query_states *= jnp.sqrt(query_states.shape[-1])\n\n        # for fast decoding causal attention mask should be shifted\n        causal_attention_mask_shift = (\n            self.variables[\"cache\"][\"cache_index\"] if (self.has_variable(\"cache\", \"cached_key\") and self.causal) else 0\n        )\n        # create causal attention_mask; attention_mask has to be defined when model is causal\n        if self.causal:\n            causal_attention_mask = make_causal_mask(attention_mask, dtype=\"bool\")\n\n            # fast decoding for generate requires special attention_mask\n            if self.has_variable(\"cache\", \"cached_key\"):\n                max_decoder_length = self.variables[\"cache\"][\"cached_key\"].shape[1]\n                causal_attention_mask = jax.lax.dynamic_slice(\n                    causal_attention_mask,\n                    (0, 0, causal_attention_mask_shift, 0),\n                    (1, 1, seq_length, max_decoder_length),\n                )\n\n            # broadcast causal attention mask &amp; attention mask to fit for merge\n            causal_attention_mask = jnp.broadcast_to(\n                causal_attention_mask, (batch_size,) + causal_attention_mask.shape[1:]\n            )\n            attention_mask = jnp.broadcast_to(\n                jnp.expand_dims(attention_mask, axis=(-3, -2)), causal_attention_mask.shape\n            )\n            attention_mask = combine_masks(attention_mask, causal_attention_mask)\n        elif attention_mask is not None:\n            attention_mask = jnp.expand_dims(attention_mask, axis=(-3, -2))\n\n        # During fast autoregressive decoding, we feed one position at a time,\n        # and cache the keys and values step by step.\n        if self.causal and (self.has_variable(\"cache\", \"cached_key\") or init_cache):\n            key_states, value_states, attention_attention_mask = self._concatenate_to_cache(\n                key_states, value_states, query_states, attention_mask\n            )\n\n        # replace masked positions with -10_000\n        if attention_mask is not None:\n            mask_value = jnp.finfo(self.dtype).min\n            attention_mask = jax.lax.select(\n                attention_mask &gt; 0,\n                jnp.full(attention_mask.shape, 0.0).astype(self.dtype),\n                jnp.full(attention_mask.shape, mask_value).astype(self.dtype),\n            )\n\n        if position_bias is None:\n            # compute position bias (only for first layer)\n            position_bias = self._create_position_bias(\n                key_states, query_states, attention_mask, init_cache, seq_length, causal_attention_mask_shift\n            )\n\n            if attention_mask is not None:\n                position_bias = position_bias + attention_mask\n\n        # create dropout rng\n        dropout_rng = None\n        if not deterministic and self.dropout &gt; 0.0:\n            dropout_rng = self.make_rng(\"dropout\")\n\n        # Softmax(QK^T)\n        attn_weights = dot_product_attention_weights(\n            query_states,\n            key_states,\n            bias=position_bias,\n            dropout_rng=dropout_rng,\n            dropout_rate=self.dropout,\n            broadcast_dropout=True,\n            deterministic=deterministic,\n            dtype=self.dtype,\n        )\n\n        if self.config.use_pjit_attention_force:\n            attn_weights = with_sharding_constraint(attn_weights, PartitionSpec(\n                (\"dp\", \"fsdp\"), \"sp\", None, None\n            ))\n\n        # multiply with value states\n        attn_output = jnp.einsum(\"...hqk,...khd-&gt;...qhd\", attn_weights, value_states)\n\n        # bring back to (batch_size, seq_length, d_model)\n        attn_output = self._merge_heads(attn_output)\n\n        # apply output matrix\n        attn_output = self.o(attn_output)\n\n        outputs = (attn_output, position_bias)\n\n        if output_attentions:\n            outputs = outputs + (attn_weights,)\n\n        return outputs\n</code></pre>"},{"location":"generated-modules-t5-modelling_t5_flax/#lib.python.EasyDel.modules.t5.modelling_t5_flax.FlaxT5Attention.compute_bias","title":"<code>compute_bias(query_length, key_length)</code>","text":"<p>Compute binned relative position bias</p> Source code in <code>lib/python/EasyDel/modules/t5/modelling_t5_flax.py</code> <pre><code>def compute_bias(self, query_length, key_length):\n    \"\"\"Compute binned relative position bias\"\"\"\n    context_position = jnp.arange(query_length, dtype=\"i4\")[:, None]\n    memory_position = jnp.arange(key_length, dtype=\"i4\")[None, :]\n\n    relative_position = memory_position - context_position\n    relative_position_bucket = self._relative_position_bucket(\n        relative_position,\n        bidirectional=(not self.causal),\n        num_buckets=self.relative_attention_num_buckets,\n        max_distance=self.relative_attention_max_distance,\n    )\n\n    values = self.relative_attention_bias(relative_position_bucket)\n    values = values.transpose((2, 0, 1))[None, :, :, :]\n    return values\n</code></pre>"},{"location":"generated-modules-t5-modelling_t5_flax/#lib.python.EasyDel.modules.t5.modelling_t5_flax.shift_tokens_right","title":"<code>shift_tokens_right(input_ids, pad_token_id, decoder_start_token_id)</code>","text":"<p>Shift input ids one token to the right.</p> Source code in <code>lib/python/EasyDel/modules/t5/modelling_t5_flax.py</code> <pre><code>def shift_tokens_right(input_ids: np.array, pad_token_id: int, decoder_start_token_id: int) -&gt; np.ndarray:\n    \"\"\"\n    Shift input ids one token to the right.\n    \"\"\"\n    shifted_input_ids = jnp.zeros_like(input_ids)\n    shifted_input_ids = shifted_input_ids.at[:, 1:].set(input_ids[:, :-1])\n    shifted_input_ids = shifted_input_ids.at[:, 0].set(decoder_start_token_id)\n\n    shifted_input_ids = jnp.where(shifted_input_ids == -100, pad_token_id, shifted_input_ids)\n    return shifted_input_ids\n</code></pre>"},{"location":"generated-modules-t5-t5_configuration/","title":"modules.t5.t5_configuration","text":""},{"location":"generated-partitioning-partitioner/","title":"partitioning.partitioner","text":""},{"location":"generated-partitioning-partitioner/#lib.python.EasyDel.partitioning.partitioner.get_partitions","title":"<code>get_partitions(jax_attn_format=True, fsdp_on_batch=True)</code>","text":"<p>The get_partitions function is a helper function that returns an EasyDelPartitions object. The EasyDelPartitions object contains the PartitionSpec objects for each of the five tensors in the attention computation: query, key, value, bias and attention. The PartitionSpec objects are used to specify how each tensor should be partitioned across devices (i.e., which dimensions of each tensor should be split across devices). For example, if we want to split the batch dimension of all five tensors across two devices then we would set ``query_partition_spec=key_partition_spec=value_partition_spec=</p> <p>Parameters:</p> Name Type Description Default <code>jax_attn_format</code> <code>bool</code> <p>bool: Specify whether the attention</p> <code>True</code> <code>fsdp_on_batch</code> <code>bool</code> <p>bool: Determine whether the batch dimension is partitioned</p> <code>True</code> <p>Returns:</p> Type Description <code>EasyDelPartitions</code> <p>A easydelpartitions object</p> Source code in <code>lib/python/EasyDel/partitioning/partitioner.py</code> <pre><code>def get_partitions(\n        jax_attn_format: bool = True,\n        fsdp_on_batch: bool = True\n) -&gt; EasyDelPartitions:\n\n    \"\"\"\n    The get_partitions function is a helper function that returns an EasyDelPartitions object.\n    The EasyDelPartitions object contains the PartitionSpec objects for each of the five tensors in\n    the attention computation: query, key, value, bias and attention. The PartitionSpec objects are\n    used to specify how each tensor should be partitioned across devices (i.e., which dimensions of\n    each tensor should be split across devices). For example, if we want to split the batch dimension\n    of all five tensors across two devices then we would set ``query_partition_spec=key_partition_spec=value_partition_spec=\n\n    :param jax_attn_format: bool: Specify whether the attention\n    :param fsdp_on_batch: bool: Determine whether the batch dimension is partitioned\n    :return: A easydelpartitions object\n    \"\"\"\n    if jax_attn_format:\n        if fsdp_on_batch:\n            query_partition_spec = PartitionSpec(\"fsdp\", None, \"sp\", None)\n            key_partition_spec = PartitionSpec(\"fsdp\", None, \"sp\", None)\n            value_partition_spec = PartitionSpec(\"fsdp\", None, \"sp\", None)\n            bias_partition_spec = PartitionSpec(\"fsdp\", None, \"sp\", None)\n            attention_partition_spec = PartitionSpec(\"fsdp\", None, \"sp\", None)\n        else:\n            query_partition_spec = PartitionSpec(\"dp\", \"fsdp\", \"tp\", \"sp\", None)\n            key_partition_spec = PartitionSpec(\"dp\", \"fsdp\", \"tp\", \"sp\", None)\n            value_partition_spec = PartitionSpec(\"dp\", \"fsdp\", \"tp\", \"sp\", None)\n            bias_partition_spec = PartitionSpec(\"dp\", None, \"fsdp\", None)\n            attention_partition_spec = PartitionSpec(\"dp\", \"fsdp\", \"tp\", \"sp\", None)\n    else:\n        if fsdp_on_batch:\n            query_partition_spec = PartitionSpec(\"fsdp\", \"sp\", None, None)\n            key_partition_spec = PartitionSpec(\"fsdp\", \"sp\", None, None)\n            value_partition_spec = PartitionSpec(\"fsdp\", \"sp\", None, None)\n            bias_partition_spec = PartitionSpec(\"fsdp\", \"sp\", None, None)\n            attention_partition_spec = PartitionSpec(\"fsdp\", \"sp\", None, None)\n        else:\n            query_partition_spec = PartitionSpec(\"dp\", \"sp\", \"fsdp\", None)\n            key_partition_spec = PartitionSpec(\"dp\", \"sp\", \"fsdp\", None)\n            value_partition_spec = PartitionSpec(\"dp\", \"sp\", \"fsdp\", None)\n            bias_partition_spec = PartitionSpec(\"dp\", \"fsdp\", None, None)\n            attention_partition_spec = PartitionSpec(\"dp\", \"sp\", \"fsdp\", None)\n    return EasyDelPartitions(\n        query_partition_spec=query_partition_spec,\n        key_partition_spec=key_partition_spec,\n        value_partition_spec=value_partition_spec,\n        bias_partition_spec=bias_partition_spec,\n        attention_partition_spec=attention_partition_spec\n    )\n</code></pre>"},{"location":"generated-reinforcement_learning-core/","title":"reinforcement_learning.core","text":""},{"location":"generated-reinforcement_learning-core/#lib.python.EasyDel.reinforcement_learning.core.add_suffix","title":"<code>add_suffix(input_dict, suffix)</code>","text":"<p>Add suffix to dict keys.</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/core.py</code> <pre><code>def add_suffix(input_dict, suffix):\n    \"\"\"Add suffix to dict keys.\"\"\"\n    return dict((k + suffix, v) for k, v in input_dict.items())\n</code></pre>"},{"location":"generated-reinforcement_learning-core/#lib.python.EasyDel.reinforcement_learning.core.multinomial","title":"<code>multinomial(logits, num_samples, replacement=False)</code>","text":"<p>Implements the <code>torch.multinomial</code> function in JAX.</p> <p>Args:     logits (jnp.array): The unnormalized log probabilities of the events.     num_samples (int): The number of samples to draw.     replacement (bool): Don't use this ; Returns:     jnp.array: A matrix of shape (num_samples, batch_size) containing the         sampled indices.</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/core.py</code> <pre><code>def multinomial(logits, num_samples: int, replacement: bool = False):\n    \"\"\"\n    Implements the `torch.multinomial` function in JAX.\n\n    Args:\n        logits (jnp.array): The unnormalized log probabilities of the events.\n        num_samples (int): The number of samples to draw.\n        replacement (bool): Don't use this ;\\\n\n    Returns:\n        jnp.array: A matrix of shape (num_samples, batch_size) containing the\n            sampled indices.\n    \"\"\"\n    logits = jax.nn.log_softmax(logits, axis=-1)\n    if replacement:\n        return jax.random.categorical(logits, num_samples)\n    else:\n        samples = []\n        for _ in range(num_samples):\n            sample = jax.random.categorical(logits, 1)\n            samples.append(sample[0])\n            logits.at[sample[0]].set(-jnp.inf)\n        return jnp.array(samples)\n</code></pre>"},{"location":"generated-reinforcement_learning-models-modelling_casual_language_rl/","title":"reinforcement_learning.models.modelling_casual_language_rl","text":""},{"location":"generated-reinforcement_learning-models-modelling_casual_language_rl/#lib.python.EasyDel.reinforcement_learning.models.modelling_casual_language_rl.ValueHead","title":"<code>ValueHead</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>lib/python/EasyDel/reinforcement_learning/models/modelling_casual_language_rl.py</code> <pre><code>class ValueHead(nn.Module):\n    summary_dropout_prob: float = 0.0\n    dtype: jnp.dtype = jnp.float32\n    param_dtype: jnp.dtype = jnp.float32\n    precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\")\n    kernel_init: Callable = nn.initializers.orthogonal()\n\n    def setup(self):\n        \"\"\"\n        The setup function is called by the model's constructor.\n        It initializes all the layers in your model, and assigns them to member variables.\n        The setup function should be used for any initialization that needs to happen before running forward().\n        This includes things like loading weights from a file, or setting up an optimizer.\n        :param self: Represent the instance of the class\n        \"\"\"\n        self.dropout = nn.Dropout(self.summary_dropout_prob)\n\n        self.summary = nn.Dense(\n            1,\n            dtype=self.dtype,\n            param_dtype=self.param_dtype,\n            precision=self.precision,\n            kernel_init=self.kernel_init,\n            use_bias=False\n        )\n\n    def __call__(self, hidden_states: chex.Array, deterministic: bool = True):\n        \"\"\"\n        The __call__ function is the main function of a class.\n        It is called when an instance of the class (an object) is invoked as a function, e.g., x(arg).\n        The __call__ method enables instances of a class to be called like standard Python functions.\n\n        :param self: Represent the instance of the class\n        :param hidden_states: chex.Array: Pass the hidden states of the previous layer\n        :param deterministic: bool: Determine whether to use dropout\n        :return: A tensor of shape (batch_size, num_classes)\n\n        \"\"\"\n        return self.summary(self.dropout(hidden_states, deterministic=deterministic))\n</code></pre>"},{"location":"generated-reinforcement_learning-models-modelling_casual_language_rl/#lib.python.EasyDel.reinforcement_learning.models.modelling_casual_language_rl.ValueHead.__call__","title":"<code>__call__(hidden_states, deterministic=True)</code>","text":"<p>The call function is the main function of a class. It is called when an instance of the class (an object) is invoked as a function, e.g., x(arg). The call method enables instances of a class to be called like standard Python functions.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>hidden_states</code> <code>Array</code> <p>chex.Array: Pass the hidden states of the previous layer</p> required <code>deterministic</code> <code>bool</code> <p>bool: Determine whether to use dropout</p> <code>True</code> <p>Returns:</p> Type Description <p>A tensor of shape (batch_size, num_classes)</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/models/modelling_casual_language_rl.py</code> <pre><code>def __call__(self, hidden_states: chex.Array, deterministic: bool = True):\n    \"\"\"\n    The __call__ function is the main function of a class.\n    It is called when an instance of the class (an object) is invoked as a function, e.g., x(arg).\n    The __call__ method enables instances of a class to be called like standard Python functions.\n\n    :param self: Represent the instance of the class\n    :param hidden_states: chex.Array: Pass the hidden states of the previous layer\n    :param deterministic: bool: Determine whether to use dropout\n    :return: A tensor of shape (batch_size, num_classes)\n\n    \"\"\"\n    return self.summary(self.dropout(hidden_states, deterministic=deterministic))\n</code></pre>"},{"location":"generated-reinforcement_learning-models-modelling_casual_language_rl/#lib.python.EasyDel.reinforcement_learning.models.modelling_casual_language_rl.ValueHead.setup","title":"<code>setup()</code>","text":"<p>The setup function is called by the model's constructor. It initializes all the layers in your model, and assigns them to member variables. The setup function should be used for any initialization that needs to happen before running forward(). This includes things like loading weights from a file, or setting up an optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required Source code in <code>lib/python/EasyDel/reinforcement_learning/models/modelling_casual_language_rl.py</code> <pre><code>def setup(self):\n    \"\"\"\n    The setup function is called by the model's constructor.\n    It initializes all the layers in your model, and assigns them to member variables.\n    The setup function should be used for any initialization that needs to happen before running forward().\n    This includes things like loading weights from a file, or setting up an optimizer.\n    :param self: Represent the instance of the class\n    \"\"\"\n    self.dropout = nn.Dropout(self.summary_dropout_prob)\n\n    self.summary = nn.Dense(\n        1,\n        dtype=self.dtype,\n        param_dtype=self.param_dtype,\n        precision=self.precision,\n        kernel_init=self.kernel_init,\n        use_bias=False\n    )\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-base/","title":"reinforcement_learning.trainer.base","text":""},{"location":"generated-reinforcement_learning-trainer-base/#lib.python.EasyDel.reinforcement_learning.trainer.base.create_reinforcement_learning_casual_language_model_train_step","title":"<code>create_reinforcement_learning_casual_language_model_train_step(partition_spec=PartitionSpec(('dp', 'fsdp'), 'sp'))</code>","text":"<p>The create_reinforcement_learning_casual_language_model_train_step function is a training step function that takes in the current state of the model, and a batch of data. It then calculates the loss and accuracy for this batch, and returns an updated state with new parameters based on these gradients.</p> <p>Parameters:</p> Name Type Description Default <code>partition_spec</code> <p>Specify which devices the model will be split across</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp')</code> <p>Returns:</p> Type Description <p>A reinforcement_learning_casual_language_model_train_step function that takes in the current state of the model,</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/base.py</code> <pre><code>def create_reinforcement_learning_casual_language_model_train_step(partition_spec=PartitionSpec((\"dp\", \"fsdp\"), \"sp\")):\n    \"\"\"\n    The create_reinforcement_learning_casual_language_model_train_step function is a training step function\n    that takes in the current state of the model, and a batch of data. It then calculates the loss and accuracy for\n    this batch, and returns an updated state with new parameters based on these gradients.\n\n    :param partition_spec: Specify which devices the model will be split across\n    :return: A reinforcement_learning_casual_language_model_train_step function that takes in the current state\n    of the model,\n\n    \"\"\"\n\n    def reinforcement_learning_casual_language_model_train_step(state, batch):\n        \"\"\"\n        The casual_language_model_train_step function is a training step function that takes in the current state\n        of the model, and a batch of data. It then calculates the loss and accuracy for this batch,\n        and returns an updated state with new parameters based on these gradients.\n\n        :param state: Store the model parameters\n        :param batch: Pass the data to the model\n        :return: A tuple of (state, loss, accuracy)\n\n        \"\"\"\n        batch = with_sharding_constraint(batch, partition_spec)\n\n        def calculate_loss(params):\n            labels = batch.pop(\"labels\")\n            logits = state.apply_fn(params=params, **batch,\n                                    return_dict=True).logits\n\n            loss, accuracy = cross_entropy_loss_and_accuracy(\n                logits[:, :-1, :], labels, batch[\"attention_mask\"].astype(jnp.float32)[:, 1:]\n            )\n            return loss, accuracy\n\n        grad_fn = jax.value_and_grad(calculate_loss, has_aux=True)\n        (loss__, accuracy__), grad = grad_fn(state.params)\n        state = state.apply_gradients(grads=grad)\n        return state, loss__, accuracy__\n\n    return reinforcement_learning_casual_language_model_train_step\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/","title":"reinforcement_learning.trainer.dpo_trainer","text":""},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer","title":"<code>DPOTrainer</code>","text":"<p>EasyDel DPO Trainer Class</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>class DPOTrainer:\n    \"\"\"\n    EasyDel DPO Trainer Class\n    \"\"\"\n\n    def __init__(\n            self,\n            model_state: EasyDelState | str = None,\n            ref_model_state: Optional[EasyDelState | str] = None,\n            partitioner_config: Optional[PartitionerConfig] = PartitionerConfig(),\n            beta: float = 0.1,\n            label_smoothing: float = 0,\n            loss_type: Literal[\"sigmoid\", \"hinge\", \"ipo\", \"kto\"] = \"sigmoid\",\n            arguments: TrainArguments = None,\n            label_pad_token_id: int = -100,\n            padding_value: int = None,\n            truncation_mode: str = \"keep_end\",\n            train_dataset: Optional[Dataset] = None,\n            eval_dataset: Optional[Union[Dataset, Dict[str, Dataset]]] = None,\n            tokenizer: Optional[PreTrainedTokenizerBase] = None,\n            max_length: Optional[int] = None,\n            max_prompt_length: Optional[int] = None,\n            max_target_length: Optional[int] = None,\n            precompute_ref_log_probs: bool = False,\n            model_init_kwarguments: Optional[Dict] = None,\n            ref_model_init_kwarguments: Optional[Dict] = None,\n            reference_free: bool = False,\n    ):\n\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the attributes of an object.\n\n\n        :param self: Refer to the object itself\n        :param model_state: EasyDelState | str: Pass the model state to the trainer\n        :param ref_model_state: Optional[EasyDelState | str]: Pass the reference model state\n        :param partitioner_config: Optional[PartitionerConfig]: Specify the partitioner configuration\n        :param beta: float: Control the strength of the regularization term\n        :param label_smoothing: float: Smooth the labels\n        :param loss_type: Literal[\"sigmoid\", \"hinge\", \"ipo\", \"kto\"] : Determine the loss function used\n        :param arguments: TrainArguments: Pass the arguments to the trainer\n        :param label_pad_token_id: int: Pad the labels\n        :param padding_value: int: Specify the value that is used for padding\n        :param truncation_mode: str: Truncate the input text\n        :param train_dataset: Optional[Dataset]: Load the training dataset\n        :param eval_dataset: Optional[Union[Dataset, Dict[str, Dataset]]] : Pass the evaluation dataset to the trainer\n        :param tokenizer: Optional[PreTrainedTokenizerBase]: Pass the tokenizer to the trainer\n        :param max_length: Optional[int]: Set the maximum length of the input sequence\n        :param max_prompt_length: Optional[int]: Set the maximum length of the prompt\n        :param max_target_length: Optional[int]: Truncate the target sequence\n        :param precompute_ref_log_probs: bool: Precompute the log probabilities of the reference model\n        :param model_init_kwarguments: Optional[Dict]: Pass in the model_kwarguments to model for init process\n        :param ref_model_init_kwarguments: Optional[Dict]: Pass the ref_model_init_kwarguments to ref_model for init process\n        :param : Set the padding value for the model\n        \"\"\"\n        if partitioner_config is None:\n            partitioner_config = PartitionerConfig()\n        self.partitioner_config = partitioner_config\n        assert arguments is not None, (\n            \"You Have to pass arguments that will be used for training but you have passed\"\n            \"`arguments=None`\"\n        )\n        assert isinstance(arguments, TrainArguments), (\n            f\"arguments type must be `TrainArguments` but got {type(arguments)}\"\n        )\n        if model_init_kwarguments is None:\n            model_init_kwarguments = {}\n        elif not isinstance(model_state, str):\n            raise ValueError(\"You passed model_kwarguments to the DPOTrainer. But your model is already instantiated.\")\n\n        if ref_model_init_kwarguments is None:\n            ref_model_init_kwarguments = {}\n        elif not isinstance(ref_model_state, str):\n            raise ValueError(\n                \"You passed ref_model_kwarguments to the DPOTrainer. But your ref_model is already instantiated.\"\n            )\n\n        if isinstance(model_state, str):\n            warnings.warn(\n                \"You passed a model_id to the DPOTrainer. This will automatically create an \"\n                \"`AutoEasyDelModelForCausalLM` for you.\"\n            )\n            model_state = EasyDelState.from_pretrained(\n                model_state,\n                **model_init_kwarguments\n            )\n        if isinstance(ref_model_state, str):\n            warnings.warn(\n                \"You passed a ref model_id to the DPOTrainer. This will automatically create an \"\n                \"`AutoEasyDelModelForCausalLM`\"\n            )\n            ref_model_state = EasyDelState.from_pretrained(\n                ref_model_state,\n                **ref_model_init_kwarguments\n            )\n\n        data_collator = DPODataCollatorWithPadding(\n            pad_token_id=tokenizer.pad_token_id,\n            label_pad_token_id=label_pad_token_id,\n            is_encoder_decoder=False,\n        )\n\n        self.max_length = max_length\n        self.label_pad_token_id = label_pad_token_id\n        self.padding_value = padding_value if padding_value is not None else tokenizer.pad_token_id\n        self.max_prompt_length = max_prompt_length\n        self.truncation_mode = truncation_mode\n        self.max_target_length = max_target_length\n        self.tokenizer = tokenizer\n        self.precompute_ref_log_probs = precompute_ref_log_probs\n        self.reference_free = reference_free\n        self.is_encoder_decoder = False\n        self._precomputed_train_ref_log_probs = False\n        self._precomputed_eval_ref_log_probs = False\n        if loss_type in [\"hinge\", \"ipo\", \"kto_pair\"] and label_smoothing &gt; 0:\n            warnings.warn(\n                \"You are using a loss type that does not support label smoothing. Ignoring label_smoothing parameter.\"\n            )\n\n        self.beta = beta\n        self.label_smoothing = label_smoothing\n        self.loss_type = loss_type\n\n        self._stored_metrics = defaultdict(lambda: defaultdict(list))\n\n        train_dataset = train_dataset.map(self.tokenize_row, )\n        if eval_dataset is not None:\n            eval_dataset = eval_dataset.map(self.tokenize_row)\n\n        self.arguments = arguments\n        self.hp_name = None\n        self.deepspeed = None\n        self.is_in_train = False\n\n        self.data_collator = data_collator\n        self.train_dataset = train_dataset\n        self.eval_dataset = eval_dataset\n        self.tokenizer = tokenizer\n        self.ref_model_state = ref_model_state\n        self.model_state = model_state\n        self._loggers_initialized = False\n        self.mesh = self.arguments.get_mesh()\n\n        self.concatenated_forward = create_concatenated_forward(\n            is_encoder_decoder=self.is_encoder_decoder,\n            padding_value=padding_value,\n            label_pad_token_id=label_pad_token_id\n        )\n\n    def _get_train_dataloader(self) -&gt; DataLoader:\n\n        \"\"\"\n        The _get_train_dataloader function is used to create a DataLoader object for the training dataset.\n\n        :param self: Represent the instance of the class\n        :return: A dataloader object\n        \"\"\"\n        if self.train_dataset is None:\n            raise ValueError(\"Trainer: training requires a train_dataset.\")\n\n        train_dataset = self.train_dataset\n        data_collator = self.data_collator\n        if hasattr(self, \"_remove_unused_columns\"):\n            train_dataset = self._remove_unused_columns(train_dataset, description=\"training\")\n        else:\n            warnings.warn(\n                \"Couldn't find function `_remove_unused_columns` if you are the \"\n                \"developer fix this otherwise ignore this warning\"\n            )\n        dataloader_params = {\n            \"batch_size\": self.arguments.total_batch_size,\n            \"collate_fn\": data_collator,\n            \"num_workers\": self.arguments.dataloader_num_workers,\n            \"pin_memory\": self.arguments.dataloader_pin_memory,\n        }\n\n        return DataLoader(\n            train_dataset,\n            **dataloader_params\n        )\n\n    def get_train_dataloader(\n            self,\n    ) -&gt; DataLoader:\n        \"\"\"\n        Returns the training [`~torch.utils.data.DataLoader`].\n\n        Subclass of transformers.src.transformers.trainer.get_train_dataloader to precompute `ref_log_probs`.\n        \"\"\"\n\n        if self.precompute_ref_log_probs and not self._precomputed_train_ref_log_probs:\n            dataloader_params = {\n                \"batch_size\": self.arguments.total_batch_size,\n                \"collate_fn\": self.data_collator,\n                \"num_workers\": self.arguments.dataloader_num_workers,\n                \"pin_memory\": self.arguments.dataloader_pin_memory,\n                \"shuffle\": False,\n            }\n\n            data_loader = DataLoader(self.train_dataset, **dataloader_params)\n\n            reference_chosen_log_probs = []\n            reference_rejected_log_probs = []\n            for padded_batch in tqdm(iterable=data_loader, desc=\"Train dataset reference log probs\"):\n                reference_chosen_logp, reference_rejected_logp = self.compute_reference_log_probs(\n                    self.model_state,\n                    padded_batch,\n                )\n                reference_chosen_log_probs.append(reference_chosen_logp.cpu())\n                reference_rejected_log_probs.append(reference_rejected_logp.cpu())\n\n            all_reference_chosen_log_probs = jnp.concatenate(reference_chosen_log_probs)\n            all_reference_rejected_log_probs = jnp.concatenate(reference_rejected_log_probs)\n\n            self.train_dataset = self.train_dataset.add_column(\n                name=\"reference_chosen_log_probs\", column=all_reference_chosen_log_probs\n            )\n            self.train_dataset = self.train_dataset.add_column(\n                name=\"reference_rejected_log_probs\", column=all_reference_rejected_log_probs\n            )\n\n            self._precomputed_train_ref_log_probs = True\n        return self._get_train_dataloader()\n\n    def build_tokenized_answer(self, prompt, answer):\n        \"\"\"\n        Llama tokenizer does satisfy `enc(a + b) = enc(a) + enc(b)`.\n        It does ensure `enc(a + b) = enc(a) + enc(a + b)[len(enc(a)):]`.\n        \"\"\"\n\n        full_tokenized = self.tokenizer(prompt + answer, add_special_tokens=False)\n        prompt_input_ids = self.tokenizer(prompt, add_special_tokens=False)[\"input_ids\"]\n\n        answer_input_ids = full_tokenized[\"input_ids\"][len(prompt_input_ids):]\n        answer_attention_mask = full_tokenized[\"attention_mask\"][len(prompt_input_ids):]\n        prompt_input_ids = jnp.asarray(prompt_input_ids, dtype=\"i4\")\n        answer_input_ids = jnp.asarray(answer_input_ids, dtype=\"i4\")\n        full_concat_input_ids = jnp.concatenate(\n            (\n                prompt_input_ids,\n                answer_input_ids\n            )\n        )\n\n        # Prepare input tokens for token by token comparison\n        full_input_ids = jnp.array(full_tokenized[\"input_ids\"])\n\n        if len(full_input_ids) != len(full_concat_input_ids):\n            raise ValueError(\"Prompt input ids and answer input ids should have the same length.\")\n\n        response_token_ids_start_idx = len(prompt_input_ids)\n        if prompt_input_ids.tolist() != full_tokenized[\"input_ids\"][:response_token_ids_start_idx]:\n            response_token_ids_start_idx -= 1\n\n        prompt_input_ids = full_tokenized[\"input_ids\"][:response_token_ids_start_idx]\n        prompt_attention_mask = full_tokenized[\"attention_mask\"][:response_token_ids_start_idx]\n\n        if len(prompt_input_ids) != len(prompt_attention_mask):\n            raise ValueError(\"Prompt input ids and attention mask should have the same length.\")\n\n        answer_input_ids = full_tokenized[\"input_ids\"][response_token_ids_start_idx:]\n        answer_attention_mask = full_tokenized[\"attention_mask\"][response_token_ids_start_idx:]\n\n        return dict(\n            prompt_input_ids=prompt_input_ids,\n            prompt_attention_mask=prompt_attention_mask,\n            input_ids=answer_input_ids,\n            attention_mask=answer_attention_mask,\n        )\n\n    def tokenize_row(self, feature, state: EasyDelState = None) -&gt; Dict:\n\n        \"\"\"\n        The tokenize_row function is responsible for taking a single row of data and converting it into the format that\n        the model expects. This includes:\n        - Tokenizing the text (using HuggingFace's tokenizer)\n        - Padding/truncating sequences to a fixed length (if necessary)\n        - Creating attention masks, which tell the model which tokens are padding and which aren't.\n\n        :param self: Represent the instance of the class\n        :param feature: Pass in the data from the dataset\n        :param state: EasyDelState: Keep track of the state of the tokenizer\n        :return: A dictionary of the following keys\n        \"\"\"\n        batch = {}\n        prompt = feature[\"prompt\"]\n        chosen = feature[\"chosen\"]\n        rejected = feature[\"rejected\"]\n\n        if not isinstance(prompt, str):\n            raise ValueError(f\"prompt should be an str but got {type(prompt)} , {prompt}\")\n        prompt_tokens = self.tokenizer(prompt, add_special_tokens=False)\n        prompt_tokens = {f\"prompt_{k}\": v for k, v in prompt_tokens.items()}\n\n        if not isinstance(chosen, str):\n            raise ValueError(f\"chosen should be an str but got {type(chosen)} , {chosen}\")\n        chosen_tokens = self.build_tokenized_answer(prompt, chosen)\n\n        if not isinstance(rejected, str):\n            raise ValueError(f\"rejected should be an str but got {type(rejected)}\")\n        rejected_tokens = self.build_tokenized_answer(prompt, rejected)\n\n        # add BOS token to head of prompt\n        prompt_tokens[\"prompt_input_ids\"] = [self.tokenizer.bos_token_id] + prompt_tokens[\"prompt_input_ids\"]\n        chosen_tokens[\"prompt_input_ids\"] = [self.tokenizer.bos_token_id] + chosen_tokens[\"prompt_input_ids\"]\n        rejected_tokens[\"prompt_input_ids\"] = [self.tokenizer.bos_token_id] + rejected_tokens[\"prompt_input_ids\"]\n\n        prompt_tokens[\"prompt_attention_mask\"] = [1] + prompt_tokens[\"prompt_attention_mask\"]\n        chosen_tokens[\"prompt_attention_mask\"] = [1] + chosen_tokens[\"prompt_attention_mask\"]\n        rejected_tokens[\"prompt_attention_mask\"] = [1] + rejected_tokens[\"prompt_attention_mask\"]\n\n        # add EOS token to end of answer\n        chosen_tokens[\"input_ids\"].append(self.tokenizer.eos_token_id)\n        chosen_tokens[\"attention_mask\"].append(1)\n\n        rejected_tokens[\"input_ids\"].append(self.tokenizer.eos_token_id)\n        rejected_tokens[\"attention_mask\"].append(1)\n\n        longer_response_length = max(len(chosen_tokens[\"input_ids\"]), len(rejected_tokens[\"input_ids\"]))\n\n        # if combined sequence is too long, truncate the prompt\n        for answer_tokens in [chosen_tokens, rejected_tokens, prompt_tokens]:\n            if len(answer_tokens[\"prompt_input_ids\"]) + longer_response_length &gt; self.max_length:\n                if self.truncation_mode == \"keep_start\":\n                    for k in [\"prompt_input_ids\", \"prompt_attention_mask\"]:\n                        answer_tokens[k] = answer_tokens[k][: self.max_prompt_length]\n                elif self.truncation_mode == \"keep_end\":\n                    for k in [\"prompt_input_ids\", \"prompt_attention_mask\"]:\n                        answer_tokens[k] = answer_tokens[k][-self.max_prompt_length:]\n                else:\n                    raise ValueError(f\"Unknown truncation mode: {self.truncation_mode}\")\n\n        # if that's still too long, truncate the response\n        for answer_tokens in [chosen_tokens, rejected_tokens]:\n            if len(answer_tokens[\"prompt_input_ids\"]) + longer_response_length &gt; self.max_length:\n                for k in [\"input_ids\", \"attention_mask\"]:\n                    answer_tokens[k] = answer_tokens[k][: self.max_length - self.max_prompt_length]\n\n        # Create labels\n        chosen_sequence_tokens = {\n            k: chosen_tokens[f\"prompt_{k}\"] + chosen_tokens[k] for k in [\"input_ids\", \"attention_mask\"]\n        }\n        rejected_sequence_tokens = {\n            k: rejected_tokens[f\"prompt_{k}\"] + rejected_tokens[k] for k in [\"input_ids\", \"attention_mask\"]\n        }\n        chosen_sequence_tokens[\"labels\"] = chosen_sequence_tokens[\"input_ids\"][:]\n        chosen_sequence_tokens[\"labels\"][: len(chosen_tokens[\"prompt_input_ids\"])] = [\n                                                                                         self.label_pad_token_id\n                                                                                     ] * len(\n            chosen_tokens[\"prompt_input_ids\"]\n        )\n        rejected_sequence_tokens[\"labels\"] = rejected_sequence_tokens[\"input_ids\"][:]\n        rejected_sequence_tokens[\"labels\"][: len(rejected_tokens[\"prompt_input_ids\"])] = [\n                                                                                             self.label_pad_token_id\n                                                                                         ] * len(\n            rejected_tokens[\"prompt_input_ids\"])\n\n        for k, tokens_ in {\n            \"chosen_\": chosen_sequence_tokens,\n            \"rejected_\": rejected_sequence_tokens,\n            \"\": prompt_tokens,\n        }.items():\n            for type_key, tokens in tokens_.items():\n                if type_key == \"token_type_ids\":\n                    continue\n                batch[f\"{k}{type_key}\"] = tokens\n\n        return batch\n\n    def compute_reference_log_probs(\n            self,\n            state: EasyDelState,\n            padded_batch: Dict,\n    ) -&gt; tuple[Any, Any]:\n        \"\"\"\n        Computes log probabilities of the reference model for a single padded batch of a DPO specific dataset.\n        \"\"\"\n\n        if self.ref_model_state is None:\n            (\n                reference_chosen_log_probs,\n                reference_rejected_log_probs,\n                _,\n                _,\n            ) = self.concatenated_forward(\n                apply_fn=state.apply_fn,\n                params=state.params,\n                batch=padded_batch,\n            )\n        else:\n            (\n                reference_chosen_log_probs,\n                reference_rejected_log_probs,\n                _,\n                _,\n            ) = self.concatenated_forward(\n                apply_fn=self.ref_model_state.apply_fn,\n                params=self.ref_model_state.params,\n                batch=padded_batch,\n            )\n\n        return reference_chosen_log_probs, reference_rejected_log_probs\n\n    def get_mesh(self) -&gt; jax.sharding.Mesh:\n\n        \"\"\"\n        The get_mesh function returns the mesh of a given instance of the class.\n\n        :param self: Bind the method to an object\n        :return: The mesh of the device\n        \"\"\"\n        return self.mesh\n\n    def train(self):\n        step = 0\n        train_function = create_dpo_train_function(\n            concatenated_forward=self.concatenated_forward,\n            ref_state=self.ref_model_state,\n            loss_type=self.loss_type,\n            reference_free=self.reference_free,\n            label_smoothing=self.label_smoothing,\n            beta=self.beta\n        )\n        for epoch_index in range(self.arguments.num_train_epochs):\n            for batch in self.get_train_dataloader():\n                step += 1\n                if self.arguments.step_start_point &gt; step:\n                    ...\n                else:\n                    self.model_state, mt = train_function(self.model_state, batch=batch)\n                    print(mt)\n                    break\n\n    def eval(self):\n        \"\"\"\n        Process is Under Progress ...\n        \"\"\"\n        # TODO : Finish Eval Step\n        ...\n\n    def __repr__(self):\n\n        \"\"\"\n        The __repr__ function is used to generate a string representation of an object.\n        This function should return a string that can be parsed by the Python interpreter\n        to recreate the object. The __repr__ function is called when you use print() on an\n        object, or when you type its name in the REPL.\n\n        :param self: Refer to the instance of the class\n        :return: A string representation of the object\n        \"\"\"\n        string = f\"{self.__class__.__name__}(\\n\"\n        for k, v in self.__dict__.items():\n            if not k.startswith(\"_\"):\n                repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n                string += repr_src if len(repr_src) &lt; 350 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n        return string + \")\"\n\n    def __str__(self):\n\n        \"\"\"\n        The __str__ function is called when you use the print function or when str() is used.\n        It should return a string representation of the object.\n\n        :param self: Refer to the instance of the class\n        :return: The object's string representation\n        \"\"\"\n        return self.__repr__()\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.__init__","title":"<code>__init__(model_state=None, ref_model_state=None, partitioner_config=PartitionerConfig(), beta=0.1, label_smoothing=0, loss_type='sigmoid', arguments=None, label_pad_token_id=-100, padding_value=None, truncation_mode='keep_end', train_dataset=None, eval_dataset=None, tokenizer=None, max_length=None, max_prompt_length=None, max_target_length=None, precompute_ref_log_probs=False, model_init_kwarguments=None, ref_model_init_kwarguments=None, reference_free=False)</code>","text":"<p>The init function is called when the class is instantiated. It sets up the attributes of an object.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>model_state</code> <code>EasyDelState | str</code> <p>EasyDelState | str: Pass the model state to the trainer</p> <code>None</code> <code>ref_model_state</code> <code>Optional[EasyDelState | str]</code> <p>Optional[EasyDelState | str]: Pass the reference model state</p> <code>None</code> <code>partitioner_config</code> <code>Optional[PartitionerConfig]</code> <p>Optional[PartitionerConfig]: Specify the partitioner configuration</p> <code>PartitionerConfig()</code> <code>beta</code> <code>float</code> <p>float: Control the strength of the regularization term</p> <code>0.1</code> <code>label_smoothing</code> <code>float</code> <p>float: Smooth the labels</p> <code>0</code> <code>loss_type</code> <code>Literal['sigmoid', 'hinge', 'ipo', 'kto']</code> <p>Literal[\"sigmoid\", \"hinge\", \"ipo\", \"kto\"] : Determine the loss function used</p> <code>'sigmoid'</code> <code>arguments</code> <code>TrainArguments</code> <p>TrainArguments: Pass the arguments to the trainer</p> <code>None</code> <code>label_pad_token_id</code> <code>int</code> <p>int: Pad the labels</p> <code>-100</code> <code>padding_value</code> <code>int</code> <p>int: Specify the value that is used for padding</p> <code>None</code> <code>truncation_mode</code> <code>str</code> <p>str: Truncate the input text</p> <code>'keep_end'</code> <code>train_dataset</code> <code>Optional[Dataset]</code> <p>Optional[Dataset]: Load the training dataset</p> <code>None</code> <code>eval_dataset</code> <code>Optional[Union[Dataset, Dict[str, Dataset]]]</code> <p>Optional[Union[Dataset, Dict[str, Dataset]]] : Pass the evaluation dataset to the trainer</p> <code>None</code> <code>tokenizer</code> <code>Optional[PreTrainedTokenizerBase]</code> <p>Optional[PreTrainedTokenizerBase]: Pass the tokenizer to the trainer</p> <code>None</code> <code>max_length</code> <code>Optional[int]</code> <p>Optional[int]: Set the maximum length of the input sequence</p> <code>None</code> <code>max_prompt_length</code> <code>Optional[int]</code> <p>Optional[int]: Set the maximum length of the prompt</p> <code>None</code> <code>max_target_length</code> <code>Optional[int]</code> <p>Optional[int]: Truncate the target sequence</p> <code>None</code> <code>precompute_ref_log_probs</code> <code>bool</code> <p>bool: Precompute the log probabilities of the reference model</p> <code>False</code> <code>model_init_kwarguments</code> <code>Optional[Dict]</code> <p>Optional[Dict]: Pass in the model_kwarguments to model for init process</p> <code>None</code> <code>ref_model_init_kwarguments</code> <code>Optional[Dict]</code> <p>Optional[Dict]: Pass the ref_model_init_kwarguments to ref_model for init process</p> <code>None</code> <code></code> <p>Set the padding value for the model</p> required Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def __init__(\n        self,\n        model_state: EasyDelState | str = None,\n        ref_model_state: Optional[EasyDelState | str] = None,\n        partitioner_config: Optional[PartitionerConfig] = PartitionerConfig(),\n        beta: float = 0.1,\n        label_smoothing: float = 0,\n        loss_type: Literal[\"sigmoid\", \"hinge\", \"ipo\", \"kto\"] = \"sigmoid\",\n        arguments: TrainArguments = None,\n        label_pad_token_id: int = -100,\n        padding_value: int = None,\n        truncation_mode: str = \"keep_end\",\n        train_dataset: Optional[Dataset] = None,\n        eval_dataset: Optional[Union[Dataset, Dict[str, Dataset]]] = None,\n        tokenizer: Optional[PreTrainedTokenizerBase] = None,\n        max_length: Optional[int] = None,\n        max_prompt_length: Optional[int] = None,\n        max_target_length: Optional[int] = None,\n        precompute_ref_log_probs: bool = False,\n        model_init_kwarguments: Optional[Dict] = None,\n        ref_model_init_kwarguments: Optional[Dict] = None,\n        reference_free: bool = False,\n):\n\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up the attributes of an object.\n\n\n    :param self: Refer to the object itself\n    :param model_state: EasyDelState | str: Pass the model state to the trainer\n    :param ref_model_state: Optional[EasyDelState | str]: Pass the reference model state\n    :param partitioner_config: Optional[PartitionerConfig]: Specify the partitioner configuration\n    :param beta: float: Control the strength of the regularization term\n    :param label_smoothing: float: Smooth the labels\n    :param loss_type: Literal[\"sigmoid\", \"hinge\", \"ipo\", \"kto\"] : Determine the loss function used\n    :param arguments: TrainArguments: Pass the arguments to the trainer\n    :param label_pad_token_id: int: Pad the labels\n    :param padding_value: int: Specify the value that is used for padding\n    :param truncation_mode: str: Truncate the input text\n    :param train_dataset: Optional[Dataset]: Load the training dataset\n    :param eval_dataset: Optional[Union[Dataset, Dict[str, Dataset]]] : Pass the evaluation dataset to the trainer\n    :param tokenizer: Optional[PreTrainedTokenizerBase]: Pass the tokenizer to the trainer\n    :param max_length: Optional[int]: Set the maximum length of the input sequence\n    :param max_prompt_length: Optional[int]: Set the maximum length of the prompt\n    :param max_target_length: Optional[int]: Truncate the target sequence\n    :param precompute_ref_log_probs: bool: Precompute the log probabilities of the reference model\n    :param model_init_kwarguments: Optional[Dict]: Pass in the model_kwarguments to model for init process\n    :param ref_model_init_kwarguments: Optional[Dict]: Pass the ref_model_init_kwarguments to ref_model for init process\n    :param : Set the padding value for the model\n    \"\"\"\n    if partitioner_config is None:\n        partitioner_config = PartitionerConfig()\n    self.partitioner_config = partitioner_config\n    assert arguments is not None, (\n        \"You Have to pass arguments that will be used for training but you have passed\"\n        \"`arguments=None`\"\n    )\n    assert isinstance(arguments, TrainArguments), (\n        f\"arguments type must be `TrainArguments` but got {type(arguments)}\"\n    )\n    if model_init_kwarguments is None:\n        model_init_kwarguments = {}\n    elif not isinstance(model_state, str):\n        raise ValueError(\"You passed model_kwarguments to the DPOTrainer. But your model is already instantiated.\")\n\n    if ref_model_init_kwarguments is None:\n        ref_model_init_kwarguments = {}\n    elif not isinstance(ref_model_state, str):\n        raise ValueError(\n            \"You passed ref_model_kwarguments to the DPOTrainer. But your ref_model is already instantiated.\"\n        )\n\n    if isinstance(model_state, str):\n        warnings.warn(\n            \"You passed a model_id to the DPOTrainer. This will automatically create an \"\n            \"`AutoEasyDelModelForCausalLM` for you.\"\n        )\n        model_state = EasyDelState.from_pretrained(\n            model_state,\n            **model_init_kwarguments\n        )\n    if isinstance(ref_model_state, str):\n        warnings.warn(\n            \"You passed a ref model_id to the DPOTrainer. This will automatically create an \"\n            \"`AutoEasyDelModelForCausalLM`\"\n        )\n        ref_model_state = EasyDelState.from_pretrained(\n            ref_model_state,\n            **ref_model_init_kwarguments\n        )\n\n    data_collator = DPODataCollatorWithPadding(\n        pad_token_id=tokenizer.pad_token_id,\n        label_pad_token_id=label_pad_token_id,\n        is_encoder_decoder=False,\n    )\n\n    self.max_length = max_length\n    self.label_pad_token_id = label_pad_token_id\n    self.padding_value = padding_value if padding_value is not None else tokenizer.pad_token_id\n    self.max_prompt_length = max_prompt_length\n    self.truncation_mode = truncation_mode\n    self.max_target_length = max_target_length\n    self.tokenizer = tokenizer\n    self.precompute_ref_log_probs = precompute_ref_log_probs\n    self.reference_free = reference_free\n    self.is_encoder_decoder = False\n    self._precomputed_train_ref_log_probs = False\n    self._precomputed_eval_ref_log_probs = False\n    if loss_type in [\"hinge\", \"ipo\", \"kto_pair\"] and label_smoothing &gt; 0:\n        warnings.warn(\n            \"You are using a loss type that does not support label smoothing. Ignoring label_smoothing parameter.\"\n        )\n\n    self.beta = beta\n    self.label_smoothing = label_smoothing\n    self.loss_type = loss_type\n\n    self._stored_metrics = defaultdict(lambda: defaultdict(list))\n\n    train_dataset = train_dataset.map(self.tokenize_row, )\n    if eval_dataset is not None:\n        eval_dataset = eval_dataset.map(self.tokenize_row)\n\n    self.arguments = arguments\n    self.hp_name = None\n    self.deepspeed = None\n    self.is_in_train = False\n\n    self.data_collator = data_collator\n    self.train_dataset = train_dataset\n    self.eval_dataset = eval_dataset\n    self.tokenizer = tokenizer\n    self.ref_model_state = ref_model_state\n    self.model_state = model_state\n    self._loggers_initialized = False\n    self.mesh = self.arguments.get_mesh()\n\n    self.concatenated_forward = create_concatenated_forward(\n        is_encoder_decoder=self.is_encoder_decoder,\n        padding_value=padding_value,\n        label_pad_token_id=label_pad_token_id\n    )\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.__repr__","title":"<code>__repr__()</code>","text":"<p>The repr function is used to generate a string representation of an object. This function should return a string that can be parsed by the Python interpreter to recreate the object. The repr function is called when you use print() on an object, or when you type its name in the REPL.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>A string representation of the object</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def __repr__(self):\n\n    \"\"\"\n    The __repr__ function is used to generate a string representation of an object.\n    This function should return a string that can be parsed by the Python interpreter\n    to recreate the object. The __repr__ function is called when you use print() on an\n    object, or when you type its name in the REPL.\n\n    :param self: Refer to the instance of the class\n    :return: A string representation of the object\n    \"\"\"\n    string = f\"{self.__class__.__name__}(\\n\"\n    for k, v in self.__dict__.items():\n        if not k.startswith(\"_\"):\n            repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n            string += repr_src if len(repr_src) &lt; 350 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n    return string + \")\"\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.__str__","title":"<code>__str__()</code>","text":"<p>The str function is called when you use the print function or when str() is used. It should return a string representation of the object.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>The object's string representation</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def __str__(self):\n\n    \"\"\"\n    The __str__ function is called when you use the print function or when str() is used.\n    It should return a string representation of the object.\n\n    :param self: Refer to the instance of the class\n    :return: The object's string representation\n    \"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.build_tokenized_answer","title":"<code>build_tokenized_answer(prompt, answer)</code>","text":"<p>Llama tokenizer does satisfy <code>enc(a + b) = enc(a) + enc(b)</code>. It does ensure <code>enc(a + b) = enc(a) + enc(a + b)[len(enc(a)):]</code>.</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def build_tokenized_answer(self, prompt, answer):\n    \"\"\"\n    Llama tokenizer does satisfy `enc(a + b) = enc(a) + enc(b)`.\n    It does ensure `enc(a + b) = enc(a) + enc(a + b)[len(enc(a)):]`.\n    \"\"\"\n\n    full_tokenized = self.tokenizer(prompt + answer, add_special_tokens=False)\n    prompt_input_ids = self.tokenizer(prompt, add_special_tokens=False)[\"input_ids\"]\n\n    answer_input_ids = full_tokenized[\"input_ids\"][len(prompt_input_ids):]\n    answer_attention_mask = full_tokenized[\"attention_mask\"][len(prompt_input_ids):]\n    prompt_input_ids = jnp.asarray(prompt_input_ids, dtype=\"i4\")\n    answer_input_ids = jnp.asarray(answer_input_ids, dtype=\"i4\")\n    full_concat_input_ids = jnp.concatenate(\n        (\n            prompt_input_ids,\n            answer_input_ids\n        )\n    )\n\n    # Prepare input tokens for token by token comparison\n    full_input_ids = jnp.array(full_tokenized[\"input_ids\"])\n\n    if len(full_input_ids) != len(full_concat_input_ids):\n        raise ValueError(\"Prompt input ids and answer input ids should have the same length.\")\n\n    response_token_ids_start_idx = len(prompt_input_ids)\n    if prompt_input_ids.tolist() != full_tokenized[\"input_ids\"][:response_token_ids_start_idx]:\n        response_token_ids_start_idx -= 1\n\n    prompt_input_ids = full_tokenized[\"input_ids\"][:response_token_ids_start_idx]\n    prompt_attention_mask = full_tokenized[\"attention_mask\"][:response_token_ids_start_idx]\n\n    if len(prompt_input_ids) != len(prompt_attention_mask):\n        raise ValueError(\"Prompt input ids and attention mask should have the same length.\")\n\n    answer_input_ids = full_tokenized[\"input_ids\"][response_token_ids_start_idx:]\n    answer_attention_mask = full_tokenized[\"attention_mask\"][response_token_ids_start_idx:]\n\n    return dict(\n        prompt_input_ids=prompt_input_ids,\n        prompt_attention_mask=prompt_attention_mask,\n        input_ids=answer_input_ids,\n        attention_mask=answer_attention_mask,\n    )\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.compute_reference_log_probs","title":"<code>compute_reference_log_probs(state, padded_batch)</code>","text":"<p>Computes log probabilities of the reference model for a single padded batch of a DPO specific dataset.</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def compute_reference_log_probs(\n        self,\n        state: EasyDelState,\n        padded_batch: Dict,\n) -&gt; tuple[Any, Any]:\n    \"\"\"\n    Computes log probabilities of the reference model for a single padded batch of a DPO specific dataset.\n    \"\"\"\n\n    if self.ref_model_state is None:\n        (\n            reference_chosen_log_probs,\n            reference_rejected_log_probs,\n            _,\n            _,\n        ) = self.concatenated_forward(\n            apply_fn=state.apply_fn,\n            params=state.params,\n            batch=padded_batch,\n        )\n    else:\n        (\n            reference_chosen_log_probs,\n            reference_rejected_log_probs,\n            _,\n            _,\n        ) = self.concatenated_forward(\n            apply_fn=self.ref_model_state.apply_fn,\n            params=self.ref_model_state.params,\n            batch=padded_batch,\n        )\n\n    return reference_chosen_log_probs, reference_rejected_log_probs\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.eval","title":"<code>eval()</code>","text":"<p>Process is Under Progress ...</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def eval(self):\n    \"\"\"\n    Process is Under Progress ...\n    \"\"\"\n    # TODO : Finish Eval Step\n    ...\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.get_mesh","title":"<code>get_mesh()</code>","text":"<p>The get_mesh function returns the mesh of a given instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Bind the method to an object</p> required <p>Returns:</p> Type Description <code>Mesh</code> <p>The mesh of the device</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def get_mesh(self) -&gt; jax.sharding.Mesh:\n\n    \"\"\"\n    The get_mesh function returns the mesh of a given instance of the class.\n\n    :param self: Bind the method to an object\n    :return: The mesh of the device\n    \"\"\"\n    return self.mesh\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.get_train_dataloader","title":"<code>get_train_dataloader()</code>","text":"<p>Returns the training [<code>~torch.utils.data.DataLoader</code>].</p> <p>Subclass of transformers.src.transformers.trainer.get_train_dataloader to precompute <code>ref_log_probs</code>.</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def get_train_dataloader(\n        self,\n) -&gt; DataLoader:\n    \"\"\"\n    Returns the training [`~torch.utils.data.DataLoader`].\n\n    Subclass of transformers.src.transformers.trainer.get_train_dataloader to precompute `ref_log_probs`.\n    \"\"\"\n\n    if self.precompute_ref_log_probs and not self._precomputed_train_ref_log_probs:\n        dataloader_params = {\n            \"batch_size\": self.arguments.total_batch_size,\n            \"collate_fn\": self.data_collator,\n            \"num_workers\": self.arguments.dataloader_num_workers,\n            \"pin_memory\": self.arguments.dataloader_pin_memory,\n            \"shuffle\": False,\n        }\n\n        data_loader = DataLoader(self.train_dataset, **dataloader_params)\n\n        reference_chosen_log_probs = []\n        reference_rejected_log_probs = []\n        for padded_batch in tqdm(iterable=data_loader, desc=\"Train dataset reference log probs\"):\n            reference_chosen_logp, reference_rejected_logp = self.compute_reference_log_probs(\n                self.model_state,\n                padded_batch,\n            )\n            reference_chosen_log_probs.append(reference_chosen_logp.cpu())\n            reference_rejected_log_probs.append(reference_rejected_logp.cpu())\n\n        all_reference_chosen_log_probs = jnp.concatenate(reference_chosen_log_probs)\n        all_reference_rejected_log_probs = jnp.concatenate(reference_rejected_log_probs)\n\n        self.train_dataset = self.train_dataset.add_column(\n            name=\"reference_chosen_log_probs\", column=all_reference_chosen_log_probs\n        )\n        self.train_dataset = self.train_dataset.add_column(\n            name=\"reference_rejected_log_probs\", column=all_reference_rejected_log_probs\n        )\n\n        self._precomputed_train_ref_log_probs = True\n    return self._get_train_dataloader()\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.DPOTrainer.tokenize_row","title":"<code>tokenize_row(feature, state=None)</code>","text":"<p>The tokenize_row function is responsible for taking a single row of data and converting it into the format that the model expects. This includes: - Tokenizing the text (using HuggingFace's tokenizer) - Padding/truncating sequences to a fixed length (if necessary) - Creating attention masks, which tell the model which tokens are padding and which aren't.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>feature</code> <p>Pass in the data from the dataset</p> required <code>state</code> <code>EasyDelState</code> <p>EasyDelState: Keep track of the state of the tokenizer</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary of the following keys</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def tokenize_row(self, feature, state: EasyDelState = None) -&gt; Dict:\n\n    \"\"\"\n    The tokenize_row function is responsible for taking a single row of data and converting it into the format that\n    the model expects. This includes:\n    - Tokenizing the text (using HuggingFace's tokenizer)\n    - Padding/truncating sequences to a fixed length (if necessary)\n    - Creating attention masks, which tell the model which tokens are padding and which aren't.\n\n    :param self: Represent the instance of the class\n    :param feature: Pass in the data from the dataset\n    :param state: EasyDelState: Keep track of the state of the tokenizer\n    :return: A dictionary of the following keys\n    \"\"\"\n    batch = {}\n    prompt = feature[\"prompt\"]\n    chosen = feature[\"chosen\"]\n    rejected = feature[\"rejected\"]\n\n    if not isinstance(prompt, str):\n        raise ValueError(f\"prompt should be an str but got {type(prompt)} , {prompt}\")\n    prompt_tokens = self.tokenizer(prompt, add_special_tokens=False)\n    prompt_tokens = {f\"prompt_{k}\": v for k, v in prompt_tokens.items()}\n\n    if not isinstance(chosen, str):\n        raise ValueError(f\"chosen should be an str but got {type(chosen)} , {chosen}\")\n    chosen_tokens = self.build_tokenized_answer(prompt, chosen)\n\n    if not isinstance(rejected, str):\n        raise ValueError(f\"rejected should be an str but got {type(rejected)}\")\n    rejected_tokens = self.build_tokenized_answer(prompt, rejected)\n\n    # add BOS token to head of prompt\n    prompt_tokens[\"prompt_input_ids\"] = [self.tokenizer.bos_token_id] + prompt_tokens[\"prompt_input_ids\"]\n    chosen_tokens[\"prompt_input_ids\"] = [self.tokenizer.bos_token_id] + chosen_tokens[\"prompt_input_ids\"]\n    rejected_tokens[\"prompt_input_ids\"] = [self.tokenizer.bos_token_id] + rejected_tokens[\"prompt_input_ids\"]\n\n    prompt_tokens[\"prompt_attention_mask\"] = [1] + prompt_tokens[\"prompt_attention_mask\"]\n    chosen_tokens[\"prompt_attention_mask\"] = [1] + chosen_tokens[\"prompt_attention_mask\"]\n    rejected_tokens[\"prompt_attention_mask\"] = [1] + rejected_tokens[\"prompt_attention_mask\"]\n\n    # add EOS token to end of answer\n    chosen_tokens[\"input_ids\"].append(self.tokenizer.eos_token_id)\n    chosen_tokens[\"attention_mask\"].append(1)\n\n    rejected_tokens[\"input_ids\"].append(self.tokenizer.eos_token_id)\n    rejected_tokens[\"attention_mask\"].append(1)\n\n    longer_response_length = max(len(chosen_tokens[\"input_ids\"]), len(rejected_tokens[\"input_ids\"]))\n\n    # if combined sequence is too long, truncate the prompt\n    for answer_tokens in [chosen_tokens, rejected_tokens, prompt_tokens]:\n        if len(answer_tokens[\"prompt_input_ids\"]) + longer_response_length &gt; self.max_length:\n            if self.truncation_mode == \"keep_start\":\n                for k in [\"prompt_input_ids\", \"prompt_attention_mask\"]:\n                    answer_tokens[k] = answer_tokens[k][: self.max_prompt_length]\n            elif self.truncation_mode == \"keep_end\":\n                for k in [\"prompt_input_ids\", \"prompt_attention_mask\"]:\n                    answer_tokens[k] = answer_tokens[k][-self.max_prompt_length:]\n            else:\n                raise ValueError(f\"Unknown truncation mode: {self.truncation_mode}\")\n\n    # if that's still too long, truncate the response\n    for answer_tokens in [chosen_tokens, rejected_tokens]:\n        if len(answer_tokens[\"prompt_input_ids\"]) + longer_response_length &gt; self.max_length:\n            for k in [\"input_ids\", \"attention_mask\"]:\n                answer_tokens[k] = answer_tokens[k][: self.max_length - self.max_prompt_length]\n\n    # Create labels\n    chosen_sequence_tokens = {\n        k: chosen_tokens[f\"prompt_{k}\"] + chosen_tokens[k] for k in [\"input_ids\", \"attention_mask\"]\n    }\n    rejected_sequence_tokens = {\n        k: rejected_tokens[f\"prompt_{k}\"] + rejected_tokens[k] for k in [\"input_ids\", \"attention_mask\"]\n    }\n    chosen_sequence_tokens[\"labels\"] = chosen_sequence_tokens[\"input_ids\"][:]\n    chosen_sequence_tokens[\"labels\"][: len(chosen_tokens[\"prompt_input_ids\"])] = [\n                                                                                     self.label_pad_token_id\n                                                                                 ] * len(\n        chosen_tokens[\"prompt_input_ids\"]\n    )\n    rejected_sequence_tokens[\"labels\"] = rejected_sequence_tokens[\"input_ids\"][:]\n    rejected_sequence_tokens[\"labels\"][: len(rejected_tokens[\"prompt_input_ids\"])] = [\n                                                                                         self.label_pad_token_id\n                                                                                     ] * len(\n        rejected_tokens[\"prompt_input_ids\"])\n\n    for k, tokens_ in {\n        \"chosen_\": chosen_sequence_tokens,\n        \"rejected_\": rejected_sequence_tokens,\n        \"\": prompt_tokens,\n    }.items():\n        for type_key, tokens in tokens_.items():\n            if type_key == \"token_type_ids\":\n                continue\n            batch[f\"{k}{type_key}\"] = tokens\n\n    return batch\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.concatenated_inputs","title":"<code>concatenated_inputs(batch, is_encoder_decoder=False, label_pad_token_id=-100, padding_value=0)</code>","text":"<p>The concatenated_inputs function takes a batch of chosen and rejected examples, and concatenates them together. This is useful for training the model to predict whether     an example was chosen by the human annotator. The function also pads all inputs to the same length as the longest input in that batch.</p> <p>Parameters:</p> Name Type Description Default <code>batch</code> <code>Dict[str, Union[List, Array]]</code> <p>Dict[str,Union[List,chex.Array]]: Pass the batch of data into the function, Allow for the batch to be a list of arrays or just an array, Specify the type of data that is being passed in</p> required <code>is_encoder_decoder</code> <code>bool</code> <p>bool: Determine whether the model is an encoder-decoder model</p> <code>False</code> <code>label_pad_token_id</code> <code>int</code> <p>int: Pad the labels with a value of -100</p> <code>-100</code> <code>padding_value</code> <code>int</code> <p>int: Pad the input_ids and attention_mask arrays to the same length</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Array]</code> <p>A dictionary of the concatenated inputs</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def concatenated_inputs(\n        batch: Dict[str, Union[List, chex.Array]],\n        is_encoder_decoder: bool = False,\n        label_pad_token_id: int = -100,\n        padding_value: int = 0,\n) -&gt; Dict[str, chex.Array]:\n    \"\"\"\n    The concatenated_inputs function takes a batch of chosen and rejected examples,\n    and concatenates them together. This is useful for training the model to predict whether     an example was chosen by the human annotator. The function also pads all inputs to\n    the same length as the longest input in that batch.\n\n    :param batch: Dict[str,Union[List,chex.Array]]: Pass the batch of data into the function,\n    Allow for the batch to be a list of arrays or just an array,\n     Specify the type of data that is being passed in\n    :param is_encoder_decoder: bool: Determine whether the model is an encoder-decoder model\n    :param label_pad_token_id: int: Pad the labels with a value of -100\n    :param padding_value: int: Pad the input_ids and attention_mask arrays to the same length\n    :return: A dictionary of the concatenated inputs\n    \"\"\"\n    concatenated_batch = {}\n\n    if is_encoder_decoder:\n        max_length = max(batch[\"chosen_labels\"].shape[1], batch[\"rejected_labels\"].shape[1])\n    else:\n        max_length = max(batch[\"chosen_input_ids\"].shape[1], batch[\"rejected_input_ids\"].shape[1])\n\n    for k in batch:\n        if k.startswith(\"chosen\") and isinstance(batch[k], jax.Array):\n            if \"labels\" in k or is_encoder_decoder:\n                pad_value = label_pad_token_id\n            elif k.endswith(\"_input_ids\"):\n                pad_value = padding_value\n            elif k.endswith(\"_attention_mask\"):\n                pad_value = 0\n            else:\n                raise KeyError(\"couldn't find pad_value [Dataset Issue]\")\n            concatenated_key = k.replace(\"chosen\", \"concatenated\")\n            concatenated_batch[concatenated_key] = pad_to_length(batch[k], max_length, pad_value=pad_value)\n    for k in batch:\n        if k.startswith(\"rejected\") and isinstance(batch[k], jax.Array):\n            if \"labels\" in k or is_encoder_decoder:\n                pad_value = label_pad_token_id\n            elif k.endswith(\"_input_ids\"):\n                pad_value = padding_value\n            elif k.endswith(\"_attention_mask\"):\n                pad_value = 0\n            else:\n                raise KeyError(\"couldn't find pad_value [Dataset Issue]\")\n            concatenated_key = k.replace(\"rejected\", \"concatenated\")\n            concatenated_batch[concatenated_key] = jnp.concatenate(\n                (\n                    concatenated_batch[concatenated_key],\n                    pad_to_length(batch[k], max_length, pad_value=pad_value),\n                ),\n                axis=0,\n            )\n\n    if is_encoder_decoder:\n        concatenated_batch[\"concatenated_input_ids\"] = batch[\"prompt_input_ids\"].repeat(2, 1)\n        concatenated_batch[\"concatenated_attention_mask\"] = (\n            batch[\"prompt_attention_mask\"].repeat(2, 1)\n        )\n\n    return concatenated_batch\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.create_concatenated_forward","title":"<code>create_concatenated_forward(is_encoder_decoder, label_pad_token_id, padding_value)</code>","text":"<p>The create_concatenated_forward function is a helper function that creates a forward pass function for the model. The forward pass function takes in an apply_fn, which is the model's apply_fn, and runs it on concatenated inputs. It returns chosen log probs, rejected log probs, chosen logits and rejected logits.</p> <p>Parameters:</p> Name Type Description Default <code>is_encoder_decoder</code> <p>Determine whether the model is an encoder-decoder model or not</p> required <code>label_pad_token_id</code> <p>Pad the labels to the same length</p> required <code>padding_value</code> <p>Pad the inputs to the same length</p> required <p>Returns:</p> Type Description <p>A function that takes in a apply_fn, params and a batch of inputs,</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def create_concatenated_forward(\n        is_encoder_decoder,\n        label_pad_token_id,\n        padding_value\n):\n    \"\"\"\n    The create_concatenated_forward function is a helper function that creates a forward pass function for the\n    model. The forward pass function takes in an apply_fn, which is the model's apply_fn, and runs it on concatenated\n    inputs. It returns chosen log probs, rejected log probs, chosen logits and rejected logits.\n\n    :param is_encoder_decoder: Determine whether the model is an encoder-decoder model or not\n    :param label_pad_token_id: Pad the labels to the same length\n    :param padding_value: Pad the inputs to the same length\n    :return: A function that takes in a apply_fn, params and a batch of inputs,\n    \"\"\"\n\n    def concatenated_forward(\n            apply_fn: Callable,\n            params: dict | flax.core.FrozenDict,\n            batch: Dict[str, Union[List, chex.Array]]\n\n    ) -&gt; Tuple[chex.Array, chex.Array, chex.Array, chex.Array]:\n        \"\"\"\n        The concatenated_forward function is used to compute the log-probabilities of both chosen and rejected labels.\n\n        :param apply_fn: Callable: Pass in the model function\n        :param params: dict | flax.core.FrozenDict: Pass the model parameters to the function\n        :param batch: Dict[str, Union[List, chex.Array]] : Pass the batch of data to the concatenated_forward function\n        :return: The log_probs of the chosen and rejected labels, as well as their corresponding logits\n        \"\"\"\n        concatenated_batch = concatenated_inputs(\n            batch,\n            is_encoder_decoder=is_encoder_decoder,\n            label_pad_token_id=label_pad_token_id,\n            padding_value=padding_value,\n        )\n        len_chosen = batch[\"chosen_labels\"].shape[0]\n        concatenated_batch[\"concatenated_input_ids\"] = concatenated_batch[\"concatenated_input_ids\"].reshape(\n            concatenated_batch[\"concatenated_input_ids\"].shape[0], -1\n        )\n        concatenated_batch[\"concatenated_labels\"] = concatenated_batch[\"concatenated_labels\"].reshape(\n            concatenated_batch[\"concatenated_labels\"].shape[0], -1\n        )\n        concatenated_batch[\"concatenated_attention_mask\"] = concatenated_batch[\"concatenated_attention_mask\"].reshape(\n            concatenated_batch[\"concatenated_attention_mask\"].shape[0], -1\n        )\n        model_kwargs = (\n            {\n                \"labels\": concatenated_batch[\"concatenated_labels\"],\n                \"decoder_input_ids\": concatenated_batch.pop(\"concatenated_decoder_input_ids\", None),\n            }\n            if is_encoder_decoder\n            else {}\n        )\n        all_logits = apply_fn(\n            concatenated_batch[\"concatenated_input_ids\"],\n            attention_mask=concatenated_batch[\"concatenated_attention_mask\"],\n            params=params,\n            **model_kwargs,\n        ).logits\n\n        all_log_probs = get_batch_log_probs(\n            all_logits,\n            concatenated_batch[\"concatenated_labels\"],\n            average_log_prob=False,\n            is_encoder_decoder=is_encoder_decoder,\n            label_pad_token_id=label_pad_token_id,\n        )\n\n        chosen_log_probs = all_log_probs[:len_chosen]\n        rejected_log_probs = all_log_probs[len_chosen:]\n\n        chosen_logits = all_logits[:len_chosen]\n        rejected_logits = all_logits[len_chosen:]\n\n        return chosen_log_probs, rejected_log_probs, chosen_logits, rejected_logits\n\n    return concatenated_forward\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.create_dpo_train_function","title":"<code>create_dpo_train_function(concatenated_forward, ref_state=None, beta=0.1, label_smoothing=0, loss_type='sigmoid', reference_free=False)</code>","text":"<p>The create_dpo_train_function function is a helper function that creates the DPO training step.</p> <p>Parameters:</p> Name Type Description Default <code>concatenated_forward</code> <code>Callable</code> <p>Callable: Define the forward pass of the model</p> required <code>ref_state</code> <code>EasyDelState</code> <p>EasyDelState: Specify the reference policy</p> <code>None</code> <code>beta</code> <code>float</code> <p>float: Scale the logits</p> <code>0.1</code> <code>label_smoothing</code> <code>float</code> <p>float: Smooth the labels</p> <code>0</code> <code>loss_type</code> <code>Literal['sigmoid', 'hinge', 'ipo', 'kto']</code> <p>Literal[\"sigmoid\", \"hinge\", \"ipo\", \"kto\"]: Determine the loss function</p> <code>'sigmoid'</code> <code>reference_free</code> <code>bool</code> <p>bool: Indicate whether the reference policy is used or not</p> <code>False</code> <p>Returns:</p> Type Description <p>A function that takes in a state and a batch</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def create_dpo_train_function(\n        concatenated_forward: Callable,\n        ref_state: EasyDelState = None,\n        beta: float = 0.1,\n        label_smoothing: float = 0,\n        loss_type: Literal[\"sigmoid\", \"hinge\", \"ipo\", \"kto\"] = \"sigmoid\",\n        reference_free: bool = False,\n):\n    \"\"\"\n    The create_dpo_train_function function is a helper function that creates the DPO training step.\n\n    :param concatenated_forward: Callable: Define the forward pass of the model\n    :param ref_state: EasyDelState: Specify the reference policy\n    :param beta: float: Scale the logits\n    :param label_smoothing: float: Smooth the labels\n    :param loss_type:  Literal[\"sigmoid\", \"hinge\", \"ipo\", \"kto\"]: Determine the loss function\n    :param reference_free: bool: Indicate whether the reference policy is used or not\n    :return: A function that takes in a state and a batch\n    \"\"\"\n\n    def _sigmoid_dpo_loss(\n            logits: chex.Array,\n            policy_chosen_log_probs: chex.Array = None,  # IGNORED\n            reference_chosen_log_probs: chex.Array = None,  # IGNORED\n            policy_rejected_log_probs: chex.Array = None,  # IGNORED\n            reference_rejected_log_probs: chex.Array = None  # IGNORED\n    ):\n\n        \"\"\"\n        The _sigmoid_dpo_loss function is a helper function for the sigmoid_dpo_loss\n            function. It computes the loss of each example in a batch, given its logits\n            and (optionally) its chosen/rejected log probabilities under both policies.\n\n        :param logits: chex.Array: Compute the loss\n        :param policy_chosen_log_probs: chex.Array: Calculate the policy loss\n        :param # IGNORED\n                    reference_chosen_log_probs: chex.Array: Compute the loss for the reference policy\n        :param # IGNORED\n                    policy_rejected_log_probs: chex.Array: Calculate the loss for the rejected samples\n        :param # IGNORED\n                    reference_rejected_log_probs: chex.Array: Calculate the loss of rejected samples\n        :return: an array represent loss\n        \"\"\"\n        losses = (\n                -jax.nn.log_sigmoid(beta * logits) * (1 - label_smoothing)\n                - jax.nn.log_sigmoid(-beta * logits) * label_smoothing\n        )\n        return losses\n\n    def _hinge_dpo_loss(\n            logits: chex.Array,\n            policy_chosen_log_probs: chex.Array,  # IGNORED\n            reference_chosen_log_probs: chex.Array,  # IGNORED\n            policy_rejected_log_probs: chex.Array,  # IGNORED\n            reference_rejected_log_probs: chex.Array  # IGNORED\n    ):\n\n        \"\"\"\n        The _hinge_dpo_loss function is a helper function that computes the loss for DPO.\n\n        :param logits: chex.Array: Calculate the hinge loss\n        :param policy_chosen_log_probs: chex.Array: Compute the policy loss\n        :param # IGNORED\n                    reference_chosen_log_probs: chex.Array: Compute the loss\n        :param # IGNORED\n                    policy_rejected_log_probs: chex.Array: Calculate the loss\n        :param # IGNORED\n                    reference_rejected_log_probs: chex.Array  # IGNORED: Calculate the loss\n        :return: an array represent The hinge loss\n        \"\"\"\n        return jax.relu(1 - beta * logits)\n\n    def _ipo_dpo_loss(\n            logits: chex.Array,\n            policy_chosen_log_probs: chex.Array,  # IGNORED\n            reference_chosen_log_probs: chex.Array,  # IGNORED\n            policy_rejected_log_probs: chex.Array,  # IGNORED\n            reference_rejected_log_probs: chex.Array  # IGNORED\n    ):\n        \"\"\"\n         The _ipo_dpo_loss function is a helper function that calculates the loss for\n         the IPO-DPO algorithm. It takes in the logits, policy_chosen_log_probs,\n         reference_chosen_log_probs, policy rejected log probs and reference rejected\n         log probs as inputs. The output of this function is used to calculate the loss\n         for each batch of data.\n\n         :param logits: chex.Array: Calculate the loss\n         :param policy_chosen_log_probs: chex.Array: Compute the\n         :param # IGNORED\n                     reference_chosen_log_probs: chex.Array: Compute the loss\n         :param # IGNORED\n                     policy_rejected_log_probs: chex.Array: Calculate the probability of rejecting a policy\n         :param # IGNORED\n                     reference_rejected_log_probs: chex.Array  # IGNORED: Make sure that the function\n         :return: an array represent loss\n         \"\"\"\n        return (logits - 1 / (2 * beta)) ** 2\n\n    def _kto_pair_dpo_loss(\n            logits: chex.Array,  # IGNORED\n            policy_chosen_log_probs: chex.Array,\n            reference_chosen_log_probs: chex.Array,\n            policy_rejected_log_probs: chex.Array,\n            reference_rejected_log_probs: chex.Array\n    ):\n\n        \"\"\"\n        The _kto_pair_dpo_loss function is a helper function that computes the loss for\n        a single pair of trajectories. It takes in two sets of log probabilities, one from\n        the policy and one from the reference distribution. The first set are the log\n        probabilities for actions taken by each agent in a trajectory, while the second set\n        are those for actions not taken by each agent (i.e., rejected). The function then\n        computes KL divergences between these two sets of distributions and uses them to compute losses.\n\n        :param logits: chex.Array: Calculate the log_probs\n        :param # IGNORED\n                    policy_chosen_log_probs: chex.Array: Calculate the chosen_kl\n        :param reference_chosen_log_probs: chex.Array: Calculate the chosen_kl\n        :param policy_rejected_log_probs: chex.Array: Calculate the rejected_kl variable\n        :param reference_rejected_log_probs: chex.Array: Calculate the rejected_kl variable\n        :return: an array represent loss\n        \"\"\"\n        chosen_kl = jax.lax.clamp(\n            min=0,\n            x=jnp.mean(policy_chosen_log_probs - reference_chosen_log_probs),\n            max=1e9\n        )\n        rejected_kl = jax.lax.clamp(\n            min=0,\n            x=jnp.mean(policy_rejected_log_probs - reference_rejected_log_probs),\n            max=1e9\n        )\n\n        chosen_log_ratios = policy_chosen_log_probs - reference_chosen_log_probs\n        rejected_log_ratios = policy_rejected_log_probs - reference_rejected_log_probs\n        losses = jnp.concatenate(\n            (\n                1 - jax.nn.sigmoid(beta * (chosen_log_ratios - rejected_kl)),\n                1 - jax.nn.sigmoid(beta * (chosen_kl - rejected_log_ratios)),\n            ),\n            0,\n        )\n\n        return losses\n\n    if loss_type == \"sigmoid\":\n        _loss_func = _sigmoid_dpo_loss\n    elif loss_type == \"hinge\":\n        _loss_func = _hinge_dpo_loss\n    elif loss_type == \"ipo\":\n        _loss_func = _ipo_dpo_loss\n    elif loss_type == \"kto_pair\":\n        _loss_func = _kto_pair_dpo_loss\n    else:\n        raise ValueError(f\"UnKnown loss_type {loss_type}\")\n\n    def dpo_step(\n            state: EasyDelState,\n            batch: dict\n    ) -&gt; EasyDelState:\n\n        \"\"\"\n        The dpo_step function is the core of DPO. It takes a state and a batch,\n        and returns an updated state. The update is done by calculating the loss\n        for each example in the batch, then taking its gradient with respect to\n        the parameters of the policy network (which are stored in `state`). This\n        gradient is then used to update `state`.\n\n        :param state: EasyDelState: Store the parameters of the model\n        :param batch: dict: Pass the data to the model\n        :return: A new state, which is a collection of the parameters and apply_fn\n        \"\"\"\n\n        def calculate_loss(params: dict | flax.core.FrozenDict):\n            (\n                policy_chosen_log_probs,\n                policy_rejected_log_probs,\n                policy_chosen_logits,\n                policy_rejected_logits,\n            ) = concatenated_forward(\n                state.apply_fn,\n                params,\n                batch\n            )\n\n            if \"reference_chosen_log_probs\" in batch and \"reference_rejected_log_probs\" in batch:\n                reference_chosen_log_probs = batch[\"reference_chosen_log_probs\"]\n                reference_rejected_log_probs = batch[\"reference_rejected_log_probs\"]\n            else:\n                if ref_state is None:\n                    (\n                        reference_chosen_log_probs,\n                        reference_rejected_log_probs,\n                        _,\n                        _,\n                    ) = concatenated_forward(\n                        state.apply_fn,\n                        state.params,\n                        batch\n                    )\n                else:\n                    (\n                        reference_chosen_log_probs,\n                        reference_rejected_log_probs,\n                        _,\n                        _,\n                    ) = concatenated_forward(\n                        ref_state.apply_fn,\n                        ref_state.params,\n                        batch\n                    )\n\n            pi_log_ratios = policy_chosen_log_probs - policy_rejected_log_probs\n\n            if reference_free:\n                ref_log_ratios = 0\n            else:\n                ref_log_ratios = reference_chosen_log_probs - reference_rejected_log_probs\n\n            logits = pi_log_ratios - ref_log_ratios\n            losses = _loss_func(\n                logits,\n                policy_chosen_log_probs,\n                reference_chosen_log_probs,\n                policy_rejected_log_probs,\n                reference_rejected_log_probs\n            )\n            chosen_rewards = (\n                    beta\n                    * (\n                            policy_chosen_log_probs - reference_chosen_log_probs\n                    )\n            )\n            rejected_rewards = (\n                    beta\n                    * (\n                            policy_rejected_log_probs\n                            - reference_rejected_log_probs\n                    )\n            )\n\n            return losses, chosen_rewards, rejected_rewards\n\n        grad_fn = jax.value_and_grad(calculate_loss, has_aux=True)\n        (__loss, __chosen_rewards, __rejected_rewards), grads = grad_fn(state.params)\n        state = state.apply_gradients(grads=grads)\n        return state\n\n    return dpo_step\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-dpo_trainer/#lib.python.EasyDel.reinforcement_learning.trainer.dpo_trainer.get_batch_log_probs","title":"<code>get_batch_log_probs(logits, labels, average_log_prob=False, label_pad_token_id=-100, is_encoder_decoder=False)</code>","text":"<p>The get_batch_log_probs function computes the log probability of a batch of sequences.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>Array</code> <p>chex.Array: Compute the log_softmax of the input</p> required <code>labels</code> <code>Array</code> <p>chex.Array: Mask the logits</p> required <code>average_log_prob</code> <code>bool</code> <p>bool: Determine whether to average the log prob over the sequence length</p> <code>False</code> <code>label_pad_token_id</code> <code>int</code> <p>int: Mask out the padding tokens in the labels</p> <code>-100</code> <code>is_encoder_decoder</code> <code>bool</code> <p>bool: Indicate whether the model is an encoder-decoder model</p> <code>False</code> <code></code> <p>Determine whether to average the log probability over all tokens or not</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The log probability of the labels given the logits</p> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/dpo_trainer.py</code> <pre><code>def get_batch_log_probs(\n        logits: chex.Array,\n        labels: chex.Array,\n        average_log_prob: bool = False,\n        label_pad_token_id: int = -100,\n        is_encoder_decoder: bool = False,\n) -&gt; chex.Array:\n    \"\"\"\n    The get_batch_log_probs function computes the log probability of a batch of sequences.\n\n    :param logits: chex.Array: Compute the log_softmax of the input\n    :param labels: chex.Array: Mask the logits\n    :param average_log_prob: bool: Determine whether to average the log prob over the sequence length\n    :param label_pad_token_id: int: Mask out the padding tokens in the labels\n    :param is_encoder_decoder: bool: Indicate whether the model is an encoder-decoder model\n    :param : Determine whether to average the log probability over all tokens or not\n    :return: The log probability of the labels given the logits\n    \"\"\"\n\n    # sudo code\n    # (per_token_log_probs * loss_mask).sum(-1)\n    # or\n    # (per_token_log_probs * loss_mask).sum(-1) / loss_mask.sum(-1)\n\n    if logits.shape[:-1] != labels.shape:\n        raise ValueError(\"Logits (batch and sequence length dim) and labels must have the same shape.\")\n\n    if not is_encoder_decoder:\n        labels = labels[:, 1:]\n        logits = logits[:, :-1, :]\n\n    batch, seq_len, dim = logits.shape\n    loss_mask = labels != label_pad_token_id\n    labels = jax.lax.select(\n        labels == label_pad_token_id,\n        jnp.zeros(labels.shape, dtype=labels.dtype),\n        labels\n    )\n    logits_log_s = jax.nn.log_softmax(\n        logits, -1\n    )\n    per_token_log_probs = jnp.take_along_axis(\n        logits_log_s,\n        axis=2,\n        indices=labels[:, :, None]\n    ).reshape(batch, seq_len)\n\n    if average_log_prob:\n        log_prob = jnp.sum((per_token_log_probs * loss_mask), axis=-1) / jnp.sum(loss_mask, axis=-1)\n    else:\n        log_prob = jnp.sum((per_token_log_probs * loss_mask), axis=-1)\n\n    return log_prob\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-partitioner_config/","title":"reinforcement_learning.trainer.partitioner_config","text":""},{"location":"generated-reinforcement_learning-trainer-ppo_config/","title":"reinforcement_learning.trainer.ppo_config","text":""},{"location":"generated-reinforcement_learning-trainer-ppo_config/#lib.python.EasyDel.reinforcement_learning.trainer.ppo_config.PPOConfig","title":"<code>PPOConfig</code>","text":"Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/ppo_config.py</code> <pre><code>class PPOConfig:\n    def __init__(\n            self,\n            exp_name: str = os.path.basename(sys.argv[0])[: -len(\".py\")],\n            seed: int = 0,\n            task_name: Optional[str] = None,\n            model_name: Optional[str] = None,\n            query_dataset: Optional[str] = None,\n            reward_model: Optional[str] = None,\n            remove_unused_columns: bool = True,\n            tracker_kwargs: Optional[dict] = None,\n            accelerator_kwargs: Optional[dict] = None,\n            project_kwargs: Optional[dict] = None,\n            tracker_project_name: str = \"trl\",\n            push_to_hub_if_best_kwargs: Optional[dict] = None,\n            steps: int = 20000,\n            learning_rate: float = 1e-5,\n            adap_kl_ctrl: bool = True,\n            init_kl_coef: Optional[float] = 0.2,\n            kl_penalty: Literal[\"kl\", \"abs\", \"mse\", \"full\"] = \"kl\",\n            target: Optional[float] = 6,\n            horizon: Optional[float] = 10000,\n            gamma: float = 1,\n            lam: float = 0.95,\n            cliprange: float = 0.2,\n            cliprange_value: float = 0.2,\n            vf_coef: float = 0.1,\n            batch_size: int = 256,\n            gradient_accumulation_steps: int = 1,\n            ppo_epochs: int = 4,\n            max_grad_norm: Optional[float] = None,\n            target_kl: float = 1,\n            compare_steps: int = 1,\n            ratio_threshold: float = 10.0,\n            use_score_scaling: bool = False,\n            use_score_norm: bool = False,\n            score_clip: Optional[float] = None,\n            whiten_rewards: bool = False,\n            is_encoder_decoder: Optional[bool] = None,\n            warmup_steps: Optional[int] = 0,\n            learning_rate_end: float = 1e-5,\n            extra_optimizer_kwargs: dict | None = None,\n            weight_decay: Optional[float] = 0.01,\n    ):\n        \"\"\"\n    Configuration class for PPOTrainer\n    :param exp_name: str : the name of this experiment (by default is the file name without the extension name)\n    :param seed: int :Seed value for random generations\n    :param task_name: Optional[str] : Name of task to use - used only for tracking purposes\n    :param model_name: Optional[str] :Name of model to use - used only for tracking purposes\n    :param query_dataset: Optional[str] :Name of dataset to query - used only for tracking purposes\n    :param reward_model: Optional[str] :The reward model to use - used only for tracking purposes\n    :param remove_unused_columns: bool : Remove unused columns from the dataset if `datasets.Dataset` is used\n    :param tracker_kwargs: Optional[dict] : Keyword arguments for the tracker\n    :param accelerator_kwargs: Optional[dict] :Keyword arguments for the accelerator\n    :param project_kwargs: Optional[dict] : Keyword arguments for the accelerator project config (e.g. `logging_dir`)\n    :param tracker_project_name: str :Name of project to use for tracking\n    :param push_to_hub_if_best_kwargs: Optional[dict] :Keyword arguments for pushing model to the hub during training\n    (e.g. pretrained_model_name_or_path).\n    :param steps: int : Number of training steps\n    :param learning_rate: float :Adam learning rate\n    :param adap_kl_ctrl: bool :Use adaptive KL control, otherwise linear\n    :param init_kl_coef: Optional[float] : Initial KL penalty coefficient (used for adaptive and linear control)\n    :param kl_penalty: Literal[\"kl\", \"abs\", \"mse\", \"full\"] : kl penalty options: 'kl': model_logp - ref_logp,\n    'abs': abs(kl),  'mse': mean squared error mse(kl) and 'full': the actual kl for all tokens in the distribution\n    :param target: Optional[float] :Target KL value for adaptive KL control\n    :param horizon: Optional[float] :Horizon for adaptive KL control\n    :param gamma: float :Gamma parameter for advantage calculation\n    :param lam: float : Lambda parameter for advantage calculation\n    :param cliprange: float : Range for clipping in PPO policy gradient loss\n    :param cliprange_value: float : Range for clipping values in loss calculation\n    :param vf_coef: float : Scaling factor for value loss\n    :param batch_size: int :Number of samples per optimisation step\n    :param gradient_accumulation_steps: int :The number of gradient accumulation steps\n    :param ppo_epochs: int : Number of optimisation epochs per batch of samples\n    :param max_grad_norm: Optional[float] :Maximum gradient norm for gradient clipping\n    :param target_kl: float :Stop early if we exceed this value by over 50%\n    :param compare_steps: int : Number of steps between comparison of the current reward with the best seen so far\n    :param ratio_threshold : float :Skip mini-batches with high PPO ratios that can cause loss spikes\n    :param use_score_scaling: bool : Use score scaling\n    :param use_score_norm: bool : Use score normalization. Only applicable if use_score_scaling is True\n    :param score_clip: Optional[float] :Score clipping\n    :param whiten_rewards: bool :Whiten the rewards before compute advantages\n    :param is_encoder_decoder: Optional[bool] :TO BE FILLED In RUNTIME: Whether the model is an encoder-decoder model\n    :param warmup_steps: Optional[int]:\n    :param learning_rate_end: float :\n    :param extra_optimizer_kwargs: dict | None :\n    :param weight_decay: Optional[float] : Weight decay is Optimizer Weight decay :\\\n        \"\"\"\n\n        tracker_kwargs = tracker_kwargs if tracker_kwargs is not None else {}\n        accelerator_kwargs = accelerator_kwargs if accelerator_kwargs is not None else {}\n        project_kwargs = project_kwargs if project_kwargs is not None else {}\n        push_to_hub_if_best_kwargs = push_to_hub_if_best_kwargs if push_to_hub_if_best_kwargs is not None else {}\n        self.exp_name = exp_name\n        self.seed = seed\n        self.task_name = task_name\n        self.model_name = model_name\n        self.query_dataset = query_dataset\n        self.reward_model = reward_model\n        self.remove_unused_columns = remove_unused_columns\n        self.tracker_kwargs = tracker_kwargs\n        self.accelerator_kwargs = accelerator_kwargs\n        self.project_kwargs = project_kwargs\n        self.tracker_project_name = tracker_project_name\n        self.push_to_hub_if_best_kwargs = push_to_hub_if_best_kwargs\n        self.steps = steps\n        self.learning_rate = learning_rate\n        self.adap_kl_ctrl = adap_kl_ctrl\n        self.init_kl_coef = init_kl_coef\n        self.kl_penalty = kl_penalty\n        self.target = target\n        self.horizon = horizon\n        self.gamma = gamma\n        self.lam = lam\n        self.cliprange = cliprange\n        self.cliprange_value = cliprange_value\n        self.vf_coef = vf_coef\n        self.batch_size = batch_size\n        self.gradient_accumulation_steps = gradient_accumulation_steps\n        self.ppo_epochs = ppo_epochs\n        self.max_grad_norm = max_grad_norm\n        self.target_kl = target_kl\n        self.compare_steps = compare_steps\n        self.ratio_threshold = ratio_threshold\n        self.use_score_scaling = use_score_scaling\n        self.use_score_norm = use_score_norm\n        self.score_clip = score_clip\n        self.whiten_rewards = whiten_rewards\n        self.is_encoder_decoder = is_encoder_decoder\n        self.warmup_steps = warmup_steps\n        self.learning_rate_end = learning_rate_end\n        self.extra_optimizer_kwargs = extra_optimizer_kwargs\n        self.weight_decay = weight_decay\n        self.total_ppo_epochs = int(np.ceil(self.steps / (self.batch_size * self.gradient_accumulation_steps)))\n        assert self.kl_penalty in [\"kl\", \"abs\", \"mse\", \"full\"]\n\n    def to_dict(self):\n        output_dict = {}\n        for key, value in self.__dict__.items():\n            output_dict[key] = value\n        return flatten_dict(output_dict)\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-ppo_config/#lib.python.EasyDel.reinforcement_learning.trainer.ppo_config.PPOConfig.__init__","title":"<code>__init__(exp_name=os.path.basename(sys.argv[0])[:-len('.py')], seed=0, task_name=None, model_name=None, query_dataset=None, reward_model=None, remove_unused_columns=True, tracker_kwargs=None, accelerator_kwargs=None, project_kwargs=None, tracker_project_name='trl', push_to_hub_if_best_kwargs=None, steps=20000, learning_rate=1e-05, adap_kl_ctrl=True, init_kl_coef=0.2, kl_penalty='kl', target=6, horizon=10000, gamma=1, lam=0.95, cliprange=0.2, cliprange_value=0.2, vf_coef=0.1, batch_size=256, gradient_accumulation_steps=1, ppo_epochs=4, max_grad_norm=None, target_kl=1, compare_steps=1, ratio_threshold=10.0, use_score_scaling=False, use_score_norm=False, score_clip=None, whiten_rewards=False, is_encoder_decoder=None, warmup_steps=0, learning_rate_end=1e-05, extra_optimizer_kwargs=None, weight_decay=0.01)</code>","text":"<p>Configuration class for PPOTrainer</p> <p>Parameters:</p> Name Type Description Default <code>exp_name</code> <code>str</code> <p>str : the name of this experiment (by default is the file name without the extension name)</p> <code>basename(argv[0])[:-len('.py')]</code> <code>seed</code> <code>int</code> <p>int :Seed value for random generations</p> <code>0</code> <code>task_name</code> <code>Optional[str]</code> <p>Optional[str] : Name of task to use - used only for tracking purposes</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>Optional[str] :Name of model to use - used only for tracking purposes</p> <code>None</code> <code>query_dataset</code> <code>Optional[str]</code> <p>Optional[str] :Name of dataset to query - used only for tracking purposes</p> <code>None</code> <code>reward_model</code> <code>Optional[str]</code> <p>Optional[str] :The reward model to use - used only for tracking purposes</p> <code>None</code> <code>remove_unused_columns</code> <code>bool</code> <p>bool : Remove unused columns from the dataset if <code>datasets.Dataset</code> is used</p> <code>True</code> <code>tracker_kwargs</code> <code>Optional[dict]</code> <p>Optional[dict] : Keyword arguments for the tracker</p> <code>None</code> <code>accelerator_kwargs</code> <code>Optional[dict]</code> <p>Optional[dict] :Keyword arguments for the accelerator</p> <code>None</code> <code>project_kwargs</code> <code>Optional[dict]</code> <p>Optional[dict] : Keyword arguments for the accelerator project config (e.g. <code>logging_dir</code>)</p> <code>None</code> <code>tracker_project_name</code> <code>str</code> <p>str :Name of project to use for tracking</p> <code>'trl'</code> <code>push_to_hub_if_best_kwargs</code> <code>Optional[dict]</code> <p>Optional[dict] :Keyword arguments for pushing model to the hub during training (e.g. pretrained_model_name_or_path).</p> <code>None</code> <code>steps</code> <code>int</code> <p>int : Number of training steps</p> <code>20000</code> <code>learning_rate</code> <code>float</code> <p>float :Adam learning rate</p> <code>1e-05</code> <code>adap_kl_ctrl</code> <code>bool</code> <p>bool :Use adaptive KL control, otherwise linear</p> <code>True</code> <code>init_kl_coef</code> <code>Optional[float]</code> <p>Optional[float] : Initial KL penalty coefficient (used for adaptive and linear control)</p> <code>0.2</code> <code>kl_penalty</code> <code>Literal['kl', 'abs', 'mse', 'full']</code> <p>Literal[\"kl\", \"abs\", \"mse\", \"full\"] : kl penalty options: 'kl': model_logp - ref_logp, 'abs': abs(kl),  'mse': mean squared error mse(kl) and 'full': the actual kl for all tokens in the distribution</p> <code>'kl'</code> <code>target</code> <code>Optional[float]</code> <p>Optional[float] :Target KL value for adaptive KL control</p> <code>6</code> <code>horizon</code> <code>Optional[float]</code> <p>Optional[float] :Horizon for adaptive KL control</p> <code>10000</code> <code>gamma</code> <code>float</code> <p>float :Gamma parameter for advantage calculation</p> <code>1</code> <code>lam</code> <code>float</code> <p>float : Lambda parameter for advantage calculation</p> <code>0.95</code> <code>cliprange</code> <code>float</code> <p>float : Range for clipping in PPO policy gradient loss</p> <code>0.2</code> <code>cliprange_value</code> <code>float</code> <p>float : Range for clipping values in loss calculation</p> <code>0.2</code> <code>vf_coef</code> <code>float</code> <p>float : Scaling factor for value loss</p> <code>0.1</code> <code>batch_size</code> <code>int</code> <p>int :Number of samples per optimisation step</p> <code>256</code> <code>gradient_accumulation_steps</code> <code>int</code> <p>int :The number of gradient accumulation steps</p> <code>1</code> <code>ppo_epochs</code> <code>int</code> <p>int : Number of optimisation epochs per batch of samples</p> <code>4</code> <code>max_grad_norm</code> <code>Optional[float]</code> <p>Optional[float] :Maximum gradient norm for gradient clipping</p> <code>None</code> <code>target_kl</code> <code>float</code> <p>float :Stop early if we exceed this value by over 50%</p> <code>1</code> <code>compare_steps</code> <code>int</code> <p>int : Number of steps between comparison of the current reward with the best seen so far</p> <code>1</code> <code></code> <code>ratio_threshold</code> <p>float :Skip mini-batches with high PPO ratios that can cause loss spikes</p> required <code>use_score_scaling</code> <code>bool</code> <p>bool : Use score scaling</p> <code>False</code> <code>use_score_norm</code> <code>bool</code> <p>bool : Use score normalization. Only applicable if use_score_scaling is True</p> <code>False</code> <code>score_clip</code> <code>Optional[float]</code> <p>Optional[float] :Score clipping</p> <code>None</code> <code>whiten_rewards</code> <code>bool</code> <p>bool :Whiten the rewards before compute advantages</p> <code>False</code> <code>is_encoder_decoder</code> <code>Optional[bool]</code> <p>Optional[bool] :TO BE FILLED In RUNTIME: Whether the model is an encoder-decoder model</p> <code>None</code> <code>warmup_steps</code> <code>Optional[int]</code> <p>Optional[int]:</p> <code>0</code> <code>learning_rate_end</code> <code>float</code> <p>float :</p> <code>1e-05</code> <code>extra_optimizer_kwargs</code> <code>dict | None</code> <p>dict | None :</p> <code>None</code> <code>weight_decay</code> <code>Optional[float]</code> <p>Optional[float] : Weight decay is Optimizer Weight decay :</p> <code>0.01</code> Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/ppo_config.py</code> <pre><code>def __init__(\n        self,\n        exp_name: str = os.path.basename(sys.argv[0])[: -len(\".py\")],\n        seed: int = 0,\n        task_name: Optional[str] = None,\n        model_name: Optional[str] = None,\n        query_dataset: Optional[str] = None,\n        reward_model: Optional[str] = None,\n        remove_unused_columns: bool = True,\n        tracker_kwargs: Optional[dict] = None,\n        accelerator_kwargs: Optional[dict] = None,\n        project_kwargs: Optional[dict] = None,\n        tracker_project_name: str = \"trl\",\n        push_to_hub_if_best_kwargs: Optional[dict] = None,\n        steps: int = 20000,\n        learning_rate: float = 1e-5,\n        adap_kl_ctrl: bool = True,\n        init_kl_coef: Optional[float] = 0.2,\n        kl_penalty: Literal[\"kl\", \"abs\", \"mse\", \"full\"] = \"kl\",\n        target: Optional[float] = 6,\n        horizon: Optional[float] = 10000,\n        gamma: float = 1,\n        lam: float = 0.95,\n        cliprange: float = 0.2,\n        cliprange_value: float = 0.2,\n        vf_coef: float = 0.1,\n        batch_size: int = 256,\n        gradient_accumulation_steps: int = 1,\n        ppo_epochs: int = 4,\n        max_grad_norm: Optional[float] = None,\n        target_kl: float = 1,\n        compare_steps: int = 1,\n        ratio_threshold: float = 10.0,\n        use_score_scaling: bool = False,\n        use_score_norm: bool = False,\n        score_clip: Optional[float] = None,\n        whiten_rewards: bool = False,\n        is_encoder_decoder: Optional[bool] = None,\n        warmup_steps: Optional[int] = 0,\n        learning_rate_end: float = 1e-5,\n        extra_optimizer_kwargs: dict | None = None,\n        weight_decay: Optional[float] = 0.01,\n):\n    \"\"\"\nConfiguration class for PPOTrainer\n:param exp_name: str : the name of this experiment (by default is the file name without the extension name)\n:param seed: int :Seed value for random generations\n:param task_name: Optional[str] : Name of task to use - used only for tracking purposes\n:param model_name: Optional[str] :Name of model to use - used only for tracking purposes\n:param query_dataset: Optional[str] :Name of dataset to query - used only for tracking purposes\n:param reward_model: Optional[str] :The reward model to use - used only for tracking purposes\n:param remove_unused_columns: bool : Remove unused columns from the dataset if `datasets.Dataset` is used\n:param tracker_kwargs: Optional[dict] : Keyword arguments for the tracker\n:param accelerator_kwargs: Optional[dict] :Keyword arguments for the accelerator\n:param project_kwargs: Optional[dict] : Keyword arguments for the accelerator project config (e.g. `logging_dir`)\n:param tracker_project_name: str :Name of project to use for tracking\n:param push_to_hub_if_best_kwargs: Optional[dict] :Keyword arguments for pushing model to the hub during training\n(e.g. pretrained_model_name_or_path).\n:param steps: int : Number of training steps\n:param learning_rate: float :Adam learning rate\n:param adap_kl_ctrl: bool :Use adaptive KL control, otherwise linear\n:param init_kl_coef: Optional[float] : Initial KL penalty coefficient (used for adaptive and linear control)\n:param kl_penalty: Literal[\"kl\", \"abs\", \"mse\", \"full\"] : kl penalty options: 'kl': model_logp - ref_logp,\n'abs': abs(kl),  'mse': mean squared error mse(kl) and 'full': the actual kl for all tokens in the distribution\n:param target: Optional[float] :Target KL value for adaptive KL control\n:param horizon: Optional[float] :Horizon for adaptive KL control\n:param gamma: float :Gamma parameter for advantage calculation\n:param lam: float : Lambda parameter for advantage calculation\n:param cliprange: float : Range for clipping in PPO policy gradient loss\n:param cliprange_value: float : Range for clipping values in loss calculation\n:param vf_coef: float : Scaling factor for value loss\n:param batch_size: int :Number of samples per optimisation step\n:param gradient_accumulation_steps: int :The number of gradient accumulation steps\n:param ppo_epochs: int : Number of optimisation epochs per batch of samples\n:param max_grad_norm: Optional[float] :Maximum gradient norm for gradient clipping\n:param target_kl: float :Stop early if we exceed this value by over 50%\n:param compare_steps: int : Number of steps between comparison of the current reward with the best seen so far\n:param ratio_threshold : float :Skip mini-batches with high PPO ratios that can cause loss spikes\n:param use_score_scaling: bool : Use score scaling\n:param use_score_norm: bool : Use score normalization. Only applicable if use_score_scaling is True\n:param score_clip: Optional[float] :Score clipping\n:param whiten_rewards: bool :Whiten the rewards before compute advantages\n:param is_encoder_decoder: Optional[bool] :TO BE FILLED In RUNTIME: Whether the model is an encoder-decoder model\n:param warmup_steps: Optional[int]:\n:param learning_rate_end: float :\n:param extra_optimizer_kwargs: dict | None :\n:param weight_decay: Optional[float] : Weight decay is Optimizer Weight decay :\\\n    \"\"\"\n\n    tracker_kwargs = tracker_kwargs if tracker_kwargs is not None else {}\n    accelerator_kwargs = accelerator_kwargs if accelerator_kwargs is not None else {}\n    project_kwargs = project_kwargs if project_kwargs is not None else {}\n    push_to_hub_if_best_kwargs = push_to_hub_if_best_kwargs if push_to_hub_if_best_kwargs is not None else {}\n    self.exp_name = exp_name\n    self.seed = seed\n    self.task_name = task_name\n    self.model_name = model_name\n    self.query_dataset = query_dataset\n    self.reward_model = reward_model\n    self.remove_unused_columns = remove_unused_columns\n    self.tracker_kwargs = tracker_kwargs\n    self.accelerator_kwargs = accelerator_kwargs\n    self.project_kwargs = project_kwargs\n    self.tracker_project_name = tracker_project_name\n    self.push_to_hub_if_best_kwargs = push_to_hub_if_best_kwargs\n    self.steps = steps\n    self.learning_rate = learning_rate\n    self.adap_kl_ctrl = adap_kl_ctrl\n    self.init_kl_coef = init_kl_coef\n    self.kl_penalty = kl_penalty\n    self.target = target\n    self.horizon = horizon\n    self.gamma = gamma\n    self.lam = lam\n    self.cliprange = cliprange\n    self.cliprange_value = cliprange_value\n    self.vf_coef = vf_coef\n    self.batch_size = batch_size\n    self.gradient_accumulation_steps = gradient_accumulation_steps\n    self.ppo_epochs = ppo_epochs\n    self.max_grad_norm = max_grad_norm\n    self.target_kl = target_kl\n    self.compare_steps = compare_steps\n    self.ratio_threshold = ratio_threshold\n    self.use_score_scaling = use_score_scaling\n    self.use_score_norm = use_score_norm\n    self.score_clip = score_clip\n    self.whiten_rewards = whiten_rewards\n    self.is_encoder_decoder = is_encoder_decoder\n    self.warmup_steps = warmup_steps\n    self.learning_rate_end = learning_rate_end\n    self.extra_optimizer_kwargs = extra_optimizer_kwargs\n    self.weight_decay = weight_decay\n    self.total_ppo_epochs = int(np.ceil(self.steps / (self.batch_size * self.gradient_accumulation_steps)))\n    assert self.kl_penalty in [\"kl\", \"abs\", \"mse\", \"full\"]\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-ppo_trainer/","title":"reinforcement_learning.trainer.ppo_trainer","text":""},{"location":"generated-reinforcement_learning-trainer-training_configs/","title":"reinforcement_learning.trainer.training_configs","text":""},{"location":"generated-reinforcement_learning-trainer-training_configs/#lib.python.EasyDel.reinforcement_learning.trainer.training_configs.RewardConfig","title":"<code>RewardConfig</code>  <code>dataclass</code>","text":"Source code in <code>lib/python/EasyDel/reinforcement_learning/trainer/training_configs.py</code> <pre><code>@dataclass\nclass RewardConfig:\n    max_length: Optional[int] = None\n    \"\"\"\n    The maximum length of the sequences in the batch. This argument is \n    required if you want to use the default data collator.\n    \"\"\"\n    gradient_checkpointing: Optional[bool] = True\n    \"\"\"If True, use gradient checkpointing to save memory at the expense of slower backward pass.\"\"\"\n    gradient_checkpointing_kwargs: Optional[dict] = None\n    \"\"\"Keyword arguments to pass to the gradient checkpointing function.\"\"\"\n</code></pre>"},{"location":"generated-reinforcement_learning-trainer-training_configs/#lib.python.EasyDel.reinforcement_learning.trainer.training_configs.RewardConfig.gradient_checkpointing","title":"<code>gradient_checkpointing: Optional[bool] = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, use gradient checkpointing to save memory at the expense of slower backward pass.</p>"},{"location":"generated-reinforcement_learning-trainer-training_configs/#lib.python.EasyDel.reinforcement_learning.trainer.training_configs.RewardConfig.gradient_checkpointing_kwargs","title":"<code>gradient_checkpointing_kwargs: Optional[dict] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Keyword arguments to pass to the gradient checkpointing function.</p>"},{"location":"generated-reinforcement_learning-trainer-training_configs/#lib.python.EasyDel.reinforcement_learning.trainer.training_configs.RewardConfig.max_length","title":"<code>max_length: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum length of the sequences in the batch. This argument is  required if you want to use the default data collator.</p>"},{"location":"generated-reinforcement_learning-trainer-utils/","title":"reinforcement_learning.trainer.utils","text":""},{"location":"generated-reinforcement_learning-utils-collectors/","title":"reinforcement_learning.utils.collectors","text":""},{"location":"generated-reinforcement_learning-utils-collectors/#lib.python.EasyDel.reinforcement_learning.utils.collectors.DPODataCollatorWithPadding","title":"<code>DPODataCollatorWithPadding</code>  <code>dataclass</code>","text":"<p>DPO DataCollator class that pads the tokenized inputs to the maximum length of the batch.</p> <p>Parameters:</p> Name Type Description Default <code>pad_token_id</code> <code>int</code> <p>int: The tokenizers pad_token_id.</p> <code>0</code> <code>label_pad_token_id</code> <code>int</code> <p>int: The label used for masking.</p> <code>-100</code> <code>is_encoder_decoder</code> <code>Optional[bool]</code> <p>Optional[bool]: Whether you model has an encoder_decoder architecture</p> <code>False</code> Source code in <code>lib/python/EasyDel/reinforcement_learning/utils/collectors.py</code> <pre><code>@dataclass\nclass DPODataCollatorWithPadding:\n    r\"\"\"\n    DPO DataCollator class that pads the tokenized inputs to the maximum length of the batch.\n\n    :param pad_token_id: int: The tokenizers pad_token_id.\n    :param label_pad_token_id: int: The label used for masking.\n    :param is_encoder_decoder: Optional[bool]: Whether you model has an encoder_decoder architecture\n    \"\"\"\n\n    pad_token_id: int = 0\n    label_pad_token_id: int = -100\n    is_encoder_decoder: Optional[bool] = False\n\n    def __call__(self, features: List[Dict[str, Any]]) -&gt; Dict[str, Any]:\n        padded_batch = {}\n        for k in features[0].keys():\n            if k.endswith(\"_input_ids\") or k.endswith(\"_attention_mask\") or k.endswith(\"_labels\"):\n                if self.is_encoder_decoder:\n                    to_pad = [jnp.array(ex[k], dtype=\"i4\") for ex in features]\n\n                    if (k.startswith(\"prompt\")) and (k.endswith(\"input_ids\")):\n                        padding_value = self.pad_token_id\n                    elif k.endswith(\"_attention_mask\"):\n                        padding_value = 0\n                    elif (k.startswith(\"chosen\")) or (k.startswith(\"rejected\")) or (\"decoder\" in k):\n                        padding_value = self.label_pad_token_id\n                    else:\n                        raise ValueError(f\"Unexpected key in batch '{k}'\")\n                    padded_batch[k] = pad_sequence(to_pad, batch_first=True, padding_value=padding_value)\n                else:\n                    if \"prompt\" in k:\n                        to_pad = [jnp.array(ex[k][::-1], dtype=\"i4\") for ex in features]\n                    else:\n                        to_pad = [jnp.array(ex[k], dtype=\"i4\") for ex in features]\n                    if k.endswith(\"_input_ids\"):\n                        padding_value = self.pad_token_id\n                    elif k.endswith(\"_labels\"):\n                        padding_value = self.label_pad_token_id\n                    elif k.endswith(\"_attention_mask\"):\n                        padding_value = 0\n                    else:\n                        raise ValueError(f\"Unexpected key in batch '{k}'\")\n\n                    padded_batch[k] = pad_sequence(to_pad, batch_first=True, padding_value=padding_value)\n                    if \"prompt\" in k:\n                        padded_batch[k] = jnp.flip(padded_batch[k], axis=[1])\n            elif k.endswith(\"_logps\"):\n                padded_batch[k] = jnp.array([ex[k] for ex in features])\n            else:\n                padded_batch[k] = [ex[k] for ex in features]\n\n        return padded_batch\n</code></pre>"},{"location":"generated-serve-api-client/","title":"serve.api.client","text":""},{"location":"generated-serve-api-configuration/","title":"serve.api.configuration","text":""},{"location":"generated-serve-api-configuration/#lib.python.EasyDel.serve.api.configuration.EasyServeConfig","title":"<code>EasyServeConfig</code>  <code>dataclass</code>","text":"<p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>str: Set the host address of the server</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>int: Specify the port number that the server will run on</p> <code>2059</code> <code>batch_size</code> <code>int</code> <p>int: Set the batch size of the model</p> <code>1</code> <code>max_sequence_length</code> <code>int</code> <p>int: Set the maximum length of the text that can be generated</p> <code>4096</code> <code>max_new_tokens</code> <code>int</code> <p>int: Determine how many tokens can be added to the vocabulary</p> <code>4096</code> <code>max_compile_tokens</code> <code>int</code> <p>int: Set the maximum number of tokens that can be streamed at a time</p> <code>64</code> <code>generation_ps</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec : PartitionSpec to use for sharding data</p> <code>PartitionSpec('dp', 'fsdp')</code> <code>temperature</code> <code>float</code> <p>float: Control the randomness of the output</p> <code>0.1</code> <code>top_p</code> <code>float</code> <p>float: Control the diversity of the text generated</p> <code>0.95</code> <code>top_k</code> <code>int</code> <p>int: Limit the number of tokens that can be generated</p> <code>50</code> <code>logging</code> <code>bool</code> <p>bool: Print out the progress of the server</p> <code>True</code> <code>mesh_axes_names</code> <code>Sequence[str]</code> <p>Sequence[str]: Specify the names of the axes in the mesh tensor</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>mesh_axes_shape</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the shape of the mesh</p> <code>(1, -1, 1, 1)</code> <code>dtype</code> <code>str</code> <p>str: Specify the data type of the model</p> <code>'fp16'</code> <code>use_prefix_tokenizer</code> <code>bool</code> <p>bool: Determine if the tokenizer should be used to generate tokens</p> <code>True</code> <code>pre_compile</code> <code>bool</code> <p>bool: Pre-compile the model</p> <code>True</code> <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>lib/python/EasyDel/serve/api/configuration.py</code> <pre><code>@dataclass\nclass EasyServeConfig:\n    \"\"\"\n    :param host: str: Set the host address of the server\n    :param port: int: Specify the port number that the server will run on\n    :param batch_size: int: Set the batch size of the model\n    :param max_sequence_length: int: Set the maximum length of the text that can be generated\n    :param max_new_tokens: int: Determine how many tokens can be added to the vocabulary\n    :param max_compile_tokens: int: Set the maximum number of tokens that can be streamed at a time\n    :param generation_ps: jax.sharding.PartitionSpec : PartitionSpec to use for sharding data\n    :param temperature: float: Control the randomness of the output\n    :param top_p: float: Control the diversity of the text generated\n    :param top_k: int: Limit the number of tokens that can be generated\n    :param logging: bool: Print out the progress of the server\n    :param mesh_axes_names: Sequence[str]: Specify the names of the axes in the mesh tensor\n    :param mesh_axes_shape: Sequence[int]: Specify the shape of the mesh\n    :param dtype: str: Specify the data type of the model\n    :param use_prefix_tokenizer: bool: Determine if the tokenizer should be used to generate tokens\n    :param pre_compile: bool: Pre-compile the model\n    :return: Nothing\n\n    \"\"\"\n    host: str = \"0.0.0.0\"\n    port: int = 2059\n\n    batch_size: int = 1\n    max_sequence_length: int = 4096\n    max_new_tokens: int = 4096\n    max_compile_tokens: int = 64\n    temperature: float = 0.1\n    top_p: float = 0.95\n    top_k: int = 50\n    greedy: bool = False\n\n    logging: bool = True\n\n    mesh_axes_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\")\n    mesh_axes_shape: Sequence[int] = (1, -1, 1, 1)\n    generation_ps: PartitionSpec = PartitionSpec(\"dp\", \"fsdp\")\n    dtype: str = \"fp16\"\n\n    use_prefix_tokenizer: bool = True\n    pre_compile: bool = True\n\n    verbose: bool = True\n\n    def __repr__(self):\n\n        \"\"\"\n        The __repr__ function is used to generate a string representation of an object.\n        This function should return a string that can be parsed by the Python interpreter\n        to recreate the object. The __repr__ function is called when you use print() on an\n        object, or when you type its name in the REPL.\n\n        :param self: Refer to the instance of the class\n        :return: A string representation of the object\n        \"\"\"\n        string = f\"{self.__class__.__name__}(\\n\"\n        for k, v in self.__dict__.items():\n            if not k.startswith(\"_\"):\n                repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n                string += repr_src if len(repr_src) &lt; 500 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n        return string + \")\"\n\n    def __str__(self):\n\n        \"\"\"\n        The __str__ function is called when you use the print function or when str() is used.\n        It should return a string representation of the object.\n\n        :param self: Refer to the instance of the class\n        :return: The object's string representation\n        \"\"\"\n        return self.__repr__()\n</code></pre>"},{"location":"generated-serve-api-configuration/#lib.python.EasyDel.serve.api.configuration.EasyServeConfig.__repr__","title":"<code>__repr__()</code>","text":"<p>The repr function is used to generate a string representation of an object. This function should return a string that can be parsed by the Python interpreter to recreate the object. The repr function is called when you use print() on an object, or when you type its name in the REPL.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>A string representation of the object</p> Source code in <code>lib/python/EasyDel/serve/api/configuration.py</code> <pre><code>def __repr__(self):\n\n    \"\"\"\n    The __repr__ function is used to generate a string representation of an object.\n    This function should return a string that can be parsed by the Python interpreter\n    to recreate the object. The __repr__ function is called when you use print() on an\n    object, or when you type its name in the REPL.\n\n    :param self: Refer to the instance of the class\n    :return: A string representation of the object\n    \"\"\"\n    string = f\"{self.__class__.__name__}(\\n\"\n    for k, v in self.__dict__.items():\n        if not k.startswith(\"_\"):\n            repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n            string += repr_src if len(repr_src) &lt; 500 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n    return string + \")\"\n</code></pre>"},{"location":"generated-serve-api-configuration/#lib.python.EasyDel.serve.api.configuration.EasyServeConfig.__str__","title":"<code>__str__()</code>","text":"<p>The str function is called when you use the print function or when str() is used. It should return a string representation of the object.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>The object's string representation</p> Source code in <code>lib/python/EasyDel/serve/api/configuration.py</code> <pre><code>def __str__(self):\n\n    \"\"\"\n    The __str__ function is called when you use the print function or when str() is used.\n    It should return a string representation of the object.\n\n    :param self: Refer to the instance of the class\n    :return: The object's string representation\n    \"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"generated-serve-api-dantics/","title":"serve.api.dantics","text":""},{"location":"generated-serve-api-serve/","title":"serve.api.serve","text":""},{"location":"generated-serve-api-serve/#lib.python.EasyDel.serve.api.serve.EasyServe","title":"<code>EasyServe</code>","text":"Source code in <code>lib/python/EasyDel/serve/api/serve.py</code> <pre><code>class EasyServe:\n    def __init__(\n            self,\n            llm: EasyDelFlaxPretrainedModel,\n            params: FrozenDict | dict,\n            tokenizer: PreTrainedTokenizerBase,\n            prefix_tokenizer: PreTrainedTokenizerBase,\n            greedy_generate_function: Callable,\n            non_greedy_generate_function: Callable,\n            serve_config: EasyServeConfig,\n    ):\n        self.llm = llm\n        self.params = params\n        self.tokenizer = tokenizer\n        self.prefix_tokenizer = prefix_tokenizer\n        self.greedy_generate_function = greedy_generate_function\n        self.non_greedy_generate_function = non_greedy_generate_function\n        self.serve_config = serve_config\n        if serve_config.pre_compile:\n            self.compile(verbose=serve_config.verbose)\n        self.fast_api = FastAPI(\n            title=\"EasyDeL\"\n        )\n        self.fast_api.post(\"/generate/v1/conversation\")(self.api_generate_request)\n\n    def get_generation_function(self, greedy: bool):\n        return self.greedy_generate_function if greedy else self.non_greedy_generate_function\n\n    def conversation_template(\n            self, conversation: List[ConversationItem]\n    ) -&gt; str:\n        system = None\n        do_strip = False\n        for conv in conversation:\n            if conv.role == \"system\":\n                system = conv.content\n        messages = [f\"&lt;s&gt;[INST] &lt;&lt;SYS&gt;&gt;\\n{system}\\n&lt;&lt;/SYS&gt;&gt;\\n\\n\"] if system is not None else [\"&lt;s&gt;[INST] \"]\n        for conv in conversation:\n            content = conv.content.strip() if do_strip else conv.content\n            role = conv.role\n            do_strip = True\n            if role == \"user\" or role == \"assistant\":\n                messages.append(f\"{content} [/INST] \" if role == \"user\" else f\"{content} &lt;/s&gt;&lt;s&gt;[INST] \")\n        return ''.join(messages)\n\n    def api_generate_request(self, request: GenerateAPIRequest):\n\n        prompt = self.conversation_template(\n            request.conversation\n        )\n        response: str | None = None\n        num_token_generated: int | None = None\n        for response, num_token_generated in self.sample(\n                string=prompt,\n                max_new_tokens=request.max_new_tokens or self.serve_config.max_new_tokens,\n                greedy=request.greedy or self.serve_config.greedy\n        ):\n            ...\n        return {\n            \"response\": response,\n            \"num_token_generated\": num_token_generated,\n            \"greedy\": request.greedy,\n            \"model_prompt\": prompt\n        }\n\n    @staticmethod\n    def create_shard_and_gather_functions(\n            parameters: dict,\n            partition_rules: Tuple[Tuple[str, PartitionSpec]],\n            dtype: jax.numpy.dtype | str = \"fp16\"\n    ):\n        partition_specs = match_partition_rules(partition_rules, parameters)\n        shard_fns, gather_fns = make_shard_and_gather_fns(\n            partition_specs=partition_specs,\n            dtype_specs=get_dtype(dtype)\n        )\n        return shard_fns, gather_fns, partition_specs\n\n    @staticmethod\n    def shard_parameters(\n            mesh: Mesh,\n            params: FrozenDict | dict,\n            partition_rules: Tuple[Tuple[str, PartitionSpec]],\n            serve_config: EasyServeConfig,\n    ):\n\n        partition_specs = match_partition_rules(params=params, rules=partition_rules)\n        shard_fns, _ = make_shard_and_gather_fns(partition_specs, get_dtype(serve_config.dtype))\n\n        with mesh:\n            params = jax.tree_map(\n                lambda func, param: func(param), shard_fns, params\n            )\n\n        return params\n\n    @staticmethod\n    def create_generation_functions_and_tokenizers(\n            model: EasyDelFlaxPretrainedModel,\n            tokenizer: PreTrainedTokenizerBase,\n            serve_config: EasyServeConfig,\n            partition_specs: dict[str, PartitionSpec]\n    ) -&gt; LLMBaseReq:\n\n        if tokenizer.pad_token is None:\n            logging.info(\n                \"Tokenizer does not contain padding token setting padding token to eos token for open end generation\")\n            tokenizer.pad_token = tokenizer.eos_token\n\n        try:\n            tokenizer.padding_side = \"left\"\n            tokenizer.truncation_side = \"left\"\n            prefix_tokenizer = copy.deepcopy(tokenizer)\n            tokenizer.padding_side = \"right\"\n            tokenizer.truncation_side = \"right\"\n            tokenizer = copy.deepcopy(tokenizer)\n\n        except:\n            warnings.warn(\n                f\"The class Model of Tokenizer {type(tokenizer)} do not support deepcopy option \"\n            )\n            if serve_config.use_prefix_tokenizer:\n                tokenizer.padding_side = \"left\"\n                tokenizer.truncation_side = \"left\"\n            else:\n                tokenizer.padding_side = \"right\"\n                tokenizer.truncation_side = \"right\"\n            prefix_tokenizer = tokenizer\n\n        @functools.partial(\n            pjit,\n            in_shardings=(partition_specs, PartitionSpec(), PartitionSpec()),\n            out_shardings=(PartitionSpec())\n        )\n        def greedy_generate_function(\n                parameters,\n                input_ids,\n                attention_mask\n        ):\n            input_ids = with_sharding_constraint(input_ids, serve_config.generation_ps)\n            attention_mask = with_sharding_constraint(attention_mask, serve_config.generation_ps)\n            predict = model.generate(\n                input_ids,\n                attention_mask=attention_mask,\n                params=parameters,\n                generation_config=GenerationConfig(\n                    max_new_tokens=serve_config.max_compile_tokens,\n                    eos_token_id=tokenizer.eos_token_id,\n                    pad_token_id=tokenizer.pad_token_id,\n                    bos_token_id=tokenizer.bos_token_id,\n\n                    do_sample=False,\n                    num_beams=1,\n                )\n            ).sequences[:, input_ids.shape[1]:]\n            return predict\n\n        @functools.partial(\n            pjit,\n            in_shardings=(partition_specs, PartitionSpec(), PartitionSpec()),\n            out_shardings=(PartitionSpec())\n        )\n        def non_greedy_generate_function(\n                parameters,\n                input_ids,\n                attention_mask\n        ):\n            input_ids = with_sharding_constraint(input_ids, serve_config.generation_ps)\n            attention_mask = with_sharding_constraint(attention_mask, serve_config.generation_ps)\n            predict = model.generate(\n                input_ids,\n                attention_mask=attention_mask,\n                params=parameters,\n                generation_config=GenerationConfig(\n                    max_new_tokens=serve_config.max_compile_tokens,\n\n                    eos_token_id=tokenizer.eos_token_id,\n                    pad_token_id=tokenizer.pad_token_id,\n                    bos_token_id=tokenizer.bos_token_id,\n\n                    temperature=serve_config.temperature,\n                    do_sample=True,\n                    num_beams=1,\n                    top_p=serve_config.top_p,\n                    top_k=serve_config.top_k,\n                )\n            ).sequences[:, input_ids.shape[1]:]\n            return predict\n\n        return LLMBaseReq(\n            greedy_generate_function=greedy_generate_function,\n            non_greedy_generate_function=non_greedy_generate_function,\n            tokenizer=tokenizer,\n            prefix_tokenizer=prefix_tokenizer\n        )\n\n    @classmethod\n    def from_parameters(\n            cls,\n            llm: EasyDelFlaxPretrainedModel,\n            params: dict,\n            tokenizer: PreTrainedTokenizerBase,\n            serve_config: EasyServeConfig,\n            partition_rules: Tuple[Tuple[str, PartitionSpec]],\n            shard_parameters: bool = True,\n    ):\n        shard_fns, gather_fns, partition_specs = cls.create_shard_and_gather_functions(\n            parameters=params,\n            partition_rules=partition_rules,\n            dtype=serve_config.dtype\n        )\n        llm_base_req = cls.create_generation_functions_and_tokenizers(\n            model=llm,\n            tokenizer=tokenizer,\n            partition_specs=partition_specs,\n            serve_config=serve_config\n        )\n\n        if shard_parameters:\n            params = cls.shard_parameters(\n                params=params,\n                partition_rules=partition_rules,\n                serve_config=serve_config,\n                mesh=llm.config.jax_mesh()\n            )\n\n        return cls(\n            llm=llm,\n            serve_config=serve_config,\n            tokenizer=llm_base_req.tokenizer,\n            prefix_tokenizer=llm_base_req.prefix_tokenizer,\n            params=params,\n            greedy_generate_function=llm_base_req.greedy_generate_function,\n            non_greedy_generate_function=llm_base_req.non_greedy_generate_function,\n        )\n\n    def sample(\n            self,\n            string: str,\n            *,\n            greedy: bool = False,\n            max_new_tokens: int = None,\n            **kwargs\n    ):\n        \"\"\"\n        The process function is the main function of a model. It takes in an input string and returns a list of strings\n        that are generated from that input string. The process function can be called multiple times with different inputs,\n        and each time it will return a new set of outputs based on those inputs.\n\n        :param self: Access the class attributes\n        :param string: str: Pass the string that we want to generate\n        :param greedy: bool: Determine whether to use the greedy or non-greedy version of the generate function\n        :param max_new_tokens: int: Set the number of tokens to generate\n        :param kwargs: Pass any additional parameters to the process function\n        :return: A generator that yields the predicted text and the number of tokens generated\n\n        \"\"\"\n        with self.llm.config.jax_mesh():\n            fixed_pad = self.serve_config.max_sequence_length - self.serve_config.max_compile_tokens\n            tokens = self.prefix_tokenizer(\n                string,\n                max_length=fixed_pad,\n                padding=\"max_length\",\n                return_tensors=\"jax\"\n            ) \\\n                if self.serve_config.use_prefix_tokenizer else \\\n                self.tokenizer(\n                    string,\n                    return_tensors=\"jax\"\n                )\n\n            input_ids = tokens.input_ids\n            attention_mask = tokens.attention_mask\n            num_generated_tokens = 0\n\n            for _ in range(\n                    (max_new_tokens or self.serve_config.max_new_tokens) // self.serve_config.max_compile_tokens):\n\n                predicted_token = self.get_generation_function(greedy=greedy)(\n                    self.params,\n                    input_ids,\n                    attention_mask\n                )\n\n                num_generated_tokens += predicted_token.shape[-1]\n                plus_attn_mask = jnp.ones(\n                    (len(attention_mask), self.serve_config.max_compile_tokens),\n                    dtype=\"i4\"\n                )\n\n                input_ids = jnp.concatenate(\n                    (input_ids, predicted_token), dtype=\"i4\",\n                    axis=-1\n                )[:, -fixed_pad:]\n\n                attention_mask = jnp.concatenate(\n                    (attention_mask, plus_attn_mask), dtype=\"i4\",\n                    axis=-1\n                )[:, -fixed_pad:]\n\n                returns = (\n                    self.tokenizer.decode(input_ids[0][-num_generated_tokens:], skip_special_tokens=True),\n                    num_generated_tokens\n                )\n\n                yield returns\n                if (\n                        predicted_token[0][-1] == self.tokenizer.eos_token_id\n                        or\n                        predicted_token[0][-1] == self.prefix_tokenizer.eos_token_id\n                ):\n                    break\n\n    def compile(self, verbose: bool = True) -&gt; bool:\n        \"\"\"\n        The compile function is used to compile the model for use in inference.\n        It does this by running through all possible combinations of rules and actions,\n        and compiling them into functions that can be called later on during inference.\n        This allows us to avoid having to recompile the model every time we want to run it,\n        which would be very slow.\n\n        :param self: Represent the instance of the class\n        :param verbose: bool: Print out the compiling process\n        :return: True, but what does it do?\n        \"\"\"\n        if self.serve_config.use_prefix_tokenizer:\n            if verbose:\n                termcolor.cprint(\n                    \"Compiling Model Forwards Greedy/Non-Greedy(Generate)\",\n                    color=\"cyan\",\n                    force_color=True\n                )\n                termcolor.cprint(\n                    \"Compiling Greedy Functions\",\n                    color=\"cyan\",\n                    force_color=True\n                )\n\n            response, tokens = [None] * 2\n            for response, tokens in self.sample(\n                    string=\"\",\n                    max_new_tokens=self.serve_config.max_compile_tokens,\n                    greedy=True\n            ):\n                ...\n            if verbose:\n                termcolor.cprint(\n                    \"Compiling Non-Greedy(Generate) Functions\",\n                    color=\"cyan\",\n                    force_color=True\n                )\n            for response, tokens in self.sample(\n                    string=\"\",\n                    max_new_tokens=self.serve_config.max_compile_tokens,\n                    greedy=False\n            ):\n                ...\n\n        else:\n            termcolor.cprint(\n                \"Skip Compiling the compiling process is useless \"\n                \"when you are not using prefix tokenizer\",\n                color=\"red\", force_color=True\n            )\n        return True\n\n    def __repr__(self):\n\n        \"\"\"\n        The __repr__ function is used to generate a string representation of an object.\n        This function should return a string that can be parsed by the Python interpreter\n        to recreate the object. The __repr__ function is called when you use print() on an\n        object, or when you type its name in the REPL.\n\n        :param self: Refer to the instance of the class\n        :return: A string representation of the object\n        \"\"\"\n        string = f\"{self.__class__.__name__}(\\n\"\n        for k, v in self.__dict__.items():\n            if not k.startswith(\"_\"):\n                repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n                string += repr_src if len(repr_src) &lt; 500 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n        return string + \")\"\n\n    def __str__(self):\n\n        \"\"\"\n        The __str__ function is called when you use the print function or when str() is used.\n        It should return a string representation of the object.\n\n        :param self: Refer to the instance of the class\n        :return: The object's string representation\n        \"\"\"\n        return self.__repr__()\n\n    def fire(self):\n        uvicorn.run(\n            self.fast_api,\n            host=self.serve_config.host,\n            port=self.serve_config.port,\n        )\n</code></pre>"},{"location":"generated-serve-api-serve/#lib.python.EasyDel.serve.api.serve.EasyServe.__repr__","title":"<code>__repr__()</code>","text":"<p>The repr function is used to generate a string representation of an object. This function should return a string that can be parsed by the Python interpreter to recreate the object. The repr function is called when you use print() on an object, or when you type its name in the REPL.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>A string representation of the object</p> Source code in <code>lib/python/EasyDel/serve/api/serve.py</code> <pre><code>def __repr__(self):\n\n    \"\"\"\n    The __repr__ function is used to generate a string representation of an object.\n    This function should return a string that can be parsed by the Python interpreter\n    to recreate the object. The __repr__ function is called when you use print() on an\n    object, or when you type its name in the REPL.\n\n    :param self: Refer to the instance of the class\n    :return: A string representation of the object\n    \"\"\"\n    string = f\"{self.__class__.__name__}(\\n\"\n    for k, v in self.__dict__.items():\n        if not k.startswith(\"_\"):\n            repr_src = f\"\\t{k} : \" + v.__str__().replace(\"\\n\", \"\\n\\t\") + \"\\n\"\n            string += repr_src if len(repr_src) &lt; 500 else f\"\\t{k} : \" + f\"{v.__class__.__name__}(...)\" + \"\\n\"\n    return string + \")\"\n</code></pre>"},{"location":"generated-serve-api-serve/#lib.python.EasyDel.serve.api.serve.EasyServe.__str__","title":"<code>__str__()</code>","text":"<p>The str function is called when you use the print function or when str() is used. It should return a string representation of the object.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>The object's string representation</p> Source code in <code>lib/python/EasyDel/serve/api/serve.py</code> <pre><code>def __str__(self):\n\n    \"\"\"\n    The __str__ function is called when you use the print function or when str() is used.\n    It should return a string representation of the object.\n\n    :param self: Refer to the instance of the class\n    :return: The object's string representation\n    \"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"generated-serve-api-serve/#lib.python.EasyDel.serve.api.serve.EasyServe.compile","title":"<code>compile(verbose=True)</code>","text":"<p>The compile function is used to compile the model for use in inference. It does this by running through all possible combinations of rules and actions, and compiling them into functions that can be called later on during inference. This allows us to avoid having to recompile the model every time we want to run it, which would be very slow.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>verbose</code> <code>bool</code> <p>bool: Print out the compiling process</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True, but what does it do?</p> Source code in <code>lib/python/EasyDel/serve/api/serve.py</code> <pre><code>def compile(self, verbose: bool = True) -&gt; bool:\n    \"\"\"\n    The compile function is used to compile the model for use in inference.\n    It does this by running through all possible combinations of rules and actions,\n    and compiling them into functions that can be called later on during inference.\n    This allows us to avoid having to recompile the model every time we want to run it,\n    which would be very slow.\n\n    :param self: Represent the instance of the class\n    :param verbose: bool: Print out the compiling process\n    :return: True, but what does it do?\n    \"\"\"\n    if self.serve_config.use_prefix_tokenizer:\n        if verbose:\n            termcolor.cprint(\n                \"Compiling Model Forwards Greedy/Non-Greedy(Generate)\",\n                color=\"cyan\",\n                force_color=True\n            )\n            termcolor.cprint(\n                \"Compiling Greedy Functions\",\n                color=\"cyan\",\n                force_color=True\n            )\n\n        response, tokens = [None] * 2\n        for response, tokens in self.sample(\n                string=\"\",\n                max_new_tokens=self.serve_config.max_compile_tokens,\n                greedy=True\n        ):\n            ...\n        if verbose:\n            termcolor.cprint(\n                \"Compiling Non-Greedy(Generate) Functions\",\n                color=\"cyan\",\n                force_color=True\n            )\n        for response, tokens in self.sample(\n                string=\"\",\n                max_new_tokens=self.serve_config.max_compile_tokens,\n                greedy=False\n        ):\n            ...\n\n    else:\n        termcolor.cprint(\n            \"Skip Compiling the compiling process is useless \"\n            \"when you are not using prefix tokenizer\",\n            color=\"red\", force_color=True\n        )\n    return True\n</code></pre>"},{"location":"generated-serve-api-serve/#lib.python.EasyDel.serve.api.serve.EasyServe.sample","title":"<code>sample(string, *, greedy=False, max_new_tokens=None, **kwargs)</code>","text":"<p>The process function is the main function of a model. It takes in an input string and returns a list of strings that are generated from that input string. The process function can be called multiple times with different inputs, and each time it will return a new set of outputs based on those inputs.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the class attributes</p> required <code>string</code> <code>str</code> <p>str: Pass the string that we want to generate</p> required <code>greedy</code> <code>bool</code> <p>bool: Determine whether to use the greedy or non-greedy version of the generate function</p> <code>False</code> <code>max_new_tokens</code> <code>int</code> <p>int: Set the number of tokens to generate</p> <code>None</code> <code>kwargs</code> <p>Pass any additional parameters to the process function</p> <code>{}</code> <p>Returns:</p> Type Description <p>A generator that yields the predicted text and the number of tokens generated</p> Source code in <code>lib/python/EasyDel/serve/api/serve.py</code> <pre><code>def sample(\n        self,\n        string: str,\n        *,\n        greedy: bool = False,\n        max_new_tokens: int = None,\n        **kwargs\n):\n    \"\"\"\n    The process function is the main function of a model. It takes in an input string and returns a list of strings\n    that are generated from that input string. The process function can be called multiple times with different inputs,\n    and each time it will return a new set of outputs based on those inputs.\n\n    :param self: Access the class attributes\n    :param string: str: Pass the string that we want to generate\n    :param greedy: bool: Determine whether to use the greedy or non-greedy version of the generate function\n    :param max_new_tokens: int: Set the number of tokens to generate\n    :param kwargs: Pass any additional parameters to the process function\n    :return: A generator that yields the predicted text and the number of tokens generated\n\n    \"\"\"\n    with self.llm.config.jax_mesh():\n        fixed_pad = self.serve_config.max_sequence_length - self.serve_config.max_compile_tokens\n        tokens = self.prefix_tokenizer(\n            string,\n            max_length=fixed_pad,\n            padding=\"max_length\",\n            return_tensors=\"jax\"\n        ) \\\n            if self.serve_config.use_prefix_tokenizer else \\\n            self.tokenizer(\n                string,\n                return_tensors=\"jax\"\n            )\n\n        input_ids = tokens.input_ids\n        attention_mask = tokens.attention_mask\n        num_generated_tokens = 0\n\n        for _ in range(\n                (max_new_tokens or self.serve_config.max_new_tokens) // self.serve_config.max_compile_tokens):\n\n            predicted_token = self.get_generation_function(greedy=greedy)(\n                self.params,\n                input_ids,\n                attention_mask\n            )\n\n            num_generated_tokens += predicted_token.shape[-1]\n            plus_attn_mask = jnp.ones(\n                (len(attention_mask), self.serve_config.max_compile_tokens),\n                dtype=\"i4\"\n            )\n\n            input_ids = jnp.concatenate(\n                (input_ids, predicted_token), dtype=\"i4\",\n                axis=-1\n            )[:, -fixed_pad:]\n\n            attention_mask = jnp.concatenate(\n                (attention_mask, plus_attn_mask), dtype=\"i4\",\n                axis=-1\n            )[:, -fixed_pad:]\n\n            returns = (\n                self.tokenizer.decode(input_ids[0][-num_generated_tokens:], skip_special_tokens=True),\n                num_generated_tokens\n            )\n\n            yield returns\n            if (\n                    predicted_token[0][-1] == self.tokenizer.eos_token_id\n                    or\n                    predicted_token[0][-1] == self.prefix_tokenizer.eos_token_id\n            ):\n                break\n</code></pre>"},{"location":"generated-serve-gradio_user_interface_base/","title":"serve.gradio_user_interface_base","text":""},{"location":"generated-serve-gradio_user_interface_base/#lib.python.EasyDel.serve.gradio_user_interface_base.GradioUserInference","title":"<code>GradioUserInference</code>","text":"Source code in <code>lib/python/EasyDel/serve/gradio_user_interface_base.py</code> <pre><code>class GradioUserInference:\n    @staticmethod\n    def chat_interface_components(\n            sample_func: typing.Callable,\n            max_sequence_length: int,\n            max_new_tokens: int,\n            max_compile_tokens: int\n    ):\n        \"\"\"\n        The function `chat_interface_components` creates the components for a chat interface, including\n        a chat history, message box, buttons for submitting, stopping, and clearing the conversation,\n        and sliders for advanced options.\n        \"\"\"\n\n        _max_length = max_sequence_length\n        _max_new_tokens = max_new_tokens\n        _max_compile_tokens = max_compile_tokens\n\n        with gr.Column(\"100%\"):\n            gr.Markdown(\n                \"# &lt;h1&gt;&lt;center style='color:white;'&gt;Powered by \"\n                \"[EasyDeL](https://github.com/erfanzar/EasyDel)&lt;/center&gt;&lt;/h1&gt;\",\n            )\n            history = gr.Chatbot(\n                elem_id=\"EasyDel\",\n                label=\"EasyDel\",\n                container=True,\n                height=\"65vh\",\n            )\n            prompt = gr.Textbox(\n                show_label=False, placeholder='Enter Your Prompt Here.', container=False\n            )\n            with gr.Row():\n                submit = gr.Button(\n                    value=\"Run\",\n                    variant=\"primary\"\n                )\n                stop = gr.Button(\n                    value='Stop'\n                )\n                clear = gr.Button(\n                    value='Clear Conversation'\n                )\n            with gr.Accordion(open=False, label=\"Advanced Options\"):\n                system_prompt = gr.Textbox(\n                    value=\"\",\n                    show_label=False,\n                    label=\"System Prompt\",\n                    placeholder='System Prompt',\n                    container=False\n                )\n\n                max_sequence_length = gr.Slider(\n                    value=_max_length,\n                    maximum=10000,\n                    minimum=1,\n                    label='Max Tokens',\n                    step=1\n                )\n\n                max_new_tokens = gr.Slider(\n                    value=_max_new_tokens,\n                    maximum=10000,\n                    minimum=_max_compile_tokens,\n                    label='Max New Tokens',\n                    step=_max_compile_tokens\n                )\n\n                max_compile_tokens = gr.Slider(\n                    value=_max_compile_tokens,\n                    maximum=_max_compile_tokens,\n                    minimum=_max_compile_tokens,\n                    label='Max Compile Tokens',\n                    step=_max_compile_tokens\n                )\n\n                temperature = gr.Slider(\n                    value=0.8,\n                    maximum=1,\n                    minimum=0.1,\n                    label='Temperature',\n                    step=0.01\n                )\n                top_p = gr.Slider(\n                    value=0.9,\n                    maximum=1,\n                    minimum=0.1,\n                    label='Top P',\n                    step=0.01\n                )\n                top_k = gr.Slider(\n                    value=50,\n                    maximum=100,\n                    minimum=1,\n                    label='Top K',\n                    step=1\n                )\n\n                greedy = gr.Radio(\n                    value=True,\n                    label=\"Do Sample or Greedy Generation\"\n                )\n\n                mode = gr.Dropdown(\n                    choices=[\"Chat\", \"Instruct\"],\n                    value=\"Chat\",\n                    label=\"Mode\",\n                    multiselect=False\n                )\n\n        inputs = [\n            prompt,\n            history,\n            system_prompt,\n            mode,\n            max_length,\n            max_new_tokens,\n            max_compile_tokens,\n            greedy,\n            temperature,\n            top_p,\n            top_k\n        ]\n\n        clear.click(fn=lambda: [], outputs=[history])\n        sub_event = submit.click(\n            fn=sample_func, inputs=inputs, outputs=[prompt, history]\n        )\n        txt_event = prompt.submit(\n            fn=sample_func, inputs=inputs, outputs=[prompt, history]\n        )\n        stop.click(\n            fn=None,\n            inputs=None,\n            outputs=None,\n            cancels=[txt_event, sub_event]\n        )\n\n    def process_gradio(\n            self,\n            prompt: str,\n            history: List[List[str]],\n            system_prompt: str | None,\n            mode: str,\n            max_length: int,\n            max_new_tokens: int,\n            max_compile_tokens: int,\n            greedy: bool,\n            temperature: float,\n            top_p: float,\n            top_k: int\n    ):\n        raise NotImplementedError()\n\n    def build_inference(\n            self,\n            sample_func: typing.Callable,\n            max_length: int,\n            max_new_tokens: int,\n            max_compile_tokens: int\n    ) -&gt; gr.Blocks:\n        \"\"\"\n        The function \"build_inference\" returns a gr.Blocks object that model\n        interface components.\n        :return: a gr.Blocks object.\n        \"\"\"\n        with gr.Blocks(\n                theme=seafoam\n        ) as block:\n            self.chat_interface_components(\n                sample_func=sample_func,\n                max_length=max_length,\n                max_new_tokens=max_new_tokens,\n                max_compile_tokens=max_compile_tokens\n            )\n        return block\n</code></pre>"},{"location":"generated-serve-gradio_user_interface_base/#lib.python.EasyDel.serve.gradio_user_interface_base.GradioUserInference.build_inference","title":"<code>build_inference(sample_func, max_length, max_new_tokens, max_compile_tokens)</code>","text":"<p>The function \"build_inference\" returns a gr.Blocks object that model interface components.</p> <p>Returns:</p> Type Description <code>Blocks</code> <p>a gr.Blocks object.</p> Source code in <code>lib/python/EasyDel/serve/gradio_user_interface_base.py</code> <pre><code>def build_inference(\n        self,\n        sample_func: typing.Callable,\n        max_length: int,\n        max_new_tokens: int,\n        max_compile_tokens: int\n) -&gt; gr.Blocks:\n    \"\"\"\n    The function \"build_inference\" returns a gr.Blocks object that model\n    interface components.\n    :return: a gr.Blocks object.\n    \"\"\"\n    with gr.Blocks(\n            theme=seafoam\n    ) as block:\n        self.chat_interface_components(\n            sample_func=sample_func,\n            max_length=max_length,\n            max_new_tokens=max_new_tokens,\n            max_compile_tokens=max_compile_tokens\n        )\n    return block\n</code></pre>"},{"location":"generated-serve-gradio_user_interface_base/#lib.python.EasyDel.serve.gradio_user_interface_base.GradioUserInference.chat_interface_components","title":"<code>chat_interface_components(sample_func, max_sequence_length, max_new_tokens, max_compile_tokens)</code>  <code>staticmethod</code>","text":"<p>The function <code>chat_interface_components</code> creates the components for a chat interface, including a chat history, message box, buttons for submitting, stopping, and clearing the conversation, and sliders for advanced options.</p> Source code in <code>lib/python/EasyDel/serve/gradio_user_interface_base.py</code> <pre><code>@staticmethod\ndef chat_interface_components(\n        sample_func: typing.Callable,\n        max_sequence_length: int,\n        max_new_tokens: int,\n        max_compile_tokens: int\n):\n    \"\"\"\n    The function `chat_interface_components` creates the components for a chat interface, including\n    a chat history, message box, buttons for submitting, stopping, and clearing the conversation,\n    and sliders for advanced options.\n    \"\"\"\n\n    _max_length = max_sequence_length\n    _max_new_tokens = max_new_tokens\n    _max_compile_tokens = max_compile_tokens\n\n    with gr.Column(\"100%\"):\n        gr.Markdown(\n            \"# &lt;h1&gt;&lt;center style='color:white;'&gt;Powered by \"\n            \"[EasyDeL](https://github.com/erfanzar/EasyDel)&lt;/center&gt;&lt;/h1&gt;\",\n        )\n        history = gr.Chatbot(\n            elem_id=\"EasyDel\",\n            label=\"EasyDel\",\n            container=True,\n            height=\"65vh\",\n        )\n        prompt = gr.Textbox(\n            show_label=False, placeholder='Enter Your Prompt Here.', container=False\n        )\n        with gr.Row():\n            submit = gr.Button(\n                value=\"Run\",\n                variant=\"primary\"\n            )\n            stop = gr.Button(\n                value='Stop'\n            )\n            clear = gr.Button(\n                value='Clear Conversation'\n            )\n        with gr.Accordion(open=False, label=\"Advanced Options\"):\n            system_prompt = gr.Textbox(\n                value=\"\",\n                show_label=False,\n                label=\"System Prompt\",\n                placeholder='System Prompt',\n                container=False\n            )\n\n            max_sequence_length = gr.Slider(\n                value=_max_length,\n                maximum=10000,\n                minimum=1,\n                label='Max Tokens',\n                step=1\n            )\n\n            max_new_tokens = gr.Slider(\n                value=_max_new_tokens,\n                maximum=10000,\n                minimum=_max_compile_tokens,\n                label='Max New Tokens',\n                step=_max_compile_tokens\n            )\n\n            max_compile_tokens = gr.Slider(\n                value=_max_compile_tokens,\n                maximum=_max_compile_tokens,\n                minimum=_max_compile_tokens,\n                label='Max Compile Tokens',\n                step=_max_compile_tokens\n            )\n\n            temperature = gr.Slider(\n                value=0.8,\n                maximum=1,\n                minimum=0.1,\n                label='Temperature',\n                step=0.01\n            )\n            top_p = gr.Slider(\n                value=0.9,\n                maximum=1,\n                minimum=0.1,\n                label='Top P',\n                step=0.01\n            )\n            top_k = gr.Slider(\n                value=50,\n                maximum=100,\n                minimum=1,\n                label='Top K',\n                step=1\n            )\n\n            greedy = gr.Radio(\n                value=True,\n                label=\"Do Sample or Greedy Generation\"\n            )\n\n            mode = gr.Dropdown(\n                choices=[\"Chat\", \"Instruct\"],\n                value=\"Chat\",\n                label=\"Mode\",\n                multiselect=False\n            )\n\n    inputs = [\n        prompt,\n        history,\n        system_prompt,\n        mode,\n        max_length,\n        max_new_tokens,\n        max_compile_tokens,\n        greedy,\n        temperature,\n        top_p,\n        top_k\n    ]\n\n    clear.click(fn=lambda: [], outputs=[history])\n    sub_event = submit.click(\n        fn=sample_func, inputs=inputs, outputs=[prompt, history]\n    )\n    txt_event = prompt.submit(\n        fn=sample_func, inputs=inputs, outputs=[prompt, history]\n    )\n    stop.click(\n        fn=None,\n        inputs=None,\n        outputs=None,\n        cancels=[txt_event, sub_event]\n    )\n</code></pre>"},{"location":"generated-serve-jax_serve/","title":"serve.jax_serve","text":""},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer","title":"<code>JAXServer</code>","text":"<p>             Bases: <code>GradioUserInference</code></p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>class JAXServer(GradioUserInference):\n\n    def __init__(self, config=None):\n\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up all the attributes that will be used by other methods in the class.\n\n\n        :param self: Refer to the current instance of a class\n        :param config: Pass the JAXServerConfig object\n        :return: A fastapi object\n\n        \"\"\"\n        (\n            self.process_uvicorn,\n            self.prefix_tokenizer,\n            self.params,\n            self.tokenizer,\n            self.model,\n            self.partition_specs,\n            self.generate_function,\n            self.greedy_generate_function\n        ) = [None] * 8\n        assert config is None or isinstance(config, JAXServerConfig), \"config can be None or JAXServerConfig Type\"\n        if config is None:\n            config = JAXServerConfig()\n\n        self.config = config\n        self._funcs_generated = False\n        self.number_of_served_request_until_last_up_time = 0\n\n        self.rng_generator = RNG(42)\n        initialise_tracking(0.5)\n        array = jnp.ones((len(jax.devices()), 1)).reshape(self.config.mesh_axes_shape)\n        self.mesh = Mesh(mesh_utils.create_device_mesh(array.shape), self.config.mesh_axes_names)\n\n        self.app = FastAPI()\n        self.app.post(\"/chat\")(self.forward_chat)\n        self.app.post(\"/instruct\")(self.forward_instruct)\n        self.app.get(\"/status\")(self.status)\n        self.app = gr.mount_gradio_app(self.app, self.gradio_inference(), \"/gradio_chat\")\n\n    def status(self):\n        \"\"\"\n        The status function returns a dictionary with the following keys:\n            config: A dictionary containing all the configuration parameters for this server.\n            devices: A string describing which devices are available to JAX.\n            number_of_backends: The number of backends available to JAX.  This is usually equal to the number of GPUs\n            on your machine, but can be less if you have not installed CUDA or if you have disabled some GPUs in your\n             system BIOS settings (e.g., because they are defective).  It can also be more than one if you have multiple\n              machines connected via MPI and running under Horov\n\n        :param self: Represent the instance of the class\n        :return: A dictionary with the following keys:\n\n        \"\"\"\n        return {\n            \"config\": {k: v for k, v in self.config.__dict__.items()},\n            \"devices\": f\"{jax.devices()}\",\n            \"number_of_backends\": len(jax.devices()),\n            \"status\": \"Ready\",\n            \"number_of_served_request_until_last_up_time\": f\"{self.number_of_served_request_until_last_up_time}\",\n            \"memory\": f\"{get_mem()}\"\n        }\n\n    @staticmethod\n    def get_memory():\n        \"\"\"\n        The get_memory function returns the total memory of the system in bytes.\n\n\n        :return: The amount of memory used by the program\n\n        \"\"\"\n        return get_mem()\n\n    def configure_generate_functions(self, model, tokenizer):\n\n        \"\"\"\n        The configure_generate_functions function is used to configure the generation functions for a given model.\n\n        :param self: Access variables within the class\n        :param model: Generate the model\n        :param tokenizer: Get the eos_token_id, pad_token_id and bos token id\n        :return: A function that takes in three parameters:\n\n        \"\"\"\n        assert self.partition_specs is not None, \"you should first shard params with using ``shard_params`` method\"\n\n        if tokenizer.pad_token is None:\n            logging.info(\n                \"Tokenizer does not contain padding token setting padding token to eos token for open end generation\")\n            tokenizer.pad_token = tokenizer.eos_token\n\n        try:\n            tokenizer.padding_side = \"left\"\n            tokenizer.truncation_side = \"left\"\n            self.prefix_tokenizer = copy.deepcopy(tokenizer)\n            tokenizer.padding_side = \"right\"\n            tokenizer.truncation_side = \"right\"\n            self.tokenizer = copy.deepcopy(tokenizer)\n        except:\n            prefix_print(\n                \"Warning\", f\"The class Model of Tokenizer {type(tokenizer)} do not support deepcopy option \"\n            )\n            if self.config.use_prefix_tokenizer:\n                tokenizer.padding_side = \"left\"\n                tokenizer.truncation_side = \"left\"\n            else:\n                tokenizer.padding_side = \"right\"\n                tokenizer.truncation_side = \"right\"\n            self.prefix_tokenizer = tokenizer\n\n        @functools.partial(\n            pjit,\n            in_shardings=(self.partition_specs, Ps(), Ps()),\n            out_shardings=(Ps())\n        )\n        def greedy_generate(parameters, input_ids, attention_mask):\n            input_ids = with_sharding_constraint(input_ids, self.config.generation_ps)\n            attention_mask = with_sharding_constraint(attention_mask, self.config.generation_ps)\n            predict = model.generate(\n                input_ids,\n                attention_mask=attention_mask,\n                params=parameters,\n                generation_config=GenerationConfig(\n                    max_new_tokens=self.config.max_compile_tokens,\n                    eos_token_id=tokenizer.eos_token_id,\n                    pad_token_id=tokenizer.pad_token_id,\n                    bos_token_id=tokenizer.bos_token_id,\n\n                    do_sample=False,\n                    num_beams=1,\n                )\n            ).sequences[:, input_ids.shape[1]:]\n            return predict\n\n        @functools.partial(\n            pjit,\n            in_shardings=(self.partition_specs, Ps(), Ps()),\n            out_shardings=(Ps())\n        )\n        def generate(parameters, input_ids, attention_mask):\n            input_ids = with_sharding_constraint(input_ids, self.config.generation_ps)\n            attention_mask = with_sharding_constraint(attention_mask, self.config.generation_ps)\n            predict = model.generate(\n                input_ids,\n                attention_mask=attention_mask,\n                params=parameters,\n                generation_config=GenerationConfig(\n                    max_new_tokens=self.config.max_compile_tokens,\n\n                    eos_token_id=tokenizer.eos_token_id,\n                    pad_token_id=tokenizer.pad_token_id,\n                    bos_token_id=tokenizer.bos_token_id,\n\n                    temperature=self.config.temperature,\n                    do_sample=True,\n                    num_beams=1,\n                    top_p=self.config.top_p,\n                    top_k=self.config.top_k,\n                )\n            ).sequences[:, input_ids.shape[1]:]\n            return predict\n\n        self.generate_function = generate\n        self.greedy_generate_function = greedy_generate\n        self._funcs_generated = True\n\n    def auto_configure(self, model, params, tokenizer, partition_rules):\n        \"\"\"\n        The auto_configure function is a helper function that will automatically configure the model for distributed training.\n        It does this by:\n            1) sharding the parameters of the model based on partition_rules, and then\n            2) configuring generate functions to be used in distributed training.\n\n        :param self: Represent the instance of the class\n        :param model: Configure the model\n        :param params: Store the parameters that are used to configure the model\n        :param tokenizer: Tokenize the input text\n        :param partition_rules: Specify how the parameters should be partitioned\n        :return: A dictionary with the following keys:\n\n        \"\"\"\n        self.shard_params(params=params, partition_rules=partition_rules)\n        self.configure_generate_functions(model, tokenizer)\n\n    def generate(\n            self,\n            params: Union[flax.core.FrozenDict, dict],\n            input_ids: chex.Array,\n            attention_mask: chex.Array,\n    ):\n        \"\"\"\n        The generate function is used to generate a sequence of tokens from the model.\n\n        :param self: Access variables that belong to the class\n        :param params: Union[flax.core.FrozenDict, dict]: Pass the parameters of the model to be used in generating text\n        :param input_ids: chex.Array: Pass the input to the model\n        :param attention_mask: chex.Array: Mask the padding tokens\n        :return: The logits of the model\n\n        \"\"\"\n        if not self._funcs_generated:\n            raise NotImplementedError(\n                \"this method will be implemented automatically after using ``configure_generate_functions`` function\"\n            )\n        else:\n            with self.mesh:\n                return self.generate_function(\n                    params, input_ids, attention_mask\n                )\n\n    @classmethod\n    def load(\n            cls,\n            model: transformers.FlaxPreTrainedModel,\n            config_model: transformers.PretrainedConfig,\n            tokenizer: transformers.PreTrainedTokenizer,\n            path: Union[str, os.PathLike],\n            config=None,\n            add_params_field: bool = True,\n            init_shape: tuple = (1, 1),\n            do_memory_log: bool = False,\n            verbose: bool = True\n    ):\n        \"\"\"\n        The load function is used to load a pretrained model from disk.\n\n        :param cls: Refer to the class itself\n        :param model: transformers.FlaxPreTrainedModel: Initialize the server\n        :param config_model: transformers.PretrainedConfig: Get the partition rules\n        :param tokenizer: transformers.PreTrainedTokenizer: Load the tokenizer from the model\n        :param path: Union[str, os.PathLike]: Specify the path to the checkpoint file\n        :param config: Configure the server\n        :param add_params_field: bool: Add a params field to the server\n        :param init_shape: tuple: Specify the shape of the input to be used for generating shard_fns\n        :param do_memory_log: bool: Log the memory usage of the server\n        :param verbose: bool: Print the compilation process\n        :return: A server\n\n        \"\"\"\n        assert hasattr(model,\n                       \"init_weights\"), \"model must contain init_weights func in order to init params for shard_fns\"\n        assert hasattr(config_model,\n                       \"get_partition_rules\"), \"config_model must contain get_partition_rules functions\"\n        server = cls(config=config)\n        logging.info(\n            \"running _init() func in order to make shard_fns\"\n        )\n        with jax.default_device(jax.devices(\"cpu\")[0]):\n            def _init():\n                return model.init_weights(jax.random.PRNGKey(0), init_shape)\n\n            shape = jax.eval_shape(_init)\n        logging.info(\n            \"matching partition rules\"\n        )\n        rules = match_partition_rules(params=shape, rules=config_model.get_partition_rules(True))\n\n        with server.mesh:\n            shard_fns, _ = make_shard_and_gather_fns(rules, get_dtype(server.config.dtype))\n            logging.info(\n                \"loading checkpoints\"\n            )\n\n            shard_fns = flax.traverse_util.flatten_dict(shard_fns)\n            server.params = {}\n            with open(path, \"rb\") as stream:\n                unpacker = msgpack.Unpacker(stream, read_size=83886080, max_buffer_size=0)\n                pbar = tqdm.tqdm(unpacker)\n                for key, value in pbar:\n                    key = tuple(key)\n                    tensor = from_bytes(None, value)\n                    tensor = shard_fns[key](tensor)\n                    server.params[key] = tensor\n                    if do_memory_log:\n                        pbar.write(server.get_memory())\n                    pbar.set_description(\"Sharding Params\")\n        server.params = flax.traverse_util.unflatten_dict(server.params)\n        server.params = {\"params\": server.params} if add_params_field else server.params\n\n        server.rules = {\"params\": rules} if add_params_field else rules\n        logging.info(\n            \"configuring generate functions for the server\"\n        )\n        server.configure_generate_functions(model, tokenizer)\n\n        if server.config.pre_compile:\n            server.compile(verbose=verbose)\n        return server\n\n    @classmethod\n    def from_torch_pretrained(\n            cls,\n            server_config: JAXServerConfig,\n            pretrained_model_name_or_path: str,\n            device=jax.devices('cpu')[0],\n            dtype: jax.numpy.dtype = jax.numpy.float32,\n            param_dtype: jax.numpy.dtype = jax.numpy.float32,\n            precision: Optional[jax.lax.Precision] = jax.lax.Precision(\"fastest\"),\n            sharding_axis_dims: Sequence[int] = (1, -1, 1, 1),\n            sharding_axis_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\"),\n            query_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\", None),\n            key_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\", None),\n            value_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\", None),\n            bias_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), None, None, None),\n            attention_partition_spec: jax.sharding.PartitionSpec = jax.sharding.PartitionSpec((\"dp\", \"fsdp\"), \"sp\", \"tp\", None),\n            use_shard_map: bool = False,\n            input_shape: Sequence[int] = (1, 1),\n            shard_fns: Optional[Mapping[tuple, Callable]] = None,\n            backend: Optional[str] = None,\n            add_params_field: bool = True,\n            do_memory_log: bool = False,\n            verbose: bool = True,\n            **kwargs\n    ):\n\n        model, params = AutoEasyDelModelForCausalLM.from_pretrained(\n            pretrained_model_name_or_path=pretrained_model_name_or_path,\n            device=device,\n            dtype=dtype,\n            param_dtype=param_dtype,\n            precision=precision,\n            sharding_axis_names=sharding_axis_names,\n            sharding_axis_dims=sharding_axis_dims,\n            query_partition_spec=query_partition_spec,\n            attention_partition_spec=attention_partition_spec,\n            value_partition_spec=value_partition_spec,\n            key_partition_spec=key_partition_spec,\n            bias_partition_spec=bias_partition_spec,\n            use_shard_map=use_shard_map,\n            shard_fns=shard_fns,\n            input_shape=input_shape,\n            backend=backend,\n            **kwargs\n        )\n\n        return cls.from_parameters(\n            model=model,\n            config_model=model.config,\n            tokenizer=transformers.AutoTokenizer.from_pretrained(pretrained_model_name_or_path),\n            params=params,\n            config=server_config,\n            verbose=verbose,\n            do_memory_log=do_memory_log,\n            add_params_field=add_params_field\n        )\n\n    @classmethod\n    def from_parameters(\n            cls,\n            model: transformers.FlaxPreTrainedModel,\n            config_model: transformers.PretrainedConfig,\n            tokenizer: transformers.PreTrainedTokenizer,\n            params: Dict,\n            config: JAXServerConfig = None,\n            add_params_field: bool = True,\n            do_memory_log: bool = False,\n            verbose: bool = True\n    ):\n        \"\"\"\n        The from_parameters function is used to load a model from the parameters of a pretrained model.\n        It takes in the following arguments:\n            - cls: The class of the server you are loading, this should be Server or TPU_Server depending on\n            what backend you want to use.\n            - model: A FlaxPreTrainedModel object that contains all of your models functions and parameters. This can\n             be found in transformers/flax_utils/models/*model*.py\n                where *model* is replaced with whatever transformer you are using (e.g., bert). You can also create\n                 your own custom\n\n        :param cls: Create a new instance of the class\n        :param model: transformers.FlaxPreTrainedModel: Load the model\n        :param config_model: transformers.PretrainedConfig: Get the partition rules\n        :param tokenizer: transformers.PreTrainedTokenizer: Tokenize the input text\n        :param params: Dict: Pass in the parameters of the model\n        :param config: Pass in the config file for the server\n        :param add_params_field: bool: Add a params field to the server\n        :param do_memory_log: bool: Log the memory usage of the server\n        :param verbose: bool: Print out the status of the compilation\n        :return: A server object\n\n        \"\"\"\n        assert hasattr(model, \"init_weights\"), (\n            \"model must contain init_weights func in order to init params for shard_fns\"\n        )\n        assert hasattr(config_model, \"get_partition_rules\"), (\n            \"config_model must contain get_partition_rules functions\"\n        )\n        server = cls(config=config)\n\n        with server.mesh:\n            logging.info(\n                \"matching partition rules\"\n            )\n            partition_specs = match_partition_rules(params=params, rules=config_model.get_partition_rules(True))\n            shard_fns, _ = make_shard_and_gather_fns(partition_specs, get_dtype(server.config.dtype))\n            logging.info(\n                \"sharding parameters across all of the chosen backend(tpu/gpu/cpu)s\"\n            )\n            params = flax.traverse_util.flatten_dict(params)\n            shard_fns = flax.traverse_util.flatten_dict(shard_fns)\n            pbar = tqdm.tqdm(params.keys())\n            for key in pbar:\n                key = tuple(key)\n                params[key] = shard_fns[key](params[key])\n                if do_memory_log:\n                    pbar.write(server.get_memory())\n                pbar.set_description(\"Sharding Params\")\n            server.params = flax.traverse_util.unflatten_dict(params)\n            server.params = {\"params\": server.params} if add_params_field else server.params\n        server.partition_specs = {\"params\": partition_specs} if add_params_field else partition_specs\n        logging.info(\n            \"configuring generate functions for the server\"\n        )\n        server.configure_generate_functions(model, tokenizer)\n        if server.config.pre_compile:\n            server.compile(verbose=verbose)\n        return server\n\n    def compile(self, verbose: bool = True) -&gt; bool:\n        \"\"\"\n        The compile function is used to compile the model for use in inference.\n        It does this by running through all possible combinations of rules and actions,\n        and compiling them into functions that can be called later on during inference.\n        This allows us to avoid having to recompile the model every time we want to run it,\n        which would be very slow.\n\n        :param self: Represent the instance of the class\n        :param verbose: bool: Print out the compiling process\n        :return: True, but what does it do?\n        \"\"\"\n        assert self._funcs_generated, \"funcs are not generated yet\"\n        assert self.partition_specs is not None, \"rules should not be None\"\n        if self.config.use_prefix_tokenizer:\n            if verbose:\n                termcolor.cprint(\n                    \"Compiling Model Forwards Greedy/Non-Greedy(Generate)\",\n                    color=\"cyan\",\n                    force_color=True\n                )\n                termcolor.cprint(\n                    \"Compiling Greedy Functions\",\n                    color=\"cyan\",\n                    force_color=True\n                )\n\n            r, a = [None] * 2\n            for r, a in self.process(\n                    string=\"\",\n                    max_new_tokens=self.config.max_compile_tokens,\n                    greedy=True\n            ):\n                ...\n            if verbose:\n                termcolor.cprint(\n                    \"Compiling Non-Greedy(Generate) Functions\",\n                    color=\"cyan\",\n                    force_color=True\n                )\n            for r, a in self.process(\n                    string=\"\",\n                    max_new_tokens=self.config.max_compile_tokens,\n                    greedy=False\n            ):\n                ...\n\n        else:\n            termcolor.cprint(\n                \"Skip Compiling the compiling process is useless \"\n                \"when you are not using prefix tokenizer\",\n                color=\"red\", force_color=True\n            )\n        return True\n\n    def greedy_generate(self,\n                        params: Union[flax.core.FrozenDict, dict],\n                        input_ids: chex.Array,\n                        attention_mask: chex.Array,\n                        ):\n        \"\"\"\n        The greedy_generate function is a helper function that takes in the model parameters, input_ids and attention_mask\n        and returns the generated tokens. It uses greedy search to generate tokens one at a time.\n\n\n        :param self: Refer to the object itself\n        :param params: Union[flax.core.FrozenDict, dict]: Pass the parameters to the model\n        :param input_ids: chex.Array: Pass in the input sequence\n        :param attention_mask: chex.Array: Mask the input tokens\n        :param : Specify the parameters of the model\n        :return:  generated_ids\n\n        \"\"\"\n        if not self._funcs_generated:\n            raise NotImplementedError(\n                \"this method will be implemented automatically after using ``configure_generate_functions`` function\"\n            )\n        else:\n            with self.mesh:\n                return self.greedy_generate_function(\n                    params, input_ids, attention_mask\n                )\n\n    def shard_params(self, params, partition_rules):\n\n        \"\"\"\n        The shard_params function takes in a set of parameters and a partition rule.\n        The partition rule is used to determine how the parameters should be sharded across devices.\n        For example, if we have two devices, one with 4GB of memory and another with 8GB of memory,\n        we may want to shard our model such that the device with more memory has more parameters on it.\n        This function returns an updated version of params where each parameter is now stored on its own device.\n\n        :param self: Bind the instance of the class to a method\n        :param params: Pass the parameters of the model to be sharded\n        :param partition_rules: Specify how the parameters should be partitioned\n        :return: The sharded parameters\n\n        \"\"\"\n        logging.log(\n            logging.INFO,\n            \"the parameters will be sharded and ba saved inside server you can access them by ``JAXServer.params``\")\n        rules = match_partition_rules(params=params, rules=partition_rules)\n        self.partition_specs = rules\n        shard_fns, _ = make_shard_and_gather_fns(rules, get_dtype(self.config.dtype))\n\n        with self.mesh:\n            self.params = jax.tree_map(\n                lambda f, p: f(p), shard_fns, params\n            )\n\n        return self.params\n\n    def forward_chat(self, data: ChatRequest):\n\n        \"\"\"\n        The forward_chat function is the main function of this class.\n        It takes in a ChatRequest object, which contains a prompt and history.\n        The prompt is the user\"s input to be processed by the chatbot, while history\n        is an array of previous inputs and outputs from both sides (user and bot).\n        The forward_chat function then formats these inputs into one string that can be processed by our model.\n        This formatted string is then passed through our process() method, which returns an output response as well as how many tokens were used to generate it.\n\n        :param self: Access the attributes and methods of the class\n        :param data: ChatRequest: Pass in the data from the request\n        :return: A dictionary with the following keys:\n\n        \"\"\"\n        if not self._funcs_generated:\n            return {\n                \"status\": \"down\"\n            }\n\n        string = self.format_chat(\n            prompt=data.prompt,\n            system=None,\n            history=data.history\n        )\n\n        response, used_tokens = [None] * 2\n        for response, used_tokens in self.process(\n                string=string,\n                greedy=data.greedy,\n                max_new_tokens=None\n        ):\n            ...\n        self.number_of_served_request_until_last_up_time += 1\n        return {\n            \"input\": f\"{string}\",\n            \"response\": response,\n            \"tokens_used\": used_tokens,\n        }\n\n    @staticmethod\n    def format_instruct(system: str, instruction: str) -&gt; str:\n        \"\"\"\n        Here you will get the system and instruction from user, and you can apply your prompting style\n        \"\"\"\n        raise NotImplementedError()\n\n    @staticmethod\n    def format_chat(history: List[List[str]], prompt: str, system: Union[str, None]) -&gt; str:\n        \"\"\"\n        Here you will get the system, prompt and history from user, and you can apply your prompting style\n        \"\"\"\n        raise NotImplementedError()\n\n    def forward_instruct(self, data: InstructRequest):\n        \"\"\"\n        The forward_instruct function is the main function of this class.\n        It takes in a InstructRequest object, which contains the system and instruction to be processed.\n        The function then formats the input string using format_instruct, and passes it into process().\n        process() returns a tuple containing (response, used_tokens). The response is returned as part of\n        the response dictionary. If no valid responses are found by process(), None will be returned instead.\n\n        :param self: Bind the method to the object\n        :param data: InstructRequest: Pass the system and instruction to the function\n        :return: A dictionary with three keys:\n\n        \"\"\"\n        if not self._funcs_generated:\n            return {\n                \"status\": \"down\"\n            }\n\n        response, used_tokens = [None] * 2\n        string = self.format_instruct(\n            system=data.system,\n            instruction=data.instruction\n        )\n        for response, used_tokens in self.process(\n                string=string,\n                greedy=data.greedy,\n                max_new_tokens=None\n        ):\n            ...\n        self.number_of_served_request_until_last_up_time += 1\n        return {\n            \"input\": f\"{string}\",\n            \"response\": response,\n            \"tokens_used\": used_tokens,\n        }\n\n    def forward_instruct_non_api(self, prompt, system, greedy):\n        \"\"\"\n        The forward_instruct_non_api function is a wrapper for the forward_instruct function.\n        It takes in a prompt, system, and greedy flag as arguments and returns the response from\n        the forward_instruct function. The purpose of this wrapper is to allow users to call\n        forward_instruct without having to create an InstructRequest object.\n\n        :param self: Represent the instance of the class\n        :param prompt: Pass the instruction to the system\n        :param system: Specify which system to use for the instruction\n        :param greedy: Determine whether the system should return\n        :return: The response from the forward_instruct function\n\n        \"\"\"\n        data = InstructRequest(\n            prompt=prompt,\n            system=system,\n            greedy=greedy\n        )\n        return self.forward_instruct(data)\n\n    def forward_chat_non_api(self, prompt, history, greedy):\n        \"\"\"\n        The forward_chat_non_api function is a wrapper for the forward_chat function.\n        It takes in a prompt, history, and greedy parameter and returns the response from\n        the forward_chat function. The purpose of this wrapper is to allow users to use\n        the chatbot without having to create ChatRequest objects.\n\n        :param self: Represent the instance of the class\n        :param prompt: Pass the user's input to the model\n        :param history: Pass the history of the conversation to the model\n        :param greedy: Determine whether the model should use a greedy search\n        :return: A chat-response object\n\n        \"\"\"\n        data = ChatRequest(\n            prompt=prompt,\n            history=history,\n            greedy=greedy\n        )\n        return self.forward_chat(data)\n\n    def process_gradio(\n            self,\n            prompt: str,\n            history: List[List[str]],\n            system_prompt: str | None,\n            mode: str,\n            max_length: int,\n            max_new_tokens: int,\n            max_compile_tokens: int,\n            greedy: bool,\n            temperature: float,\n            top_p: float,\n            top_k: int\n    ):\n        if mode.lower() == \"chat\":\n            string = self.format_chat(\n                history=history,\n                system=system_prompt,\n                prompt=prompt\n            )\n        elif mode.lower() == \"instruct\":\n            history = []\n            string = self.format_instruct(\n                system=system_prompt,\n                instruction=prompt\n            )\n        else:\n            raise ValueError(\"UnKnown Mode for process_gradio available modes are only Chat or Instruct\")\n        history.append([prompt, \"\"])\n        responses = \"\"\n        for response, _ in self.process(\n                string=string,\n                greedy=greedy,\n                max_new_tokens=max_new_tokens,\n        ):\n            responses += response\n            history[-1][-1] = responses\n            yield \"\", history\n\n    def process(self,\n                string: str,\n                *,\n                greedy: bool = False,\n                max_new_tokens: int = None,\n                **kwargs\n                ):\n        \"\"\"\n        The process function is the main function of a model. It takes in an input string and returns a list of strings\n        that are generated from that input string. The process function can be called multiple times with different inputs,\n        and each time it will return a new set of outputs based on those inputs.\n\n        :param self: Access the class attributes\n        :param string: str: Pass the string that we want to generate\n        :param *: Pass a variable number of arguments to a function\n        :param greedy: bool: Determine whether to use the greedy or non-greedy version of the generate function\n        :param max_new_tokens: int: Set the number of tokens to generate\n        :param kwargs: Pass any additional parameters to the process function\n        :return: A generator that yields the predicted text and the number of tokens generated\n\n        \"\"\"\n\n        fixed_pad = self.config.max_length - self.config.max_compile_tokens\n        tokens = self.prefix_tokenizer(\n            string,\n            max_length=fixed_pad,\n            padding=\"max_length\",\n            return_tensors=\"jax\"\n        ) \\\n            if self.config.use_prefix_tokenizer else \\\n            self.tokenizer(\n                string,\n                return_tensors=\"jax\"\n            )\n\n        input_ids = tokens.input_ids\n        attention_mask = tokens.attention_mask\n        num_generated_tokens = 0\n\n        for _ in range((max_new_tokens or self.config.max_new_tokens) // self.config.max_compile_tokens):\n            inputs_to_gen = dict(\n                params=self.params,\n                input_ids=input_ids,\n                attention_mask=attention_mask\n            )\n            predicted_token = self.greedy_generate(**inputs_to_gen) if greedy else self.generate(**inputs_to_gen)\n\n            num_generated_tokens += predicted_token.shape[-1]\n            plus_attn_mask = jnp.ones((len(attention_mask), self.config.max_compile_tokens), dtype=jnp.int32)\n\n            input_ids = jnp.concatenate(\n                (input_ids, predicted_token), axis=-1\n            )[:, -fixed_pad:]\n\n            attention_mask = jnp.concatenate(\n                (attention_mask, plus_attn_mask), dtype=jnp.int32,\n                axis=-1\n            )[:, -fixed_pad:]\n\n            returns = (\n                self.tokenizer.decode(input_ids[0][-num_generated_tokens:], skip_special_tokens=True),\n                num_generated_tokens\n            )\n\n            yield returns\n            if (\n                    predicted_token[0][-1] == self.tokenizer.eos_token_id\n                    or\n                    predicted_token[0][-1] == self.prefix_tokenizer.eos_token_id\n            ):\n                break\n\n    def fire(self):\n        \"\"\"\n        The fire function is a wrapper around the uvicorn.run function that allows you\n         to run your model in a separate process\n        from the main one. This is useful for running models on GPUs, as it prevents any\n        other processes from using them while\n        the model is being served.\n\n        :param self: Refer to the instance of the class\n        :return: A process, which is a child of the main process\n\n        \"\"\"\n        assert self._funcs_generated, \"you have to first add your model and parameters into server before using fire \" \\\n                                      \"with using ``configure_generate_functions``\"\n\n        def run():\n            uvicorn.run(self.app, host=self.config.host, port=self.config.port)\n\n        self.process_uvicorn = mp.Process(target=run)\n        self.process_uvicorn.start()\n\n    def end(self):\n        \"\"\"\n        The end function is used to stop the server.\n            It will wait for the process to end before returning.\n\n        :param self: Represent the instance of the class\n        :return: The process_uvicorn\n\n        \"\"\"\n        if self.process_uvicorn is not None:\n            self.process_uvicorn.join()\n        else:\n            logging.warning(\"you have to fire server before ending that this command will be ignored\")\n\n    def gradio_inference(self):\n        return self.build_inference(\n            sample_func=self.process_gradio,\n            max_length=self.config.max_length,\n            max_new_tokens=self.config.max_new_tokens,\n            max_compile_tokens=self.config.max_compile_tokens,\n        )\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.__init__","title":"<code>__init__(config=None)</code>","text":"<p>The init function is called when the class is instantiated. It sets up all the attributes that will be used by other methods in the class.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the current instance of a class</p> required <code>config</code> <p>Pass the JAXServerConfig object</p> <code>None</code> <p>Returns:</p> Type Description <p>A fastapi object</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def __init__(self, config=None):\n\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up all the attributes that will be used by other methods in the class.\n\n\n    :param self: Refer to the current instance of a class\n    :param config: Pass the JAXServerConfig object\n    :return: A fastapi object\n\n    \"\"\"\n    (\n        self.process_uvicorn,\n        self.prefix_tokenizer,\n        self.params,\n        self.tokenizer,\n        self.model,\n        self.partition_specs,\n        self.generate_function,\n        self.greedy_generate_function\n    ) = [None] * 8\n    assert config is None or isinstance(config, JAXServerConfig), \"config can be None or JAXServerConfig Type\"\n    if config is None:\n        config = JAXServerConfig()\n\n    self.config = config\n    self._funcs_generated = False\n    self.number_of_served_request_until_last_up_time = 0\n\n    self.rng_generator = RNG(42)\n    initialise_tracking(0.5)\n    array = jnp.ones((len(jax.devices()), 1)).reshape(self.config.mesh_axes_shape)\n    self.mesh = Mesh(mesh_utils.create_device_mesh(array.shape), self.config.mesh_axes_names)\n\n    self.app = FastAPI()\n    self.app.post(\"/chat\")(self.forward_chat)\n    self.app.post(\"/instruct\")(self.forward_instruct)\n    self.app.get(\"/status\")(self.status)\n    self.app = gr.mount_gradio_app(self.app, self.gradio_inference(), \"/gradio_chat\")\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.auto_configure","title":"<code>auto_configure(model, params, tokenizer, partition_rules)</code>","text":"<p>The auto_configure function is a helper function that will automatically configure the model for distributed training. It does this by:     1) sharding the parameters of the model based on partition_rules, and then     2) configuring generate functions to be used in distributed training.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>model</code> <p>Configure the model</p> required <code>params</code> <p>Store the parameters that are used to configure the model</p> required <code>tokenizer</code> <p>Tokenize the input text</p> required <code>partition_rules</code> <p>Specify how the parameters should be partitioned</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys:</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def auto_configure(self, model, params, tokenizer, partition_rules):\n    \"\"\"\n    The auto_configure function is a helper function that will automatically configure the model for distributed training.\n    It does this by:\n        1) sharding the parameters of the model based on partition_rules, and then\n        2) configuring generate functions to be used in distributed training.\n\n    :param self: Represent the instance of the class\n    :param model: Configure the model\n    :param params: Store the parameters that are used to configure the model\n    :param tokenizer: Tokenize the input text\n    :param partition_rules: Specify how the parameters should be partitioned\n    :return: A dictionary with the following keys:\n\n    \"\"\"\n    self.shard_params(params=params, partition_rules=partition_rules)\n    self.configure_generate_functions(model, tokenizer)\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.compile","title":"<code>compile(verbose=True)</code>","text":"<p>The compile function is used to compile the model for use in inference. It does this by running through all possible combinations of rules and actions, and compiling them into functions that can be called later on during inference. This allows us to avoid having to recompile the model every time we want to run it, which would be very slow.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>verbose</code> <code>bool</code> <p>bool: Print out the compiling process</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True, but what does it do?</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def compile(self, verbose: bool = True) -&gt; bool:\n    \"\"\"\n    The compile function is used to compile the model for use in inference.\n    It does this by running through all possible combinations of rules and actions,\n    and compiling them into functions that can be called later on during inference.\n    This allows us to avoid having to recompile the model every time we want to run it,\n    which would be very slow.\n\n    :param self: Represent the instance of the class\n    :param verbose: bool: Print out the compiling process\n    :return: True, but what does it do?\n    \"\"\"\n    assert self._funcs_generated, \"funcs are not generated yet\"\n    assert self.partition_specs is not None, \"rules should not be None\"\n    if self.config.use_prefix_tokenizer:\n        if verbose:\n            termcolor.cprint(\n                \"Compiling Model Forwards Greedy/Non-Greedy(Generate)\",\n                color=\"cyan\",\n                force_color=True\n            )\n            termcolor.cprint(\n                \"Compiling Greedy Functions\",\n                color=\"cyan\",\n                force_color=True\n            )\n\n        r, a = [None] * 2\n        for r, a in self.process(\n                string=\"\",\n                max_new_tokens=self.config.max_compile_tokens,\n                greedy=True\n        ):\n            ...\n        if verbose:\n            termcolor.cprint(\n                \"Compiling Non-Greedy(Generate) Functions\",\n                color=\"cyan\",\n                force_color=True\n            )\n        for r, a in self.process(\n                string=\"\",\n                max_new_tokens=self.config.max_compile_tokens,\n                greedy=False\n        ):\n            ...\n\n    else:\n        termcolor.cprint(\n            \"Skip Compiling the compiling process is useless \"\n            \"when you are not using prefix tokenizer\",\n            color=\"red\", force_color=True\n        )\n    return True\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.configure_generate_functions","title":"<code>configure_generate_functions(model, tokenizer)</code>","text":"<p>The configure_generate_functions function is used to configure the generation functions for a given model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables within the class</p> required <code>model</code> <p>Generate the model</p> required <code>tokenizer</code> <p>Get the eos_token_id, pad_token_id and bos token id</p> required <p>Returns:</p> Type Description <p>A function that takes in three parameters:</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def configure_generate_functions(self, model, tokenizer):\n\n    \"\"\"\n    The configure_generate_functions function is used to configure the generation functions for a given model.\n\n    :param self: Access variables within the class\n    :param model: Generate the model\n    :param tokenizer: Get the eos_token_id, pad_token_id and bos token id\n    :return: A function that takes in three parameters:\n\n    \"\"\"\n    assert self.partition_specs is not None, \"you should first shard params with using ``shard_params`` method\"\n\n    if tokenizer.pad_token is None:\n        logging.info(\n            \"Tokenizer does not contain padding token setting padding token to eos token for open end generation\")\n        tokenizer.pad_token = tokenizer.eos_token\n\n    try:\n        tokenizer.padding_side = \"left\"\n        tokenizer.truncation_side = \"left\"\n        self.prefix_tokenizer = copy.deepcopy(tokenizer)\n        tokenizer.padding_side = \"right\"\n        tokenizer.truncation_side = \"right\"\n        self.tokenizer = copy.deepcopy(tokenizer)\n    except:\n        prefix_print(\n            \"Warning\", f\"The class Model of Tokenizer {type(tokenizer)} do not support deepcopy option \"\n        )\n        if self.config.use_prefix_tokenizer:\n            tokenizer.padding_side = \"left\"\n            tokenizer.truncation_side = \"left\"\n        else:\n            tokenizer.padding_side = \"right\"\n            tokenizer.truncation_side = \"right\"\n        self.prefix_tokenizer = tokenizer\n\n    @functools.partial(\n        pjit,\n        in_shardings=(self.partition_specs, Ps(), Ps()),\n        out_shardings=(Ps())\n    )\n    def greedy_generate(parameters, input_ids, attention_mask):\n        input_ids = with_sharding_constraint(input_ids, self.config.generation_ps)\n        attention_mask = with_sharding_constraint(attention_mask, self.config.generation_ps)\n        predict = model.generate(\n            input_ids,\n            attention_mask=attention_mask,\n            params=parameters,\n            generation_config=GenerationConfig(\n                max_new_tokens=self.config.max_compile_tokens,\n                eos_token_id=tokenizer.eos_token_id,\n                pad_token_id=tokenizer.pad_token_id,\n                bos_token_id=tokenizer.bos_token_id,\n\n                do_sample=False,\n                num_beams=1,\n            )\n        ).sequences[:, input_ids.shape[1]:]\n        return predict\n\n    @functools.partial(\n        pjit,\n        in_shardings=(self.partition_specs, Ps(), Ps()),\n        out_shardings=(Ps())\n    )\n    def generate(parameters, input_ids, attention_mask):\n        input_ids = with_sharding_constraint(input_ids, self.config.generation_ps)\n        attention_mask = with_sharding_constraint(attention_mask, self.config.generation_ps)\n        predict = model.generate(\n            input_ids,\n            attention_mask=attention_mask,\n            params=parameters,\n            generation_config=GenerationConfig(\n                max_new_tokens=self.config.max_compile_tokens,\n\n                eos_token_id=tokenizer.eos_token_id,\n                pad_token_id=tokenizer.pad_token_id,\n                bos_token_id=tokenizer.bos_token_id,\n\n                temperature=self.config.temperature,\n                do_sample=True,\n                num_beams=1,\n                top_p=self.config.top_p,\n                top_k=self.config.top_k,\n            )\n        ).sequences[:, input_ids.shape[1]:]\n        return predict\n\n    self.generate_function = generate\n    self.greedy_generate_function = greedy_generate\n    self._funcs_generated = True\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.end","title":"<code>end()</code>","text":"<p>The end function is used to stop the server.     It will wait for the process to end before returning.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>The process_uvicorn</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def end(self):\n    \"\"\"\n    The end function is used to stop the server.\n        It will wait for the process to end before returning.\n\n    :param self: Represent the instance of the class\n    :return: The process_uvicorn\n\n    \"\"\"\n    if self.process_uvicorn is not None:\n        self.process_uvicorn.join()\n    else:\n        logging.warning(\"you have to fire server before ending that this command will be ignored\")\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.fire","title":"<code>fire()</code>","text":"<p>The fire function is a wrapper around the uvicorn.run function that allows you  to run your model in a separate process from the main one. This is useful for running models on GPUs, as it prevents any other processes from using them while the model is being served.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the instance of the class</p> required <p>Returns:</p> Type Description <p>A process, which is a child of the main process</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def fire(self):\n    \"\"\"\n    The fire function is a wrapper around the uvicorn.run function that allows you\n     to run your model in a separate process\n    from the main one. This is useful for running models on GPUs, as it prevents any\n    other processes from using them while\n    the model is being served.\n\n    :param self: Refer to the instance of the class\n    :return: A process, which is a child of the main process\n\n    \"\"\"\n    assert self._funcs_generated, \"you have to first add your model and parameters into server before using fire \" \\\n                                  \"with using ``configure_generate_functions``\"\n\n    def run():\n        uvicorn.run(self.app, host=self.config.host, port=self.config.port)\n\n    self.process_uvicorn = mp.Process(target=run)\n    self.process_uvicorn.start()\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.format_chat","title":"<code>format_chat(history, prompt, system)</code>  <code>staticmethod</code>","text":"<p>Here you will get the system, prompt and history from user, and you can apply your prompting style</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>@staticmethod\ndef format_chat(history: List[List[str]], prompt: str, system: Union[str, None]) -&gt; str:\n    \"\"\"\n    Here you will get the system, prompt and history from user, and you can apply your prompting style\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.format_instruct","title":"<code>format_instruct(system, instruction)</code>  <code>staticmethod</code>","text":"<p>Here you will get the system and instruction from user, and you can apply your prompting style</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>@staticmethod\ndef format_instruct(system: str, instruction: str) -&gt; str:\n    \"\"\"\n    Here you will get the system and instruction from user, and you can apply your prompting style\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.forward_chat","title":"<code>forward_chat(data)</code>","text":"<p>The forward_chat function is the main function of this class. It takes in a ChatRequest object, which contains a prompt and history. The prompt is the user\"s input to be processed by the chatbot, while history is an array of previous inputs and outputs from both sides (user and bot). The forward_chat function then formats these inputs into one string that can be processed by our model. This formatted string is then passed through our process() method, which returns an output response as well as how many tokens were used to generate it.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the attributes and methods of the class</p> required <code>data</code> <code>ChatRequest</code> <p>ChatRequest: Pass in the data from the request</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys:</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def forward_chat(self, data: ChatRequest):\n\n    \"\"\"\n    The forward_chat function is the main function of this class.\n    It takes in a ChatRequest object, which contains a prompt and history.\n    The prompt is the user\"s input to be processed by the chatbot, while history\n    is an array of previous inputs and outputs from both sides (user and bot).\n    The forward_chat function then formats these inputs into one string that can be processed by our model.\n    This formatted string is then passed through our process() method, which returns an output response as well as how many tokens were used to generate it.\n\n    :param self: Access the attributes and methods of the class\n    :param data: ChatRequest: Pass in the data from the request\n    :return: A dictionary with the following keys:\n\n    \"\"\"\n    if not self._funcs_generated:\n        return {\n            \"status\": \"down\"\n        }\n\n    string = self.format_chat(\n        prompt=data.prompt,\n        system=None,\n        history=data.history\n    )\n\n    response, used_tokens = [None] * 2\n    for response, used_tokens in self.process(\n            string=string,\n            greedy=data.greedy,\n            max_new_tokens=None\n    ):\n        ...\n    self.number_of_served_request_until_last_up_time += 1\n    return {\n        \"input\": f\"{string}\",\n        \"response\": response,\n        \"tokens_used\": used_tokens,\n    }\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.forward_chat_non_api","title":"<code>forward_chat_non_api(prompt, history, greedy)</code>","text":"<p>The forward_chat_non_api function is a wrapper for the forward_chat function. It takes in a prompt, history, and greedy parameter and returns the response from the forward_chat function. The purpose of this wrapper is to allow users to use the chatbot without having to create ChatRequest objects.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>prompt</code> <p>Pass the user's input to the model</p> required <code>history</code> <p>Pass the history of the conversation to the model</p> required <code>greedy</code> <p>Determine whether the model should use a greedy search</p> required <p>Returns:</p> Type Description <p>A chat-response object</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def forward_chat_non_api(self, prompt, history, greedy):\n    \"\"\"\n    The forward_chat_non_api function is a wrapper for the forward_chat function.\n    It takes in a prompt, history, and greedy parameter and returns the response from\n    the forward_chat function. The purpose of this wrapper is to allow users to use\n    the chatbot without having to create ChatRequest objects.\n\n    :param self: Represent the instance of the class\n    :param prompt: Pass the user's input to the model\n    :param history: Pass the history of the conversation to the model\n    :param greedy: Determine whether the model should use a greedy search\n    :return: A chat-response object\n\n    \"\"\"\n    data = ChatRequest(\n        prompt=prompt,\n        history=history,\n        greedy=greedy\n    )\n    return self.forward_chat(data)\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.forward_instruct","title":"<code>forward_instruct(data)</code>","text":"<p>The forward_instruct function is the main function of this class. It takes in a InstructRequest object, which contains the system and instruction to be processed. The function then formats the input string using format_instruct, and passes it into process(). process() returns a tuple containing (response, used_tokens). The response is returned as part of the response dictionary. If no valid responses are found by process(), None will be returned instead.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Bind the method to the object</p> required <code>data</code> <code>InstructRequest</code> <p>InstructRequest: Pass the system and instruction to the function</p> required <p>Returns:</p> Type Description <p>A dictionary with three keys:</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def forward_instruct(self, data: InstructRequest):\n    \"\"\"\n    The forward_instruct function is the main function of this class.\n    It takes in a InstructRequest object, which contains the system and instruction to be processed.\n    The function then formats the input string using format_instruct, and passes it into process().\n    process() returns a tuple containing (response, used_tokens). The response is returned as part of\n    the response dictionary. If no valid responses are found by process(), None will be returned instead.\n\n    :param self: Bind the method to the object\n    :param data: InstructRequest: Pass the system and instruction to the function\n    :return: A dictionary with three keys:\n\n    \"\"\"\n    if not self._funcs_generated:\n        return {\n            \"status\": \"down\"\n        }\n\n    response, used_tokens = [None] * 2\n    string = self.format_instruct(\n        system=data.system,\n        instruction=data.instruction\n    )\n    for response, used_tokens in self.process(\n            string=string,\n            greedy=data.greedy,\n            max_new_tokens=None\n    ):\n        ...\n    self.number_of_served_request_until_last_up_time += 1\n    return {\n        \"input\": f\"{string}\",\n        \"response\": response,\n        \"tokens_used\": used_tokens,\n    }\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.forward_instruct_non_api","title":"<code>forward_instruct_non_api(prompt, system, greedy)</code>","text":"<p>The forward_instruct_non_api function is a wrapper for the forward_instruct function. It takes in a prompt, system, and greedy flag as arguments and returns the response from the forward_instruct function. The purpose of this wrapper is to allow users to call forward_instruct without having to create an InstructRequest object.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>prompt</code> <p>Pass the instruction to the system</p> required <code>system</code> <p>Specify which system to use for the instruction</p> required <code>greedy</code> <p>Determine whether the system should return</p> required <p>Returns:</p> Type Description <p>The response from the forward_instruct function</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def forward_instruct_non_api(self, prompt, system, greedy):\n    \"\"\"\n    The forward_instruct_non_api function is a wrapper for the forward_instruct function.\n    It takes in a prompt, system, and greedy flag as arguments and returns the response from\n    the forward_instruct function. The purpose of this wrapper is to allow users to call\n    forward_instruct without having to create an InstructRequest object.\n\n    :param self: Represent the instance of the class\n    :param prompt: Pass the instruction to the system\n    :param system: Specify which system to use for the instruction\n    :param greedy: Determine whether the system should return\n    :return: The response from the forward_instruct function\n\n    \"\"\"\n    data = InstructRequest(\n        prompt=prompt,\n        system=system,\n        greedy=greedy\n    )\n    return self.forward_instruct(data)\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.from_parameters","title":"<code>from_parameters(model, config_model, tokenizer, params, config=None, add_params_field=True, do_memory_log=False, verbose=True)</code>  <code>classmethod</code>","text":"<p>The from_parameters function is used to load a model from the parameters of a pretrained model. It takes in the following arguments:     - cls: The class of the server you are loading, this should be Server or TPU_Server depending on     what backend you want to use.     - model: A FlaxPreTrainedModel object that contains all of your models functions and parameters. This can      be found in transformers/flax_utils/models/model.py         where model is replaced with whatever transformer you are using (e.g., bert). You can also create          your own custom</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>Create a new instance of the class</p> required <code>model</code> <code>FlaxPreTrainedModel</code> <p>transformers.FlaxPreTrainedModel: Load the model</p> required <code>config_model</code> <code>PretrainedConfig</code> <p>transformers.PretrainedConfig: Get the partition rules</p> required <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>transformers.PreTrainedTokenizer: Tokenize the input text</p> required <code>params</code> <code>Dict</code> <p>Dict: Pass in the parameters of the model</p> required <code>config</code> <code>JAXServerConfig</code> <p>Pass in the config file for the server</p> <code>None</code> <code>add_params_field</code> <code>bool</code> <p>bool: Add a params field to the server</p> <code>True</code> <code>do_memory_log</code> <code>bool</code> <p>bool: Log the memory usage of the server</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>bool: Print out the status of the compilation</p> <code>True</code> <p>Returns:</p> Type Description <p>A server object</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>@classmethod\ndef from_parameters(\n        cls,\n        model: transformers.FlaxPreTrainedModel,\n        config_model: transformers.PretrainedConfig,\n        tokenizer: transformers.PreTrainedTokenizer,\n        params: Dict,\n        config: JAXServerConfig = None,\n        add_params_field: bool = True,\n        do_memory_log: bool = False,\n        verbose: bool = True\n):\n    \"\"\"\n    The from_parameters function is used to load a model from the parameters of a pretrained model.\n    It takes in the following arguments:\n        - cls: The class of the server you are loading, this should be Server or TPU_Server depending on\n        what backend you want to use.\n        - model: A FlaxPreTrainedModel object that contains all of your models functions and parameters. This can\n         be found in transformers/flax_utils/models/*model*.py\n            where *model* is replaced with whatever transformer you are using (e.g., bert). You can also create\n             your own custom\n\n    :param cls: Create a new instance of the class\n    :param model: transformers.FlaxPreTrainedModel: Load the model\n    :param config_model: transformers.PretrainedConfig: Get the partition rules\n    :param tokenizer: transformers.PreTrainedTokenizer: Tokenize the input text\n    :param params: Dict: Pass in the parameters of the model\n    :param config: Pass in the config file for the server\n    :param add_params_field: bool: Add a params field to the server\n    :param do_memory_log: bool: Log the memory usage of the server\n    :param verbose: bool: Print out the status of the compilation\n    :return: A server object\n\n    \"\"\"\n    assert hasattr(model, \"init_weights\"), (\n        \"model must contain init_weights func in order to init params for shard_fns\"\n    )\n    assert hasattr(config_model, \"get_partition_rules\"), (\n        \"config_model must contain get_partition_rules functions\"\n    )\n    server = cls(config=config)\n\n    with server.mesh:\n        logging.info(\n            \"matching partition rules\"\n        )\n        partition_specs = match_partition_rules(params=params, rules=config_model.get_partition_rules(True))\n        shard_fns, _ = make_shard_and_gather_fns(partition_specs, get_dtype(server.config.dtype))\n        logging.info(\n            \"sharding parameters across all of the chosen backend(tpu/gpu/cpu)s\"\n        )\n        params = flax.traverse_util.flatten_dict(params)\n        shard_fns = flax.traverse_util.flatten_dict(shard_fns)\n        pbar = tqdm.tqdm(params.keys())\n        for key in pbar:\n            key = tuple(key)\n            params[key] = shard_fns[key](params[key])\n            if do_memory_log:\n                pbar.write(server.get_memory())\n            pbar.set_description(\"Sharding Params\")\n        server.params = flax.traverse_util.unflatten_dict(params)\n        server.params = {\"params\": server.params} if add_params_field else server.params\n    server.partition_specs = {\"params\": partition_specs} if add_params_field else partition_specs\n    logging.info(\n        \"configuring generate functions for the server\"\n    )\n    server.configure_generate_functions(model, tokenizer)\n    if server.config.pre_compile:\n        server.compile(verbose=verbose)\n    return server\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.generate","title":"<code>generate(params, input_ids, attention_mask)</code>","text":"<p>The generate function is used to generate a sequence of tokens from the model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access variables that belong to the class</p> required <code>params</code> <code>Union[FrozenDict, dict]</code> <p>Union[flax.core.FrozenDict, dict]: Pass the parameters of the model to be used in generating text</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass the input to the model</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask the padding tokens</p> required <p>Returns:</p> Type Description <p>The logits of the model</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def generate(\n        self,\n        params: Union[flax.core.FrozenDict, dict],\n        input_ids: chex.Array,\n        attention_mask: chex.Array,\n):\n    \"\"\"\n    The generate function is used to generate a sequence of tokens from the model.\n\n    :param self: Access variables that belong to the class\n    :param params: Union[flax.core.FrozenDict, dict]: Pass the parameters of the model to be used in generating text\n    :param input_ids: chex.Array: Pass the input to the model\n    :param attention_mask: chex.Array: Mask the padding tokens\n    :return: The logits of the model\n\n    \"\"\"\n    if not self._funcs_generated:\n        raise NotImplementedError(\n            \"this method will be implemented automatically after using ``configure_generate_functions`` function\"\n        )\n    else:\n        with self.mesh:\n            return self.generate_function(\n                params, input_ids, attention_mask\n            )\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.get_memory","title":"<code>get_memory()</code>  <code>staticmethod</code>","text":"<p>The get_memory function returns the total memory of the system in bytes.</p> <p>Returns:</p> Type Description <p>The amount of memory used by the program</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>@staticmethod\ndef get_memory():\n    \"\"\"\n    The get_memory function returns the total memory of the system in bytes.\n\n\n    :return: The amount of memory used by the program\n\n    \"\"\"\n    return get_mem()\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.greedy_generate","title":"<code>greedy_generate(params, input_ids, attention_mask)</code>","text":"<p>The greedy_generate function is a helper function that takes in the model parameters, input_ids and attention_mask and returns the generated tokens. It uses greedy search to generate tokens one at a time.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>params</code> <code>Union[FrozenDict, dict]</code> <p>Union[flax.core.FrozenDict, dict]: Pass the parameters to the model</p> required <code>input_ids</code> <code>Array</code> <p>chex.Array: Pass in the input sequence</p> required <code>attention_mask</code> <code>Array</code> <p>chex.Array: Mask the input tokens</p> required <code></code> <p>Specify the parameters of the model</p> required <p>Returns:</p> Type Description <p>generated_ids</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def greedy_generate(self,\n                    params: Union[flax.core.FrozenDict, dict],\n                    input_ids: chex.Array,\n                    attention_mask: chex.Array,\n                    ):\n    \"\"\"\n    The greedy_generate function is a helper function that takes in the model parameters, input_ids and attention_mask\n    and returns the generated tokens. It uses greedy search to generate tokens one at a time.\n\n\n    :param self: Refer to the object itself\n    :param params: Union[flax.core.FrozenDict, dict]: Pass the parameters to the model\n    :param input_ids: chex.Array: Pass in the input sequence\n    :param attention_mask: chex.Array: Mask the input tokens\n    :param : Specify the parameters of the model\n    :return:  generated_ids\n\n    \"\"\"\n    if not self._funcs_generated:\n        raise NotImplementedError(\n            \"this method will be implemented automatically after using ``configure_generate_functions`` function\"\n        )\n    else:\n        with self.mesh:\n            return self.greedy_generate_function(\n                params, input_ids, attention_mask\n            )\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.load","title":"<code>load(model, config_model, tokenizer, path, config=None, add_params_field=True, init_shape=(1, 1), do_memory_log=False, verbose=True)</code>  <code>classmethod</code>","text":"<p>The load function is used to load a pretrained model from disk.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>Refer to the class itself</p> required <code>model</code> <code>FlaxPreTrainedModel</code> <p>transformers.FlaxPreTrainedModel: Initialize the server</p> required <code>config_model</code> <code>PretrainedConfig</code> <p>transformers.PretrainedConfig: Get the partition rules</p> required <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>transformers.PreTrainedTokenizer: Load the tokenizer from the model</p> required <code>path</code> <code>Union[str, PathLike]</code> <p>Union[str, os.PathLike]: Specify the path to the checkpoint file</p> required <code>config</code> <p>Configure the server</p> <code>None</code> <code>add_params_field</code> <code>bool</code> <p>bool: Add a params field to the server</p> <code>True</code> <code>init_shape</code> <code>tuple</code> <p>tuple: Specify the shape of the input to be used for generating shard_fns</p> <code>(1, 1)</code> <code>do_memory_log</code> <code>bool</code> <p>bool: Log the memory usage of the server</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>bool: Print the compilation process</p> <code>True</code> <p>Returns:</p> Type Description <p>A server</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>@classmethod\ndef load(\n        cls,\n        model: transformers.FlaxPreTrainedModel,\n        config_model: transformers.PretrainedConfig,\n        tokenizer: transformers.PreTrainedTokenizer,\n        path: Union[str, os.PathLike],\n        config=None,\n        add_params_field: bool = True,\n        init_shape: tuple = (1, 1),\n        do_memory_log: bool = False,\n        verbose: bool = True\n):\n    \"\"\"\n    The load function is used to load a pretrained model from disk.\n\n    :param cls: Refer to the class itself\n    :param model: transformers.FlaxPreTrainedModel: Initialize the server\n    :param config_model: transformers.PretrainedConfig: Get the partition rules\n    :param tokenizer: transformers.PreTrainedTokenizer: Load the tokenizer from the model\n    :param path: Union[str, os.PathLike]: Specify the path to the checkpoint file\n    :param config: Configure the server\n    :param add_params_field: bool: Add a params field to the server\n    :param init_shape: tuple: Specify the shape of the input to be used for generating shard_fns\n    :param do_memory_log: bool: Log the memory usage of the server\n    :param verbose: bool: Print the compilation process\n    :return: A server\n\n    \"\"\"\n    assert hasattr(model,\n                   \"init_weights\"), \"model must contain init_weights func in order to init params for shard_fns\"\n    assert hasattr(config_model,\n                   \"get_partition_rules\"), \"config_model must contain get_partition_rules functions\"\n    server = cls(config=config)\n    logging.info(\n        \"running _init() func in order to make shard_fns\"\n    )\n    with jax.default_device(jax.devices(\"cpu\")[0]):\n        def _init():\n            return model.init_weights(jax.random.PRNGKey(0), init_shape)\n\n        shape = jax.eval_shape(_init)\n    logging.info(\n        \"matching partition rules\"\n    )\n    rules = match_partition_rules(params=shape, rules=config_model.get_partition_rules(True))\n\n    with server.mesh:\n        shard_fns, _ = make_shard_and_gather_fns(rules, get_dtype(server.config.dtype))\n        logging.info(\n            \"loading checkpoints\"\n        )\n\n        shard_fns = flax.traverse_util.flatten_dict(shard_fns)\n        server.params = {}\n        with open(path, \"rb\") as stream:\n            unpacker = msgpack.Unpacker(stream, read_size=83886080, max_buffer_size=0)\n            pbar = tqdm.tqdm(unpacker)\n            for key, value in pbar:\n                key = tuple(key)\n                tensor = from_bytes(None, value)\n                tensor = shard_fns[key](tensor)\n                server.params[key] = tensor\n                if do_memory_log:\n                    pbar.write(server.get_memory())\n                pbar.set_description(\"Sharding Params\")\n    server.params = flax.traverse_util.unflatten_dict(server.params)\n    server.params = {\"params\": server.params} if add_params_field else server.params\n\n    server.rules = {\"params\": rules} if add_params_field else rules\n    logging.info(\n        \"configuring generate functions for the server\"\n    )\n    server.configure_generate_functions(model, tokenizer)\n\n    if server.config.pre_compile:\n        server.compile(verbose=verbose)\n    return server\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.process","title":"<code>process(string, *, greedy=False, max_new_tokens=None, **kwargs)</code>","text":"<p>The process function is the main function of a model. It takes in an input string and returns a list of strings that are generated from that input string. The process function can be called multiple times with different inputs, and each time it will return a new set of outputs based on those inputs.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the class attributes</p> required <code>string</code> <code>str</code> <p>str: Pass the string that we want to generate</p> required <code>*</code> <p>Pass a variable number of arguments to a function</p> required <code>greedy</code> <code>bool</code> <p>bool: Determine whether to use the greedy or non-greedy version of the generate function</p> <code>False</code> <code>max_new_tokens</code> <code>int</code> <p>int: Set the number of tokens to generate</p> <code>None</code> <code>kwargs</code> <p>Pass any additional parameters to the process function</p> <code>{}</code> <p>Returns:</p> Type Description <p>A generator that yields the predicted text and the number of tokens generated</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def process(self,\n            string: str,\n            *,\n            greedy: bool = False,\n            max_new_tokens: int = None,\n            **kwargs\n            ):\n    \"\"\"\n    The process function is the main function of a model. It takes in an input string and returns a list of strings\n    that are generated from that input string. The process function can be called multiple times with different inputs,\n    and each time it will return a new set of outputs based on those inputs.\n\n    :param self: Access the class attributes\n    :param string: str: Pass the string that we want to generate\n    :param *: Pass a variable number of arguments to a function\n    :param greedy: bool: Determine whether to use the greedy or non-greedy version of the generate function\n    :param max_new_tokens: int: Set the number of tokens to generate\n    :param kwargs: Pass any additional parameters to the process function\n    :return: A generator that yields the predicted text and the number of tokens generated\n\n    \"\"\"\n\n    fixed_pad = self.config.max_length - self.config.max_compile_tokens\n    tokens = self.prefix_tokenizer(\n        string,\n        max_length=fixed_pad,\n        padding=\"max_length\",\n        return_tensors=\"jax\"\n    ) \\\n        if self.config.use_prefix_tokenizer else \\\n        self.tokenizer(\n            string,\n            return_tensors=\"jax\"\n        )\n\n    input_ids = tokens.input_ids\n    attention_mask = tokens.attention_mask\n    num_generated_tokens = 0\n\n    for _ in range((max_new_tokens or self.config.max_new_tokens) // self.config.max_compile_tokens):\n        inputs_to_gen = dict(\n            params=self.params,\n            input_ids=input_ids,\n            attention_mask=attention_mask\n        )\n        predicted_token = self.greedy_generate(**inputs_to_gen) if greedy else self.generate(**inputs_to_gen)\n\n        num_generated_tokens += predicted_token.shape[-1]\n        plus_attn_mask = jnp.ones((len(attention_mask), self.config.max_compile_tokens), dtype=jnp.int32)\n\n        input_ids = jnp.concatenate(\n            (input_ids, predicted_token), axis=-1\n        )[:, -fixed_pad:]\n\n        attention_mask = jnp.concatenate(\n            (attention_mask, plus_attn_mask), dtype=jnp.int32,\n            axis=-1\n        )[:, -fixed_pad:]\n\n        returns = (\n            self.tokenizer.decode(input_ids[0][-num_generated_tokens:], skip_special_tokens=True),\n            num_generated_tokens\n        )\n\n        yield returns\n        if (\n                predicted_token[0][-1] == self.tokenizer.eos_token_id\n                or\n                predicted_token[0][-1] == self.prefix_tokenizer.eos_token_id\n        ):\n            break\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.shard_params","title":"<code>shard_params(params, partition_rules)</code>","text":"<p>The shard_params function takes in a set of parameters and a partition rule. The partition rule is used to determine how the parameters should be sharded across devices. For example, if we have two devices, one with 4GB of memory and another with 8GB of memory, we may want to shard our model such that the device with more memory has more parameters on it. This function returns an updated version of params where each parameter is now stored on its own device.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Bind the instance of the class to a method</p> required <code>params</code> <p>Pass the parameters of the model to be sharded</p> required <code>partition_rules</code> <p>Specify how the parameters should be partitioned</p> required <p>Returns:</p> Type Description <p>The sharded parameters</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def shard_params(self, params, partition_rules):\n\n    \"\"\"\n    The shard_params function takes in a set of parameters and a partition rule.\n    The partition rule is used to determine how the parameters should be sharded across devices.\n    For example, if we have two devices, one with 4GB of memory and another with 8GB of memory,\n    we may want to shard our model such that the device with more memory has more parameters on it.\n    This function returns an updated version of params where each parameter is now stored on its own device.\n\n    :param self: Bind the instance of the class to a method\n    :param params: Pass the parameters of the model to be sharded\n    :param partition_rules: Specify how the parameters should be partitioned\n    :return: The sharded parameters\n\n    \"\"\"\n    logging.log(\n        logging.INFO,\n        \"the parameters will be sharded and ba saved inside server you can access them by ``JAXServer.params``\")\n    rules = match_partition_rules(params=params, rules=partition_rules)\n    self.partition_specs = rules\n    shard_fns, _ = make_shard_and_gather_fns(rules, get_dtype(self.config.dtype))\n\n    with self.mesh:\n        self.params = jax.tree_map(\n            lambda f, p: f(p), shard_fns, params\n        )\n\n    return self.params\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServer.status","title":"<code>status()</code>","text":"<p>The status function returns a dictionary with the following keys:     config: A dictionary containing all the configuration parameters for this server.     devices: A string describing which devices are available to JAX.     number_of_backends: The number of backends available to JAX.  This is usually equal to the number of GPUs     on your machine, but can be less if you have not installed CUDA or if you have disabled some GPUs in your      system BIOS settings (e.g., because they are defective).  It can also be more than one if you have multiple       machines connected via MPI and running under Horov</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys:</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>def status(self):\n    \"\"\"\n    The status function returns a dictionary with the following keys:\n        config: A dictionary containing all the configuration parameters for this server.\n        devices: A string describing which devices are available to JAX.\n        number_of_backends: The number of backends available to JAX.  This is usually equal to the number of GPUs\n        on your machine, but can be less if you have not installed CUDA or if you have disabled some GPUs in your\n         system BIOS settings (e.g., because they are defective).  It can also be more than one if you have multiple\n          machines connected via MPI and running under Horov\n\n    :param self: Represent the instance of the class\n    :return: A dictionary with the following keys:\n\n    \"\"\"\n    return {\n        \"config\": {k: v for k, v in self.config.__dict__.items()},\n        \"devices\": f\"{jax.devices()}\",\n        \"number_of_backends\": len(jax.devices()),\n        \"status\": \"Ready\",\n        \"number_of_served_request_until_last_up_time\": f\"{self.number_of_served_request_until_last_up_time}\",\n        \"memory\": f\"{get_mem()}\"\n    }\n</code></pre>"},{"location":"generated-serve-jax_serve/#lib.python.EasyDel.serve.jax_serve.JAXServerConfig","title":"<code>JAXServerConfig</code>  <code>dataclass</code>","text":"<p>It sets up the attributes of an instance of this class, which are:         host: str = \"0.0.0.0\"             The IP address to listen on for incoming requests from clients</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>str: Set the host address of the server</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>int: Specify the port number that the server will run on</p> <code>2059</code> <code>batch_size</code> <code>int</code> <p>int: Set the batch size of the model</p> <code>1</code> <code>contains_auto_format</code> <code>bool</code> <p>bool: Determine whether the input text contains auto-formatting</p> <code>True</code> <code>max_sequence_length</code> <code>int</code> <p>int: Set the maximum length of the text that can be generated</p> <code>4096</code> <code>max_new_tokens</code> <code>int</code> <p>int: Determine how many tokens can be added to the vocabulary</p> <code>4096</code> <code>max_compile_tokens</code> <code>int</code> <p>int: Set the maximum number of tokens that can be streamed at a time</p> <code>64</code> <code>generation_ps</code> <code>PartitionSpec</code> <p>jax.sharding.PartitionSpec : PartitionSpec to use for sharding data</p> <code>PartitionSpec('dp', 'fsdp')</code> <code>temperature</code> <code>float</code> <p>float: Control the randomness of the output</p> <code>0.1</code> <code>top_p</code> <code>float</code> <p>float: Control the diversity of the text generated</p> <code>0.95</code> <code>top_k</code> <code>int</code> <p>int: Limit the number of tokens that can be generated</p> <code>50</code> <code>logging</code> <code>bool</code> <p>bool: Print out the progress of the server</p> <code>True</code> <code>mesh_axes_names</code> <code>Sequence[str]</code> <p>Sequence[str]: Specify the names of the axes in the mesh tensor</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <code>&amp;quot;mp&amp;quot;)</code> <p>Define the mesh_axes_names</p> required <code>mesh_axes_shape</code> <code>Sequence[int]</code> <p>Sequence[int]: Specify the shape of the mesh</p> <code>(1, -1, 1, 1)</code> <code>dtype</code> <code>str</code> <p>str: Specify the data type of the model</p> <code>'fp16'</code> <code>stream_tokens_for_gradio</code> <code>bool</code> <p>bool: Determine whether the stream tokens</p> <code>True</code> <code>use_prefix_tokenizer</code> <code>bool</code> <p>bool: Determine if the tokenizer should be used to generate tokens</p> <code>True</code> <code>pre_compile</code> <code>bool</code> <p>bool: Pre-compile the model</p> <code>True</code> <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>lib/python/EasyDel/serve/jax_serve.py</code> <pre><code>@dataclass\nclass JAXServerConfig:\n    \"\"\"\n    It sets up the attributes of an instance of this class, which are:\n            host: str = &amp;quot;0.0.0.0&amp;quot;\n                The IP address to listen on for incoming requests from clients\n\n    :param host: str: Set the host address of the server\n    :param port: int: Specify the port number that the server will run on\n    :param batch_size: int: Set the batch size of the model\n    :param contains_auto_format: bool: Determine whether the input text contains auto-formatting\n    :param max_sequence_length: int: Set the maximum length of the text that can be generated\n    :param max_new_tokens: int: Determine how many tokens can be added to the vocabulary\n    :param max_compile_tokens: int: Set the maximum number of tokens that can be streamed at a time\n    :param generation_ps: jax.sharding.PartitionSpec : PartitionSpec to use for sharding data\n    :param temperature: float: Control the randomness of the output\n    :param top_p: float: Control the diversity of the text generated\n    :param top_k: int: Limit the number of tokens that can be generated\n    :param logging: bool: Print out the progress of the server\n    :param mesh_axes_names: Sequence[str]: Specify the names of the axes in the mesh tensor\n    :param &amp;quot;mp&amp;quot;): Define the mesh_axes_names\n    :param mesh_axes_shape: Sequence[int]: Specify the shape of the mesh\n    :param dtype: str: Specify the data type of the model\n    :param stream_tokens_for_gradio: bool: Determine whether the stream tokens\n    :param use_prefix_tokenizer: bool: Determine if the tokenizer should be used to generate tokens\n    :param pre_compile: bool: Pre-compile the model\n    :return: Nothing\n\n    \"\"\"\n    host: str = \"0.0.0.0\"\n    port: int = 2059\n    batch_size: int = 1\n    contains_auto_format: bool = True\n    max_sequence_length: int = 4096\n    max_new_tokens: int = 4096\n    max_compile_tokens: int = 64\n    temperature: float = 0.1\n    top_p: float = 0.95\n    top_k: int = 50\n    logging: bool = True\n    mesh_axes_names: Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\")\n    mesh_axes_shape: Sequence[int] = (1, -1, 1, 1)\n    generation_ps: jax.sharding.PartitionSpec = Ps(\"dp\", \"fsdp\")\n    dtype: str = \"fp16\"\n    stream_tokens_for_gradio: bool = True\n    use_prefix_tokenizer: bool = True\n    pre_compile: bool = True\n\n    def __post_init__(self):\n        assert self.max_new_tokens % self.max_compile_tokens == 0, (\n            f\"max_new_tokens should be divisible by max_compile_tokens  {self.max_new_tokens % self.max_compile_tokens}\"\n        )\n</code></pre>"},{"location":"generated-serve-torch_serve/","title":"serve.torch_serve","text":""},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer","title":"<code>PyTorchServer</code>","text":"<p>             Bases: <code>GradioUserInference</code></p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>class PyTorchServer(GradioUserInference):\n\n    def __init__(self, config: PytorchServerConfig):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the instance of the class, and defines all its attributes.\n        The __init__ function can accept arguments, which are passed at instantiation.\n\n        :param self: Represent the instance of the class\n        :param config: PytorchServerConfig: Pass the configuration parameters to the class\n        :return: The app, which is a fastapi object\n\n        \"\"\"\n        self.model, self.tokenizer = [None] * 2\n\n        self.config = config\n        self.process_uvicorn = None\n        self.app = FastAPI()\n        self.number_of_served_request_until_last_up_time = 0\n        self.device_rolling = self.get_gpu_memory(self.config.max_number_of_gpus)\n        self.dict_max_memory_sharding = {\n            i: str(\n                int(\n                    mem * self.config.max_gpu_perc_to_use\n                )\n            ) + \"GiB\" for i, mem in\n            enumerate(self.device_rolling)\n        }\n        self.app.post(\"/chat\")(self.forward_chat_fast_api)\n        self.app.post(\"/instruct\")(self.forward_instruct_fast_api)\n        self.app.get(\"/status\")(self.status)\n        self.app = gr.mount_gradio_app(self.app, self.gradio_inference(), \"/gradio_chat\")\n\n    @staticmethod\n    def get_gpu_memory(num_gpus_req=None):\n\n        \"\"\"\n        The get_gpu_memory function returns the amount of available GPU memory in GB.\n\n        :param num_gpus_req: Specify the number of gpus to be used\n        :return: The amount of free memory on each gpu\n\n        \"\"\"\n        gpu_m = []\n        dc = torch.cuda.device_count()\n        num_gpus = torch.cuda.device_count() if num_gpus_req is None else min(num_gpus_req, dc)\n\n        for gpu_id in range(num_gpus):\n            with torch.cuda.device(gpu_id):\n                gpu_properties = torch.cuda.get_device_properties(torch.cuda.current_device())\n                gpu_m.append(\n                    (gpu_properties.total_memory / (1024 ** 3)) - (torch.cuda.memory_allocated() / (1024 ** 3)))\n        return gpu_m\n\n    def get_model_load_kwargs(self):\n        \"\"\"\n        The get_model_load_kwargs function is used to set the torch_dtype, device_map and max_memory parameters for loading a model.\n\n        :param self: Bind the method to an object\n        :return: A dictionary with the following keys:\n\n        \"\"\"\n        if self.config.dtype == \"fp16\":\n            dtype = torch.float16\n        elif self.config.dtype == \"fp32\":\n            dtype = torch.float32\n        elif self.config.dtype == \"bf16\":\n            dtype = torch.bfloat16\n        else:\n            raise ValueError(\"unknown type available types are [fp32 fp16 bf16]\")\n        load_kwargs = {\n            \"torch_dtype\": dtype,\n            \"device_map\": \"auto\",\n            \"max_memory\": self.dict_max_memory_sharding\n        }\n        return load_kwargs\n\n    def status(self):\n\n        \"\"\"\n        The status function returns a dictionary with the following keys:\n            config: A dictionary of configuration parameters.\n            devices: The number of GPUs available to the server.\n            device_sharding: Whether device sharding is enabled. If True, then each request will be served by\n            a different GPU (if multiple GPUs are available). If False, then all requests will be served by\n            the same GPU (or CPU if no GPUs are available). This parameter can also be set in your client\"s\n            initialization function via torch-serve\"s DeviceShardingStrategy\n            class. See https://pytorch-lightning.readthedoc\n\n        :param self: Represent the instance of the class\n        :return: A dictionary with the following keys:\n\n        \"\"\"\n        return {\n            \"config\": {k: v for k, v in self.config.__dict__.items()},\n            \"devices\": f\"{torch.cuda.device_count()}\",\n            \"device_sharding\": self.device_rolling,\n            \"max_memory\": self.dict_max_memory_sharding,\n            \"status\": \"Ready\",\n            \"number_of_served_request_until_last_up_time\": f\"{self.number_of_served_request_until_last_up_time}\"\n        }\n\n    def forward_instruct_fast_api(self, data: InstructRequest):\n        \"\"\"\n        The forward_instruct_fast_api function is a ReST API endpoint that takes in an InstructRequest object and returns\n        a response. The InstructRequest object contains the following fields:\n            - system (str): A string representing the name of the system to be instructed. This should match one of the\n                systems defined in your config file, or else it will default to &amp;quot;default&amp;quot;. If you want to instruct multiple\n                systems at once, use forward_instruct_fast instead.\n\n        :param self: Refer to the object itself\n        :param data: InstructRequest: Pass in the data that is used to generate the response\n        :return: A dictionary with a single key, response\n\n        \"\"\"\n        string = self.format_instruct(\n            system=data.system,\n            instruction=data.instruction\n        )\n        response = self.process(\n            string=string,\n            max_length=self.config.max_length,\n            temperature=data.temperature,\n            stream=False,\n            top_k=self.config.top_k,\n            top_p=self.config.top_p,\n            max_new_tokens=self.config.max_new_tokens\n        )\n        return {\n            \"response\": response\n        }\n\n    def forward_chat_fast_api(self, data: ChatRequest):\n        \"\"\"\n        The forward_chat_fast_api function is a ReST API endpoint that takes in a ChatRequest object and returns the response from the model.\n\n        :param self: Refer to the object itself\n        :param data: ChatRequest: Pass the data from the api to the function\n        :return: A dictionary with a single key, response\n\n        \"\"\"\n        string = self.format_chat(\n            system=data.system,\n            history=data.history,\n            prompt=data.prompt,\n        )\n        response = self.process(\n            string=string,\n            max_length=self.config.max_length,\n            temperature=data.temperature,\n            stream=False,\n            top_k=self.config.top_k,\n            top_p=self.config.top_p,\n            max_new_tokens=self.config.max_new_tokens\n        )\n        return {\n            \"response\": response\n        }\n\n    @staticmethod\n    def format_instruct(system: str, instruction: str) -&gt; str:\n        \"\"\"\n        The format_instruct function is used to format the instruction string\n            for a particular system.  The function takes two arguments:\n\n        :param system: str: Determine which system the instruction is for\n        :param instruction: str: Store the instruction that is being passed in\n        :return: The instruction in the format of the system\n\n        \"\"\"\n        raise NotImplementedError()\n\n    @staticmethod\n    def format_chat(history: List[List[str]], prompt: str, system: str = None) -&gt; str:\n        \"\"\"\n        The format_chat function takes a list of strings, representing the chat history,\n        and returns a string that is formatted in such a way that it can be printed to the screen.\n        The prompt argument is used to indicate which user's turn it currently is. The system argument\n        is used for messages from the system (e.g., &amp;quot;You are now connected!&amp;quot;). If no value for system\n        is provided, then this function should return None.\n\n        :param history: List[str]: Store the chat history\n        :param prompt: str: Display the prompt to the user\n        :param system: str: Add a system message to the chat history\n        :return: A string that contains the history of a chat\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def process(\n            self,\n            string: str,\n            max_new_tokens: int = None,\n            max_length: int = None,\n            temperature: float = 0.6,\n            top_k=50,\n            top_p=0.9,\n            stream: bool = True,\n            sample: bool = True\n    ):\n        \"\"\"\n        The process function is the main function of this class. It takes a string as input and returns a generator that yields strings.\n\n        :param self: Represent the instance of the class\n        :param string: str: Pass the string to be generated\n        :param max_new_tokens: int: Limit the number of new tokens that can be generated\n        :param max_length: int: Set the maximum length of the generated text\n        :param temperature: float: Control the randomness of the text generation\n        :param top_k: Filter out the top k tokens with the highest probability\n        :param top_p: Control the probability of sampling from the top n tokens\n        :param stream: bool: Determine whether to stream the output or not\n        :param sample: bool: Indicate whether to sample from the distribution or take the argmax\n        :return: A generator\n\n        \"\"\"\n        assert self.model is not None, \"you should first load model with ``load`` method\"\n        tokens = self.tokenizer(\n            string,\n            return_tensors=\"pt\"\n        )\n        input_ids = tokens.input_ids.to(self.model.device)\n        attention_mask = tokens.attention_mask.to(self.model.device)\n\n        iterator_streamer = TextIteratorStreamer(\n            tokenizer=self.tokenizer,\n            skip_prompt=True,\n            skip_special_tokens=True\n        )\n\n        if stream:\n            kwargs = dict(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                streamer=iterator_streamer,\n                generation_config=transformers.GenerationConfig(\n                    bos_token_id=self.tokenizer.bos_token_id,\n                    eos_token_id=self.tokenizer.eos_token_id,\n                    pad_token_id=self.tokenizer.pad_token_id,\n                    max_length=max_length or self.config.max_length,\n                    temperature=temperature,\n                    top_k=top_k,\n                    top_p=top_p,\n                    max_new_tokens=max_new_tokens or self.config.max_new_tokens,\n                    num_beams=1,\n                    do_sample=sample,\n                )\n            )\n            thread_ = threading.Thread(\n                target=self.model.generate,\n                kwargs=kwargs\n            )\n            thread_.start()\n            for string in iterator_streamer:\n                yield string\n        else:\n            kwargs = dict(\n                input_ids=input_ids,\n                attention_mask=attention_mask,\n                generation_config=transformers.GenerationConfig(\n                    bos_token_id=self.tokenizer.bos_token_id,\n                    eos_token_id=self.tokenizer.eos_token_id,\n                    pad_token_id=self.tokenizer.pad_token_id,\n                    max_length=max_length or self.config.max_length,\n                    temperature=temperature,\n                    top_k=top_k,\n                    top_p=top_p,\n                    max_new_tokens=max_new_tokens or self.config.max_new_tokens,\n                    num_beams=1\n                )\n            )\n            pred = self.tokenizer.decode(self.model.generate(\n                **kwargs\n            ).logits[0])\n            return pred\n\n    def load(self, pretrained_model_name_or_path: str, tokenizer_repo: str = None, auto_config: bool = True, **kwargs):\n        \"\"\"\n        The load function is used to load a model from the HuggingFace Model Hub.\n\n        :param self: Represent the instance of the class\n        :param pretrained_model_name_or_path: str: Specify the name of the model to be loaded\n        :param tokenizer_repo: str: Specify the repo id of the tokenizer\n        :param auto_config: bool: Determine whether the model should be loaded with a config file or not\n        :param kwargs: Pass a variable number of keyword arguments to the function\n        :return: A tuple of model and tokenizer\n\n        \"\"\"\n        load_kwargs = kwargs if not auto_config else self.get_model_load_kwargs()\n        load_kwargs = load_kwargs | kwargs\n        model = transformers.AutoModelForCausalLM.from_pretrained(\n            pretrained_model_name_or_path,\n            trust_remote_code=True,\n            **load_kwargs\n        )\n        tokenizer = transformers.AutoTokenizer.from_pretrained(\n            tokenizer_repo or pretrained_model_name_or_path,\n            trust_remote_code=True\n        )\n\n        self.model = model\n        self.tokenizer = tokenizer\n\n    def process_gradio(\n            self,\n            prompt: str,\n            history: List[List[str]],\n            system_prompt: str | None,\n            mode: str,\n            max_length: int,\n            max_new_tokens: int,\n            max_compile_tokens: int,\n            greedy: bool,\n            temperature: float,\n            top_p: float,\n            top_k: int\n    ):\n\n        if mode.lower() == \"chat\":\n            string = self.format_chat(\n                history=history,\n                system=system_prompt,\n                prompt=prompt\n            )\n        elif mode.lower() == \"instruct\":\n            history = []\n            string = self.format_instruct(\n                system=system_prompt,\n                instruction=prompt\n            )\n        else:\n            raise ValueError(\"UnKnown Mode for process_gradio available modes are only Chat or Instruct\")\n        history.append([prompt, \"\"])\n        responses = \"\"\n        for response in self.process(\n                string=string,\n                max_new_tokens=max_new_tokens,\n                temperature=temperature,\n                max_length=max_length,\n                top_p=top_p,\n                top_k=top_k,\n                stream=True\n        ):\n            responses += response\n            history[-1][-1] = responses\n            yield \"\", history\n\n    def gradio_inference(self):\n        return self.build_inference(\n            sample_func=self.process_gradio,\n            max_length=self.config.max_length,\n            max_new_tokens=self.config.max_new_tokens,\n            max_compile_tokens=1,\n        )\n\n    def fire(self):\n        \"\"\"\n        The fire function starts the uvicorn server in a separate process.\n\n        :param self: Represent the instance of the class\n        :return: A process that runs the uvicorn server\n\n        \"\"\"\n\n        def run():\n            uvicorn.run(self.app, host=self.config.host, port=self.config.port)\n\n        self.process_uvicorn = mp.Process(target=run)\n        self.process_uvicorn.start()\n\n    def end(self):\n        \"\"\"\n        The end function is used to stop the server.\n            It will wait for the process to end before returning.\n\n        :param self: Represent the instance of the class\n        :return: A boolean value\n\n        \"\"\"\n        if self.process_uvicorn is not None:\n            self.process_uvicorn.join()\n        else:\n            logging.warning(\"you have to fire server before ending that this command will be ignored\")\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.__init__","title":"<code>__init__(config)</code>","text":"<p>The init function is called when the class is instantiated. It sets up the instance of the class, and defines all its attributes. The init function can accept arguments, which are passed at instantiation.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>config</code> <code>PytorchServerConfig</code> <p>PytorchServerConfig: Pass the configuration parameters to the class</p> required <p>Returns:</p> Type Description <p>The app, which is a fastapi object</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def __init__(self, config: PytorchServerConfig):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up the instance of the class, and defines all its attributes.\n    The __init__ function can accept arguments, which are passed at instantiation.\n\n    :param self: Represent the instance of the class\n    :param config: PytorchServerConfig: Pass the configuration parameters to the class\n    :return: The app, which is a fastapi object\n\n    \"\"\"\n    self.model, self.tokenizer = [None] * 2\n\n    self.config = config\n    self.process_uvicorn = None\n    self.app = FastAPI()\n    self.number_of_served_request_until_last_up_time = 0\n    self.device_rolling = self.get_gpu_memory(self.config.max_number_of_gpus)\n    self.dict_max_memory_sharding = {\n        i: str(\n            int(\n                mem * self.config.max_gpu_perc_to_use\n            )\n        ) + \"GiB\" for i, mem in\n        enumerate(self.device_rolling)\n    }\n    self.app.post(\"/chat\")(self.forward_chat_fast_api)\n    self.app.post(\"/instruct\")(self.forward_instruct_fast_api)\n    self.app.get(\"/status\")(self.status)\n    self.app = gr.mount_gradio_app(self.app, self.gradio_inference(), \"/gradio_chat\")\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.end","title":"<code>end()</code>","text":"<p>The end function is used to stop the server.     It will wait for the process to end before returning.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A boolean value</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def end(self):\n    \"\"\"\n    The end function is used to stop the server.\n        It will wait for the process to end before returning.\n\n    :param self: Represent the instance of the class\n    :return: A boolean value\n\n    \"\"\"\n    if self.process_uvicorn is not None:\n        self.process_uvicorn.join()\n    else:\n        logging.warning(\"you have to fire server before ending that this command will be ignored\")\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.fire","title":"<code>fire()</code>","text":"<p>The fire function starts the uvicorn server in a separate process.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A process that runs the uvicorn server</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def fire(self):\n    \"\"\"\n    The fire function starts the uvicorn server in a separate process.\n\n    :param self: Represent the instance of the class\n    :return: A process that runs the uvicorn server\n\n    \"\"\"\n\n    def run():\n        uvicorn.run(self.app, host=self.config.host, port=self.config.port)\n\n    self.process_uvicorn = mp.Process(target=run)\n    self.process_uvicorn.start()\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.format_chat","title":"<code>format_chat(history, prompt, system=None)</code>  <code>staticmethod</code>","text":"<p>The format_chat function takes a list of strings, representing the chat history, and returns a string that is formatted in such a way that it can be printed to the screen. The prompt argument is used to indicate which user's turn it currently is. The system argument is used for messages from the system (e.g., \"You are now connected!\"). If no value for system is provided, then this function should return None.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>List[List[str]]</code> <p>List[str]: Store the chat history</p> required <code>prompt</code> <code>str</code> <p>str: Display the prompt to the user</p> required <code>system</code> <code>str</code> <p>str: Add a system message to the chat history</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string that contains the history of a chat</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>@staticmethod\ndef format_chat(history: List[List[str]], prompt: str, system: str = None) -&gt; str:\n    \"\"\"\n    The format_chat function takes a list of strings, representing the chat history,\n    and returns a string that is formatted in such a way that it can be printed to the screen.\n    The prompt argument is used to indicate which user's turn it currently is. The system argument\n    is used for messages from the system (e.g., &amp;quot;You are now connected!&amp;quot;). If no value for system\n    is provided, then this function should return None.\n\n    :param history: List[str]: Store the chat history\n    :param prompt: str: Display the prompt to the user\n    :param system: str: Add a system message to the chat history\n    :return: A string that contains the history of a chat\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.format_instruct","title":"<code>format_instruct(system, instruction)</code>  <code>staticmethod</code>","text":"<p>The format_instruct function is used to format the instruction string     for a particular system.  The function takes two arguments:</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>str</code> <p>str: Determine which system the instruction is for</p> required <code>instruction</code> <code>str</code> <p>str: Store the instruction that is being passed in</p> required <p>Returns:</p> Type Description <code>str</code> <p>The instruction in the format of the system</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>@staticmethod\ndef format_instruct(system: str, instruction: str) -&gt; str:\n    \"\"\"\n    The format_instruct function is used to format the instruction string\n        for a particular system.  The function takes two arguments:\n\n    :param system: str: Determine which system the instruction is for\n    :param instruction: str: Store the instruction that is being passed in\n    :return: The instruction in the format of the system\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.forward_chat_fast_api","title":"<code>forward_chat_fast_api(data)</code>","text":"<p>The forward_chat_fast_api function is a ReST API endpoint that takes in a ChatRequest object and returns the response from the model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>data</code> <code>ChatRequest</code> <p>ChatRequest: Pass the data from the api to the function</p> required <p>Returns:</p> Type Description <p>A dictionary with a single key, response</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def forward_chat_fast_api(self, data: ChatRequest):\n    \"\"\"\n    The forward_chat_fast_api function is a ReST API endpoint that takes in a ChatRequest object and returns the response from the model.\n\n    :param self: Refer to the object itself\n    :param data: ChatRequest: Pass the data from the api to the function\n    :return: A dictionary with a single key, response\n\n    \"\"\"\n    string = self.format_chat(\n        system=data.system,\n        history=data.history,\n        prompt=data.prompt,\n    )\n    response = self.process(\n        string=string,\n        max_length=self.config.max_length,\n        temperature=data.temperature,\n        stream=False,\n        top_k=self.config.top_k,\n        top_p=self.config.top_p,\n        max_new_tokens=self.config.max_new_tokens\n    )\n    return {\n        \"response\": response\n    }\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.forward_instruct_fast_api","title":"<code>forward_instruct_fast_api(data)</code>","text":"<p>The forward_instruct_fast_api function is a ReST API endpoint that takes in an InstructRequest object and returns a response. The InstructRequest object contains the following fields:     - system (str): A string representing the name of the system to be instructed. This should match one of the         systems defined in your config file, or else it will default to \"default\". If you want to instruct multiple         systems at once, use forward_instruct_fast instead.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <code>data</code> <code>InstructRequest</code> <p>InstructRequest: Pass in the data that is used to generate the response</p> required <p>Returns:</p> Type Description <p>A dictionary with a single key, response</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def forward_instruct_fast_api(self, data: InstructRequest):\n    \"\"\"\n    The forward_instruct_fast_api function is a ReST API endpoint that takes in an InstructRequest object and returns\n    a response. The InstructRequest object contains the following fields:\n        - system (str): A string representing the name of the system to be instructed. This should match one of the\n            systems defined in your config file, or else it will default to &amp;quot;default&amp;quot;. If you want to instruct multiple\n            systems at once, use forward_instruct_fast instead.\n\n    :param self: Refer to the object itself\n    :param data: InstructRequest: Pass in the data that is used to generate the response\n    :return: A dictionary with a single key, response\n\n    \"\"\"\n    string = self.format_instruct(\n        system=data.system,\n        instruction=data.instruction\n    )\n    response = self.process(\n        string=string,\n        max_length=self.config.max_length,\n        temperature=data.temperature,\n        stream=False,\n        top_k=self.config.top_k,\n        top_p=self.config.top_p,\n        max_new_tokens=self.config.max_new_tokens\n    )\n    return {\n        \"response\": response\n    }\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.get_gpu_memory","title":"<code>get_gpu_memory(num_gpus_req=None)</code>  <code>staticmethod</code>","text":"<p>The get_gpu_memory function returns the amount of available GPU memory in GB.</p> <p>Parameters:</p> Name Type Description Default <code>num_gpus_req</code> <p>Specify the number of gpus to be used</p> <code>None</code> <p>Returns:</p> Type Description <p>The amount of free memory on each gpu</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>@staticmethod\ndef get_gpu_memory(num_gpus_req=None):\n\n    \"\"\"\n    The get_gpu_memory function returns the amount of available GPU memory in GB.\n\n    :param num_gpus_req: Specify the number of gpus to be used\n    :return: The amount of free memory on each gpu\n\n    \"\"\"\n    gpu_m = []\n    dc = torch.cuda.device_count()\n    num_gpus = torch.cuda.device_count() if num_gpus_req is None else min(num_gpus_req, dc)\n\n    for gpu_id in range(num_gpus):\n        with torch.cuda.device(gpu_id):\n            gpu_properties = torch.cuda.get_device_properties(torch.cuda.current_device())\n            gpu_m.append(\n                (gpu_properties.total_memory / (1024 ** 3)) - (torch.cuda.memory_allocated() / (1024 ** 3)))\n    return gpu_m\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.get_model_load_kwargs","title":"<code>get_model_load_kwargs()</code>","text":"<p>The get_model_load_kwargs function is used to set the torch_dtype, device_map and max_memory parameters for loading a model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Bind the method to an object</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys:</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def get_model_load_kwargs(self):\n    \"\"\"\n    The get_model_load_kwargs function is used to set the torch_dtype, device_map and max_memory parameters for loading a model.\n\n    :param self: Bind the method to an object\n    :return: A dictionary with the following keys:\n\n    \"\"\"\n    if self.config.dtype == \"fp16\":\n        dtype = torch.float16\n    elif self.config.dtype == \"fp32\":\n        dtype = torch.float32\n    elif self.config.dtype == \"bf16\":\n        dtype = torch.bfloat16\n    else:\n        raise ValueError(\"unknown type available types are [fp32 fp16 bf16]\")\n    load_kwargs = {\n        \"torch_dtype\": dtype,\n        \"device_map\": \"auto\",\n        \"max_memory\": self.dict_max_memory_sharding\n    }\n    return load_kwargs\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.load","title":"<code>load(pretrained_model_name_or_path, tokenizer_repo=None, auto_config=True, **kwargs)</code>","text":"<p>The load function is used to load a model from the HuggingFace Model Hub.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>pretrained_model_name_or_path</code> <code>str</code> <p>str: Specify the name of the model to be loaded</p> required <code>tokenizer_repo</code> <code>str</code> <p>str: Specify the repo id of the tokenizer</p> <code>None</code> <code>auto_config</code> <code>bool</code> <p>bool: Determine whether the model should be loaded with a config file or not</p> <code>True</code> <code>kwargs</code> <p>Pass a variable number of keyword arguments to the function</p> <code>{}</code> <p>Returns:</p> Type Description <p>A tuple of model and tokenizer</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def load(self, pretrained_model_name_or_path: str, tokenizer_repo: str = None, auto_config: bool = True, **kwargs):\n    \"\"\"\n    The load function is used to load a model from the HuggingFace Model Hub.\n\n    :param self: Represent the instance of the class\n    :param pretrained_model_name_or_path: str: Specify the name of the model to be loaded\n    :param tokenizer_repo: str: Specify the repo id of the tokenizer\n    :param auto_config: bool: Determine whether the model should be loaded with a config file or not\n    :param kwargs: Pass a variable number of keyword arguments to the function\n    :return: A tuple of model and tokenizer\n\n    \"\"\"\n    load_kwargs = kwargs if not auto_config else self.get_model_load_kwargs()\n    load_kwargs = load_kwargs | kwargs\n    model = transformers.AutoModelForCausalLM.from_pretrained(\n        pretrained_model_name_or_path,\n        trust_remote_code=True,\n        **load_kwargs\n    )\n    tokenizer = transformers.AutoTokenizer.from_pretrained(\n        tokenizer_repo or pretrained_model_name_or_path,\n        trust_remote_code=True\n    )\n\n    self.model = model\n    self.tokenizer = tokenizer\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.process","title":"<code>process(string, max_new_tokens=None, max_length=None, temperature=0.6, top_k=50, top_p=0.9, stream=True, sample=True)</code>","text":"<p>The process function is the main function of this class. It takes a string as input and returns a generator that yields strings.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>string</code> <code>str</code> <p>str: Pass the string to be generated</p> required <code>max_new_tokens</code> <code>int</code> <p>int: Limit the number of new tokens that can be generated</p> <code>None</code> <code>max_length</code> <code>int</code> <p>int: Set the maximum length of the generated text</p> <code>None</code> <code>temperature</code> <code>float</code> <p>float: Control the randomness of the text generation</p> <code>0.6</code> <code>top_k</code> <p>Filter out the top k tokens with the highest probability</p> <code>50</code> <code>top_p</code> <p>Control the probability of sampling from the top n tokens</p> <code>0.9</code> <code>stream</code> <code>bool</code> <p>bool: Determine whether to stream the output or not</p> <code>True</code> <code>sample</code> <code>bool</code> <p>bool: Indicate whether to sample from the distribution or take the argmax</p> <code>True</code> <p>Returns:</p> Type Description <p>A generator</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def process(\n        self,\n        string: str,\n        max_new_tokens: int = None,\n        max_length: int = None,\n        temperature: float = 0.6,\n        top_k=50,\n        top_p=0.9,\n        stream: bool = True,\n        sample: bool = True\n):\n    \"\"\"\n    The process function is the main function of this class. It takes a string as input and returns a generator that yields strings.\n\n    :param self: Represent the instance of the class\n    :param string: str: Pass the string to be generated\n    :param max_new_tokens: int: Limit the number of new tokens that can be generated\n    :param max_length: int: Set the maximum length of the generated text\n    :param temperature: float: Control the randomness of the text generation\n    :param top_k: Filter out the top k tokens with the highest probability\n    :param top_p: Control the probability of sampling from the top n tokens\n    :param stream: bool: Determine whether to stream the output or not\n    :param sample: bool: Indicate whether to sample from the distribution or take the argmax\n    :return: A generator\n\n    \"\"\"\n    assert self.model is not None, \"you should first load model with ``load`` method\"\n    tokens = self.tokenizer(\n        string,\n        return_tensors=\"pt\"\n    )\n    input_ids = tokens.input_ids.to(self.model.device)\n    attention_mask = tokens.attention_mask.to(self.model.device)\n\n    iterator_streamer = TextIteratorStreamer(\n        tokenizer=self.tokenizer,\n        skip_prompt=True,\n        skip_special_tokens=True\n    )\n\n    if stream:\n        kwargs = dict(\n            input_ids=input_ids,\n            attention_mask=attention_mask,\n            streamer=iterator_streamer,\n            generation_config=transformers.GenerationConfig(\n                bos_token_id=self.tokenizer.bos_token_id,\n                eos_token_id=self.tokenizer.eos_token_id,\n                pad_token_id=self.tokenizer.pad_token_id,\n                max_length=max_length or self.config.max_length,\n                temperature=temperature,\n                top_k=top_k,\n                top_p=top_p,\n                max_new_tokens=max_new_tokens or self.config.max_new_tokens,\n                num_beams=1,\n                do_sample=sample,\n            )\n        )\n        thread_ = threading.Thread(\n            target=self.model.generate,\n            kwargs=kwargs\n        )\n        thread_.start()\n        for string in iterator_streamer:\n            yield string\n    else:\n        kwargs = dict(\n            input_ids=input_ids,\n            attention_mask=attention_mask,\n            generation_config=transformers.GenerationConfig(\n                bos_token_id=self.tokenizer.bos_token_id,\n                eos_token_id=self.tokenizer.eos_token_id,\n                pad_token_id=self.tokenizer.pad_token_id,\n                max_length=max_length or self.config.max_length,\n                temperature=temperature,\n                top_k=top_k,\n                top_p=top_p,\n                max_new_tokens=max_new_tokens or self.config.max_new_tokens,\n                num_beams=1\n            )\n        )\n        pred = self.tokenizer.decode(self.model.generate(\n            **kwargs\n        ).logits[0])\n        return pred\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PyTorchServer.status","title":"<code>status()</code>","text":"<p>The status function returns a dictionary with the following keys:     config: A dictionary of configuration parameters.     devices: The number of GPUs available to the server.     device_sharding: Whether device sharding is enabled. If True, then each request will be served by     a different GPU (if multiple GPUs are available). If False, then all requests will be served by     the same GPU (or CPU if no GPUs are available). This parameter can also be set in your client\"s     initialization function via torch-serve\"s DeviceShardingStrategy     class. See https://pytorch-lightning.readthedoc</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A dictionary with the following keys:</p> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>def status(self):\n\n    \"\"\"\n    The status function returns a dictionary with the following keys:\n        config: A dictionary of configuration parameters.\n        devices: The number of GPUs available to the server.\n        device_sharding: Whether device sharding is enabled. If True, then each request will be served by\n        a different GPU (if multiple GPUs are available). If False, then all requests will be served by\n        the same GPU (or CPU if no GPUs are available). This parameter can also be set in your client\"s\n        initialization function via torch-serve\"s DeviceShardingStrategy\n        class. See https://pytorch-lightning.readthedoc\n\n    :param self: Represent the instance of the class\n    :return: A dictionary with the following keys:\n\n    \"\"\"\n    return {\n        \"config\": {k: v for k, v in self.config.__dict__.items()},\n        \"devices\": f\"{torch.cuda.device_count()}\",\n        \"device_sharding\": self.device_rolling,\n        \"max_memory\": self.dict_max_memory_sharding,\n        \"status\": \"Ready\",\n        \"number_of_served_request_until_last_up_time\": f\"{self.number_of_served_request_until_last_up_time}\"\n    }\n</code></pre>"},{"location":"generated-serve-torch_serve/#lib.python.EasyDel.serve.torch_serve.PytorchServerConfig","title":"<code>PytorchServerConfig</code>  <code>dataclass</code>","text":"<p>It sets up the instance of the class, and defines all its attributes.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Specify the ip address of the server</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>Specify the port number that will be used by the server</p> <code>2059</code> <code>batch_size</code> <code>int</code> <p>Determine the number of samples to be generated in a single batch</p> <code>1</code> <code>contains_auto_format</code> <code>bool</code> <p>Determine whether the input text contains auto_formatting</p> <code>True</code> <code>max_length</code> <code>int</code> <p>Set the maximum length of a sentence</p> <code>2048</code> <code>max_new_tokens</code> <code>int</code> <p>Limit the number of new tokens that can be generated in a single batch</p> <code>2048</code> <code>temperature</code> <code>float</code> <p>Control the randomness of the generated text</p> <code>0.8</code> <code>top_p</code> <code>float</code> <p>Control the probability of sampling from the top candidates</p> <code>0.95</code> <code>top_k</code> <code>int</code> <p>Limit the number of tokens that are considered for each token</p> <code>50</code> <code>logging</code> <code>bool</code> <p>Control whether the server will print out</p> <code>True</code> <code>dtype</code> <code>str</code> <p>Specify the data type of the tensors</p> <code>'fp16'</code> <code>max_number_of_gpus</code> <code>Optional[int]</code> <p>Limit the number of gpus used by the server</p> <code>None</code> <code>max_gpu_perc_to_use</code> <code>float</code> <p>Specify the maximum percentage of gpu memory that can be used by the server</p> <code>0.95</code> <code>max_compile_tokens</code> <code>int</code> <p>int: Limit the number of tokens that can be streamed to a single client</p> <code>1</code> Source code in <code>lib/python/EasyDel/serve/torch_serve.py</code> <pre><code>@dataclass\nclass PytorchServerConfig:\n    \"\"\"\n    It sets up the instance of the class, and defines all its attributes.\n\n    :param host: Specify the ip address of the server\n    :param port: Specify the port number that will be used by the server\n    :param batch_size: Determine the number of samples to be generated in a single batch\n    :param contains_auto_format: Determine whether the input text contains auto_formatting\n    :param max_length: Set the maximum length of a sentence\n    :param max_new_tokens: Limit the number of new tokens that can be generated in a single batch\n    :param temperature: Control the randomness of the generated text\n    :param top_p: Control the probability of sampling from the top candidates\n    :param top_k: Limit the number of tokens that are considered for each token\n    :param logging: Control whether the server will print out\n    :param dtype: Specify the data type of the tensors\n    :param max_number_of_gpus: Limit the number of gpus used by the server\n    :param max_gpu_perc_to_use: Specify the maximum percentage of gpu memory that can be used by the server\n    :param max_compile_tokens: int: Limit the number of tokens that can be streamed to a single client\n    \"\"\"\n    host: str = \"0.0.0.0\"\n    port: int = 2059\n    batch_size: int = 1\n    contains_auto_format: bool = True\n    max_length: int = 2048\n    max_new_tokens: int = 2048\n    temperature: float = 0.8\n    top_p: float = 0.95\n    top_k: int = 50\n    logging: bool = True\n    dtype: str = \"fp16\"\n    max_number_of_gpus: typing.Optional[int] = None\n    max_gpu_perc_to_use: float = 0.95\n    max_compile_tokens: int = 1\n</code></pre>"},{"location":"generated-serve-utils/","title":"serve.utils","text":""},{"location":"generated-serve-utils/#lib.python.EasyDel.serve.utils.Seafoam","title":"<code>Seafoam</code>","text":"<p>             Bases: <code>Base</code></p> Source code in <code>lib/python/EasyDel/serve/utils.py</code> <pre><code>class Seafoam(Base):\n    def __init__(\n            self,\n            *,\n            primary_hue: Union[colors.Color, str] = colors.emerald,\n            secondary_hue: Union[colors.Color, str] = colors.blue,\n            neutral_hue: Union[colors.Color, str] = colors.gray,\n            spacing_size: Union[sizes.Size, str] = sizes.spacing_md,\n            radius_size: Union[sizes.Size, str] = sizes.radius_md,\n            text_size: Union[sizes.Size, str] = sizes.text_lg,\n            font: Union[fonts.Font, str]\n            = (\n                    fonts.GoogleFont(\"Quicksand\"),\n                    \"ui-sans-serif\",\n                    \"sans-serif\",\n            ),\n            font_mono: Union[fonts.Font, str]\n            = (\n                    fonts.GoogleFont(\"IBM Plex Mono\"),\n                    \"ui-monospace\",\n                    \"monospace\",\n            ),\n    ):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the object with all of its instance variables and other things it needs to function properly.\n\n\n        :param self: Represent the instance of the object\n        :param *: Unpack the list of parameters into a tuple\n        :param primary_hue: Union[colors.Color,str]: Set the primary color of the theme\n        :param secondary_hue: Union[colors.Color,str]: Set the secondary color of the theme\n        :param neutral_hue: Union[colors.Color,str]: Set the neutral color of the theme\n        :param spacing_size: Union[sizes.Size,str]: Set the spacing size of the theme\n        :param radius_size: Union[sizes.Size,str]: Set the radius of the buttons and other elements\n        :param text_size: Union[sizes.Size,str]: Set the size of the text in the app\n\n        :return: The class object\n\n        \"\"\"\n\n        super().__init__(\n            primary_hue=primary_hue,\n            secondary_hue=secondary_hue,\n            neutral_hue=neutral_hue,\n            spacing_size=spacing_size,\n            radius_size=radius_size,\n            text_size=text_size,\n            font=font,\n            font_mono=font_mono,\n\n        )\n        super().set(\n            body_background_fill=\"linear-gradient(90deg, *secondary_800, *neutral_900)\",\n            body_background_fill_dark=\"linear-gradient(90deg, *secondary_800, *neutral_900)\",\n            button_primary_background_fill=\"linear-gradient(90deg, *primary_300, *secondary_400)\",\n            button_primary_background_fill_hover=\"linear-gradient(90deg, *primary_200, *secondary_300)\",\n            button_primary_text_color=\"white\",\n            button_primary_background_fill_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            slider_color=\"*secondary_300\",\n            slider_color_dark=\"*secondary_400\",\n            block_title_text_weight=\"600\",\n            block_border_width=\"0px\",\n            block_shadow=\"*shadow_drop_lg\",\n            button_shadow=\"*shadow_drop_lg\",\n            button_large_padding=\"4px\",\n            border_color_primary=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            border_color_primary_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            table_border_color=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            table_border_color_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            button_primary_border_color=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            button_primary_border_color_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            panel_border_color=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            panel_border_color_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            block_border_color=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n            block_border_color_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\"\n        )\n</code></pre>"},{"location":"generated-serve-utils/#lib.python.EasyDel.serve.utils.Seafoam.__init__","title":"<code>__init__(*, primary_hue=colors.emerald, secondary_hue=colors.blue, neutral_hue=colors.gray, spacing_size=sizes.spacing_md, radius_size=sizes.radius_md, text_size=sizes.text_lg, font=(fonts.GoogleFont('Quicksand'), 'ui-sans-serif', 'sans-serif'), font_mono=(fonts.GoogleFont('IBM Plex Mono'), 'ui-monospace', 'monospace'))</code>","text":"<p>The init function is called when the class is instantiated. It sets up the object with all of its instance variables and other things it needs to function properly.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the object</p> required <code>*</code> <p>Unpack the list of parameters into a tuple</p> required <code>primary_hue</code> <code>Union[Color, str]</code> <p>Union[colors.Color,str]: Set the primary color of the theme</p> <code>emerald</code> <code>secondary_hue</code> <code>Union[Color, str]</code> <p>Union[colors.Color,str]: Set the secondary color of the theme</p> <code>blue</code> <code>neutral_hue</code> <code>Union[Color, str]</code> <p>Union[colors.Color,str]: Set the neutral color of the theme</p> <code>gray</code> <code>spacing_size</code> <code>Union[Size, str]</code> <p>Union[sizes.Size,str]: Set the spacing size of the theme</p> <code>spacing_md</code> <code>radius_size</code> <code>Union[Size, str]</code> <p>Union[sizes.Size,str]: Set the radius of the buttons and other elements</p> <code>radius_md</code> <code>text_size</code> <code>Union[Size, str]</code> <p>Union[sizes.Size,str]: Set the size of the text in the app</p> <code>text_lg</code> <p>Returns:</p> Type Description <p>The class object</p> Source code in <code>lib/python/EasyDel/serve/utils.py</code> <pre><code>def __init__(\n        self,\n        *,\n        primary_hue: Union[colors.Color, str] = colors.emerald,\n        secondary_hue: Union[colors.Color, str] = colors.blue,\n        neutral_hue: Union[colors.Color, str] = colors.gray,\n        spacing_size: Union[sizes.Size, str] = sizes.spacing_md,\n        radius_size: Union[sizes.Size, str] = sizes.radius_md,\n        text_size: Union[sizes.Size, str] = sizes.text_lg,\n        font: Union[fonts.Font, str]\n        = (\n                fonts.GoogleFont(\"Quicksand\"),\n                \"ui-sans-serif\",\n                \"sans-serif\",\n        ),\n        font_mono: Union[fonts.Font, str]\n        = (\n                fonts.GoogleFont(\"IBM Plex Mono\"),\n                \"ui-monospace\",\n                \"monospace\",\n        ),\n):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up the object with all of its instance variables and other things it needs to function properly.\n\n\n    :param self: Represent the instance of the object\n    :param *: Unpack the list of parameters into a tuple\n    :param primary_hue: Union[colors.Color,str]: Set the primary color of the theme\n    :param secondary_hue: Union[colors.Color,str]: Set the secondary color of the theme\n    :param neutral_hue: Union[colors.Color,str]: Set the neutral color of the theme\n    :param spacing_size: Union[sizes.Size,str]: Set the spacing size of the theme\n    :param radius_size: Union[sizes.Size,str]: Set the radius of the buttons and other elements\n    :param text_size: Union[sizes.Size,str]: Set the size of the text in the app\n\n    :return: The class object\n\n    \"\"\"\n\n    super().__init__(\n        primary_hue=primary_hue,\n        secondary_hue=secondary_hue,\n        neutral_hue=neutral_hue,\n        spacing_size=spacing_size,\n        radius_size=radius_size,\n        text_size=text_size,\n        font=font,\n        font_mono=font_mono,\n\n    )\n    super().set(\n        body_background_fill=\"linear-gradient(90deg, *secondary_800, *neutral_900)\",\n        body_background_fill_dark=\"linear-gradient(90deg, *secondary_800, *neutral_900)\",\n        button_primary_background_fill=\"linear-gradient(90deg, *primary_300, *secondary_400)\",\n        button_primary_background_fill_hover=\"linear-gradient(90deg, *primary_200, *secondary_300)\",\n        button_primary_text_color=\"white\",\n        button_primary_background_fill_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        slider_color=\"*secondary_300\",\n        slider_color_dark=\"*secondary_400\",\n        block_title_text_weight=\"600\",\n        block_border_width=\"0px\",\n        block_shadow=\"*shadow_drop_lg\",\n        button_shadow=\"*shadow_drop_lg\",\n        button_large_padding=\"4px\",\n        border_color_primary=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        border_color_primary_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        table_border_color=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        table_border_color_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        button_primary_border_color=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        button_primary_border_color_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        panel_border_color=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        panel_border_color_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        block_border_color=\"linear-gradient(90deg, *primary_600, *secondary_800)\",\n        block_border_color_dark=\"linear-gradient(90deg, *primary_600, *secondary_800)\"\n    )\n</code></pre>"},{"location":"generated-smi-smi/","title":"smi.smi","text":""},{"location":"generated-smi-smi/#lib.python.EasyDel.smi.smi.get_mem","title":"<code>get_mem(dir_prefix='/dev/shm')</code>","text":"<p>The get_mem function is a wrapper around the go tool pprof command. It takes in an optional argument, dir_prefix, which defaults to /dev/shm. The function then runs the go tool pprof command with arguments -tags and dir_prefix/memory.prof, and returns its stdout as a string.</p> <p>Parameters:</p> Name Type Description Default <code>dir_prefix</code> <code>str</code> <p>str: Specify the directory where</p> <code>'/dev/shm'</code> <p>Returns:</p> Type Description <p>A string of the memory profile</p> Source code in <code>lib/python/EasyDel/smi/smi.py</code> <pre><code>def get_mem(dir_prefix: str = '/dev/shm'):\n    \"\"\"\n    The get_mem function is a wrapper around the go tool pprof command.\n    It takes in an optional argument, dir_prefix, which defaults to /dev/shm.\n    The function then runs the go tool pprof command with arguments -tags and dir_prefix/memory.prof,\n    and returns its stdout as a string.\n\n    :param dir_prefix: str: Specify the directory where\n    :return: A string of the memory profile\n\n    \"\"\"\n    return subprocess.run(\n        args=['go', 'tool', 'pprof', '-tags', f'{dir_prefix}/memory.prof'],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.DEVNULL,\n    ).stdout.decode('utf-8')\n</code></pre>"},{"location":"generated-smi-smi/#lib.python.EasyDel.smi.smi.initialise_tracking","title":"<code>initialise_tracking(interval=0.5, dir_prefix='/dev/shm')</code>","text":"<p>The initialise_tracking function starts a daemon thread that periodically saves the current memory profile to disk.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>float: Specify the time interval between each memory profile</p> <code>0.5</code> <code>dir_prefix</code> <code>str</code> <p>str: Specify the directory where the memory profile will be saved</p> <code>'/dev/shm'</code> <p>Returns:</p> Type Description <code>None</code> <p>Nothing, but it starts a thread that</p> Source code in <code>lib/python/EasyDel/smi/smi.py</code> <pre><code>def initialise_tracking(interval: float = 0.5, dir_prefix: str = '/dev/shm') -&gt; None:\n    \"\"\"\n    The initialise_tracking function starts a daemon thread that periodically saves the current memory profile to disk.\n\n    :param interval: float: Specify the time interval between each memory profile\n    :param dir_prefix: str: Specify the directory where the memory profile will be saved\n    :return: Nothing, but it starts a thread that\n\n    \"\"\"\n\n    def inner():\n        while True:\n            jax.profiler.save_device_memory_profile(f'{dir_prefix}/memory.prof.new')\n            os.rename(f'{dir_prefix}/memory.prof.new', f'{dir_prefix}/memory.prof')\n            time.sleep(interval)\n\n    thread = threading.Thread(target=inner, daemon=True)\n    thread.start()\n</code></pre>"},{"location":"generated-smi-smi/#lib.python.EasyDel.smi.smi.run","title":"<code>run(note_book=None, interval=1, dir_prefix='/dev/shm', dpr=True)</code>","text":"<p>The run function is a simple wrapper around the go tool pprof command. It runs the command every interval seconds and prints out its output to stdout. If you are running this in a notebook, it will print to IPython's display instead of stdout.</p> <p>Parameters:</p> Name Type Description Default <code>note_book</code> <p>Determine whether the program is running in a notebook or not</p> <code>None</code> <code>interval</code> <code>float</code> <p>float: Specify the time interval between each refresh</p> <code>1</code> <code>dir_prefix</code> <code>str</code> <p>str: Specify the directory where the memory</p> <code>'/dev/shm'</code> <code>dpr</code> <p>Control whether the output is displayed in a notebook or not</p> <code>True</code> <p>Returns:</p> Type Description <p>The output of the pprof command</p> Source code in <code>lib/python/EasyDel/smi/smi.py</code> <pre><code>def run(note_book=None, interval: float = 1, dir_prefix: str = '/dev/shm', dpr=True):\n    \"\"\"\n    The run function is a simple wrapper around the go tool pprof command.\n    It runs the command every interval seconds and prints out its output to stdout.\n    If you are running this in a notebook, it will print to IPython's display instead of stdout.\n\n\n    :param note_book: Determine whether the program is running in a notebook or not\n    :param interval: float: Specify the time interval between each refresh\n    :param dir_prefix: str: Specify the directory where the memory\n    :param dpr: Control whether the output is displayed in a notebook or not\n    :return: The output of the pprof command\n\n    \"\"\"\n    if note_book is None:\n        import os\n\n        def is_notebook():\n            \"\"\"Returns True if the code is being run in a notebook, False otherwise.\"\"\"\n            return os.environ.get(\"IPYTHON\") is not None\n\n        note_book = is_notebook()\n    std = curses.initscr() if not note_book else None\n    try:\n        while True:\n            if not note_book and dpr:\n                std.clear()\n            output = subprocess.run(\n                args=['go', 'tool', 'pprof', '-tags', f'{dir_prefix}/memory.prof'],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.DEVNULL,\n            ).stdout.decode('utf-8')\n            if not note_book and dpr:\n                std.addstr(output)\n                std.refresh()\n            if note_book and dpr:\n                IPython.display.clear_output(True)\n                print(output)\n\n            with open(f'{dir_prefix}/memory.json', 'w') as fin:\n                json.dump({\n                    'log': output\n                }, fin)\n            time.sleep(interval)\n    except KeyboardInterrupt:\n        curses.endwin()\n</code></pre>"},{"location":"generated-trainer-base_trainer/","title":"trainer.base_trainer","text":""},{"location":"generated-trainer-base_trainer/#lib.python.EasyDel.trainer.base_trainer.BaseTrainer","title":"<code>BaseTrainer</code>","text":"Source code in <code>lib/python/EasyDel/trainer/base_trainer.py</code> <pre><code>class BaseTrainer:\n    def __init__(\n            self,\n            arguments: TrainArguments,\n            dataset_train: Dataset,\n            dataset_eval: Dataset = None,\n            finetune: bool = True,\n            checkpoint_path: Union[str, os.PathLike] = None,\n            _do_init_fns: bool = True\n    ):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up all the variables that are needed for training, including:\n        - The timer to keep track of how long each epoch takes.\n        - The dataloaders for both training and evaluation (if provided).\n        - The model itself, which will be created from a checkpoint if one was provided.  Otherwise,\n         it will be created from scratch using the arguments passed in by the user.\n         Note that this function also handles creating a mesh if one was not already specified in arguments\n         or loaded from a checkpoint file (see below).\n          This means that you can pass in either\n\n        :param self: Represent the instance of the class\n        :param arguments: TrainArguments: Pass the arguments to the trainer\n        :param dataset_train: Dataset: Pass the training dataset to the trainer\n        :param dataset_eval: Dataset: Pass the validation dataset\n        :param finetune: bool: Load the model from a checkpoint\n        :param checkpoint_path: Union[str,os.PathLike] : Load the checkpoint path\n        :param _do_init_fns: bool: Initialize the functions\n        :return: Nothing, it just initializes the class\n\n        \"\"\"\n        # Loggers\n        self.timer = None\n        self.wandb_runtime: Run | RunDisabled | None = None\n\n        # Data\n        self.dataloader_train = None\n        self.dataloader_eval = None\n        self.max_training_steps = None\n        self.max_evaluation_steps = None\n        self.dataset_train = dataset_train\n        self.dataset_eval = dataset_eval\n\n        # Model Related\n        self.model = None\n        self.config = None\n        self.scheduler = None\n        self.tx = None\n\n        # LoRA Related\n        self.rapture = arguments.rapture\n        self.lora_parameters = None\n        self.lora_model = None\n        self.lora_tx = None\n        self.lora_opt_state = None\n        self.lora_apply_fn = None\n\n        # PJit functions\n        self.create_sharded_state_from_params_function = None\n        self.sharded_train_step_function = None\n        self.initialize_state_function = None\n        self.mesh = None\n\n        # Checkpoint Managers\n        self.checkpoint_manager: fjformer.CheckpointManager | None = None\n\n        # EasyState\n        self.state_shape = None\n        self.state_partition_spec = None\n        self.sharded_state = None\n\n        # Rest\n\n        self.arguments = arguments\n        self.finetune = finetune\n        self.checkpoint_path = checkpoint_path\n        self.dtype = arguments.dtype\n        self.param_dtype = arguments.param_dtype\n\n        if finetune:\n            if checkpoint_path is None:\n                prefix_print(\n                    \"Warning\",\n                    \"In case of using `finetune = True` and Passing `checkpoint_path = None`\"\n                    \" you should pass parameters in train function\"\n                )\n        if _do_init_fns:\n            self.initialize_trainer_utils()\n        else:\n            prefix_print(\n                \"Warning\",\n                \"you have set `_do_init_fns = False` so function will not me initialized you have \"\n                f\"to do in manually (simply with `trainer.initialize_trainer_utils()` )\"\n            )\n\n    def __str__(self):\n        string = f\"{self.__class__.__name__}(\"\n        for key, value in self.__dict__.items():\n            string += value.__str__().replace(\"\\n\", \"\\n\\t\")\n        string += \")\"\n        return string\n\n    def __repr__(self):\n        return self.__str__()\n\n    @staticmethod\n    def finish():\n        \"\"\"\n        The finish function is called when the experiment ends.\n        It can be used to save data, upload files, or do any other cleanup tasks.\n\n        :return: A dictionary of the run's metadata\n\n        \"\"\"\n        wandb.finish()\n\n    def initialize_trainer_utils(self):\n        \"\"\"\n        The initialize_trainer_utils function is responsible for initializing the following:\n            - wandb_runtime (if you use_wandb is True)\n            - timer object (for logging time taken by various functions)\n            - dataloader objects for training and evaluation data, along with max steps per epoch.\n              The configure_dataloader function accomplishes this task.\n\n        :param self: Represent the instance of the class\n        :return: A tuple of functions\n\n        \"\"\"\n        self.wandb_runtime = self.arguments.get_wandb_init() if self.arguments.use_wandb else None\n        self.timer = Timers(\n            use_wandb=False,\n            tensorboard_writer=self.arguments.get_board()\n        )\n\n        self.timer(\"configure dataloaders\").start()\n        dataset_configurations = self.configure_dataloader()\n        self.dataloader_train = dataset_configurations.dataloader_train\n        self.max_training_steps = dataset_configurations.max_training_steps\n        self.dataloader_eval = dataset_configurations.dataloader_eval\n        self.max_evaluation_steps = dataset_configurations.max_evaluation_steps\n\n        self.timer(\"configure dataloaders\").stop()\n\n        self.timer.log([\"configure dataloaders\"])\n\n        self.timer(\"configure Model ,Optimizer ,Scheduler and Config\").start()\n        model_configurations = self.configure_model()\n        model = model_configurations.model\n        tx = model_configurations.tx\n        scheduler = model_configurations.scheduler\n        config = model_configurations.config\n        self.model = model\n        self.tx = tx\n        self.scheduler = scheduler\n        self.config = config\n        if self.rapture is not None:\n            lora_modules = self.rapture.apply_lora(\n                module=model,\n                parameters=self.arguments.rapture_config.parameters,\n                tx=tx,\n            )\n            self.lora_parameters = lora_modules.lora_parameters\n            self.lora_apply_fn = lora_modules.lora_module.__call__\n            self.lora_opt_state = lora_modules.lora_opt_state\n            self.lora_model = lora_modules.lora_module\n            self.lora_tx = lora_modules.lora_tx\n\n        self.timer(\"configure Model ,Optimizer ,Scheduler and Config\").stop()\n        self.timer.log([\"configure Model ,Optimizer ,Scheduler and Config\"])\n        self.timer(\"configure functions and sharding them\").start()\n        function_configurations = self.configure_functions()\n        self.create_sharded_state_from_params_function = \\\n            function_configurations.create_sharded_state_from_params_function\n        self.sharded_train_step_function = function_configurations.sharded_train_step_function\n        self.mesh = function_configurations.mesh\n        self.checkpoint_manager = function_configurations.checkpoint_manager\n        self.initialize_state_function = function_configurations.initialize_state_function\n        self.timer(\"configure functions and sharding them\").stop()\n        self.timer.log([\"configure functions and sharding them\"])\n\n    @abstractmethod\n    def create_collate_function(\n            self,\n            max_sequence_length: int,\n            is_left_padded: bool\n    ) -&gt; Callable:\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def configure_functions(self) -&gt; TrainerConfigureFunctionFuncOutput:\n        \"\"\"\n        The configure_functions function is responsible for configuring the functions that will be used in training.\n        It does this by first defining a function called function_configurations, which initializes the model parameters and returns\n        them as a EasyDelState object. The EasyDelState object contains all the information needed to train or evaluate\n        on a batch of data, including:\n        :param self: Access the class attributes\n        :return: A TrainerConfigureFunctionFuncOutput object\n\n        \"\"\"\n        raise NotImplementedError\n\n    def configure_dataloader(self) -&gt; TrainerConfigureDataloaderFuncOutput:\n\n        \"\"\"\n        The configure_dataloader function is used to configure the dataloader for training and evaluation.\n\n        :param self: Refer to the class instance itself\n        :return: A TrainerConfigureDataloaderFuncOutput object\n\n        \"\"\"\n\n        dataloader_train = DataLoader(\n            self.dataset_train,\n            collate_fn=self.create_collate_function(\n                max_sequence_length=self.arguments.max_sequence_length,\n                is_left_padded=self.arguments.is_left_padded\n            ),\n            batch_size=self.arguments.total_batch_size,\n            drop_last=True,\n        )\n        max_training_steps = self.arguments.num_train_epochs * len(\n            dataloader_train\n        ) if self.arguments.max_training_steps is None else self.arguments.max_training_steps\n        if self.dataset_eval is not None and self.arguments.do_eval:\n            dataloader_eval = DataLoader(\n                self.dataset_eval,\n                collate_fn=self.create_collate_function(\n                    max_sequence_length=self.arguments.max_sequence_length,\n                    is_left_padded=self.arguments.is_left_padded\n                ),\n                batch_size=self.arguments.total_batch_size,\n                drop_last=True\n            )\n            max_evaluation_steps = len(\n                dataloader_eval) if self.arguments.max_training_steps is None else self.arguments.max_training_steps\n        else:\n            dataloader_eval, max_evaluation_steps = None, 0\n\n        return TrainerConfigureDataloaderFuncOutput(\n            dataloader_train=dataloader_train,\n            max_training_steps=max_training_steps,\n            dataloader_eval=dataloader_eval,\n            max_evaluation_steps=max_evaluation_steps\n        )\n\n    def configure_model(self) -&gt; TrainerConfigureModelFuncOutput:\n        \"\"\"\n        The configure_model function is responsible for creating the model, optimizer and scheduler.\n\n        :param self: Represent the instance of the class\n        :return: A model, optimizer, scheduler and config  in TrainerConfigureModelFuncOutput Object\n\n        \"\"\"\n        extra_configs = {} if self.arguments.extra_configs is None else self.arguments.extra_configs\n        if self.arguments.model_class is not None:\n\n            if not hasattr(self.arguments.configs_to_initialize_model_class[\"config\"], \"get_partition_rules\"):\n                assert self.arguments.custom_rule is not None, (\n                    \"if you are using custom model to init you must\"\n                    \" pass custom_rule for partition rules \"\n                )\n\n            self.arguments.configs_to_initialize_model_class[\n                \"config\"\n            ].use_pjit_attention_force = self.arguments.use_pjit_attention_force\n\n            self.arguments.configs_to_initialize_model_class[\"config\"].axis_dims = self.arguments.sharding_array\n\n            model = self.arguments.model_class(\n                **self.arguments.configs_to_initialize_model_class,\n                _do_init=False\n            )\n\n            config = self.arguments.configs_to_initialize_model_class[\"config\"]\n\n        else:\n            extra_configs[\"gradient_checkpointing\"] = self.arguments.gradient_checkpointing\n            extra_configs[\"use_pjit_attention_force\"] = self.arguments.use_pjit_attention_force\n\n            model = AutoEasyDelModelForCausalLM.from_pretrained(\n                self.arguments.model_huggingface_repo_id,\n                dtype=self.arguments.dtype,\n                param_dtype=self.arguments.param_dtype,\n                _do_init=False\n            )\n            if hasattr(model, \"config\"):\n                for k, v in extra_configs.items():\n                    setattr(model.config, k, v)\n                config = model.config\n            else:\n                config = None\n                warnings.warn(\n                    \"Config is being set to None due to not detecting Model Configuration from taken Model \"\n                    \"this will cause errors later.\"\n                )\n        tx, scheduler = self.arguments.get_optimizer_and_scheduler(self.max_training_steps)\n        return TrainerConfigureModelFuncOutput(\n            model=model,\n            tx=tx,\n            scheduler=scheduler,\n            config=config\n        )\n</code></pre>"},{"location":"generated-trainer-base_trainer/#lib.python.EasyDel.trainer.base_trainer.BaseTrainer.__init__","title":"<code>__init__(arguments, dataset_train, dataset_eval=None, finetune=True, checkpoint_path=None, _do_init_fns=True)</code>","text":"<p>The init function is called when the class is instantiated. It sets up all the variables that are needed for training, including: - The timer to keep track of how long each epoch takes. - The dataloaders for both training and evaluation (if provided). - The model itself, which will be created from a checkpoint if one was provided.  Otherwise,  it will be created from scratch using the arguments passed in by the user.  Note that this function also handles creating a mesh if one was not already specified in arguments  or loaded from a checkpoint file (see below).   This means that you can pass in either</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>arguments</code> <code>TrainArguments</code> <p>TrainArguments: Pass the arguments to the trainer</p> required <code>dataset_train</code> <code>Dataset</code> <p>Dataset: Pass the training dataset to the trainer</p> required <code>dataset_eval</code> <code>Dataset</code> <p>Dataset: Pass the validation dataset</p> <code>None</code> <code>finetune</code> <code>bool</code> <p>bool: Load the model from a checkpoint</p> <code>True</code> <code>checkpoint_path</code> <code>Union[str, PathLike]</code> <p>Union[str,os.PathLike] : Load the checkpoint path</p> <code>None</code> <code>_do_init_fns</code> <code>bool</code> <p>bool: Initialize the functions</p> <code>True</code> <p>Returns:</p> Type Description <p>Nothing, it just initializes the class</p> Source code in <code>lib/python/EasyDel/trainer/base_trainer.py</code> <pre><code>def __init__(\n        self,\n        arguments: TrainArguments,\n        dataset_train: Dataset,\n        dataset_eval: Dataset = None,\n        finetune: bool = True,\n        checkpoint_path: Union[str, os.PathLike] = None,\n        _do_init_fns: bool = True\n):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up all the variables that are needed for training, including:\n    - The timer to keep track of how long each epoch takes.\n    - The dataloaders for both training and evaluation (if provided).\n    - The model itself, which will be created from a checkpoint if one was provided.  Otherwise,\n     it will be created from scratch using the arguments passed in by the user.\n     Note that this function also handles creating a mesh if one was not already specified in arguments\n     or loaded from a checkpoint file (see below).\n      This means that you can pass in either\n\n    :param self: Represent the instance of the class\n    :param arguments: TrainArguments: Pass the arguments to the trainer\n    :param dataset_train: Dataset: Pass the training dataset to the trainer\n    :param dataset_eval: Dataset: Pass the validation dataset\n    :param finetune: bool: Load the model from a checkpoint\n    :param checkpoint_path: Union[str,os.PathLike] : Load the checkpoint path\n    :param _do_init_fns: bool: Initialize the functions\n    :return: Nothing, it just initializes the class\n\n    \"\"\"\n    # Loggers\n    self.timer = None\n    self.wandb_runtime: Run | RunDisabled | None = None\n\n    # Data\n    self.dataloader_train = None\n    self.dataloader_eval = None\n    self.max_training_steps = None\n    self.max_evaluation_steps = None\n    self.dataset_train = dataset_train\n    self.dataset_eval = dataset_eval\n\n    # Model Related\n    self.model = None\n    self.config = None\n    self.scheduler = None\n    self.tx = None\n\n    # LoRA Related\n    self.rapture = arguments.rapture\n    self.lora_parameters = None\n    self.lora_model = None\n    self.lora_tx = None\n    self.lora_opt_state = None\n    self.lora_apply_fn = None\n\n    # PJit functions\n    self.create_sharded_state_from_params_function = None\n    self.sharded_train_step_function = None\n    self.initialize_state_function = None\n    self.mesh = None\n\n    # Checkpoint Managers\n    self.checkpoint_manager: fjformer.CheckpointManager | None = None\n\n    # EasyState\n    self.state_shape = None\n    self.state_partition_spec = None\n    self.sharded_state = None\n\n    # Rest\n\n    self.arguments = arguments\n    self.finetune = finetune\n    self.checkpoint_path = checkpoint_path\n    self.dtype = arguments.dtype\n    self.param_dtype = arguments.param_dtype\n\n    if finetune:\n        if checkpoint_path is None:\n            prefix_print(\n                \"Warning\",\n                \"In case of using `finetune = True` and Passing `checkpoint_path = None`\"\n                \" you should pass parameters in train function\"\n            )\n    if _do_init_fns:\n        self.initialize_trainer_utils()\n    else:\n        prefix_print(\n            \"Warning\",\n            \"you have set `_do_init_fns = False` so function will not me initialized you have \"\n            f\"to do in manually (simply with `trainer.initialize_trainer_utils()` )\"\n        )\n</code></pre>"},{"location":"generated-trainer-base_trainer/#lib.python.EasyDel.trainer.base_trainer.BaseTrainer.configure_dataloader","title":"<code>configure_dataloader()</code>","text":"<p>The configure_dataloader function is used to configure the dataloader for training and evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the class instance itself</p> required <p>Returns:</p> Type Description <code>TrainerConfigureDataloaderFuncOutput</code> <p>A TrainerConfigureDataloaderFuncOutput object</p> Source code in <code>lib/python/EasyDel/trainer/base_trainer.py</code> <pre><code>def configure_dataloader(self) -&gt; TrainerConfigureDataloaderFuncOutput:\n\n    \"\"\"\n    The configure_dataloader function is used to configure the dataloader for training and evaluation.\n\n    :param self: Refer to the class instance itself\n    :return: A TrainerConfigureDataloaderFuncOutput object\n\n    \"\"\"\n\n    dataloader_train = DataLoader(\n        self.dataset_train,\n        collate_fn=self.create_collate_function(\n            max_sequence_length=self.arguments.max_sequence_length,\n            is_left_padded=self.arguments.is_left_padded\n        ),\n        batch_size=self.arguments.total_batch_size,\n        drop_last=True,\n    )\n    max_training_steps = self.arguments.num_train_epochs * len(\n        dataloader_train\n    ) if self.arguments.max_training_steps is None else self.arguments.max_training_steps\n    if self.dataset_eval is not None and self.arguments.do_eval:\n        dataloader_eval = DataLoader(\n            self.dataset_eval,\n            collate_fn=self.create_collate_function(\n                max_sequence_length=self.arguments.max_sequence_length,\n                is_left_padded=self.arguments.is_left_padded\n            ),\n            batch_size=self.arguments.total_batch_size,\n            drop_last=True\n        )\n        max_evaluation_steps = len(\n            dataloader_eval) if self.arguments.max_training_steps is None else self.arguments.max_training_steps\n    else:\n        dataloader_eval, max_evaluation_steps = None, 0\n\n    return TrainerConfigureDataloaderFuncOutput(\n        dataloader_train=dataloader_train,\n        max_training_steps=max_training_steps,\n        dataloader_eval=dataloader_eval,\n        max_evaluation_steps=max_evaluation_steps\n    )\n</code></pre>"},{"location":"generated-trainer-base_trainer/#lib.python.EasyDel.trainer.base_trainer.BaseTrainer.configure_functions","title":"<code>configure_functions()</code>  <code>abstractmethod</code>","text":"<p>The configure_functions function is responsible for configuring the functions that will be used in training. It does this by first defining a function called function_configurations, which initializes the model parameters and returns them as a EasyDelState object. The EasyDelState object contains all the information needed to train or evaluate on a batch of data, including:</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the class attributes</p> required <p>Returns:</p> Type Description <code>TrainerConfigureFunctionFuncOutput</code> <p>A TrainerConfigureFunctionFuncOutput object</p> Source code in <code>lib/python/EasyDel/trainer/base_trainer.py</code> <pre><code>@abc.abstractmethod\ndef configure_functions(self) -&gt; TrainerConfigureFunctionFuncOutput:\n    \"\"\"\n    The configure_functions function is responsible for configuring the functions that will be used in training.\n    It does this by first defining a function called function_configurations, which initializes the model parameters and returns\n    them as a EasyDelState object. The EasyDelState object contains all the information needed to train or evaluate\n    on a batch of data, including:\n    :param self: Access the class attributes\n    :return: A TrainerConfigureFunctionFuncOutput object\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"generated-trainer-base_trainer/#lib.python.EasyDel.trainer.base_trainer.BaseTrainer.configure_model","title":"<code>configure_model()</code>","text":"<p>The configure_model function is responsible for creating the model, optimizer and scheduler.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <code>TrainerConfigureModelFuncOutput</code> <p>A model, optimizer, scheduler and config  in TrainerConfigureModelFuncOutput Object</p> Source code in <code>lib/python/EasyDel/trainer/base_trainer.py</code> <pre><code>def configure_model(self) -&gt; TrainerConfigureModelFuncOutput:\n    \"\"\"\n    The configure_model function is responsible for creating the model, optimizer and scheduler.\n\n    :param self: Represent the instance of the class\n    :return: A model, optimizer, scheduler and config  in TrainerConfigureModelFuncOutput Object\n\n    \"\"\"\n    extra_configs = {} if self.arguments.extra_configs is None else self.arguments.extra_configs\n    if self.arguments.model_class is not None:\n\n        if not hasattr(self.arguments.configs_to_initialize_model_class[\"config\"], \"get_partition_rules\"):\n            assert self.arguments.custom_rule is not None, (\n                \"if you are using custom model to init you must\"\n                \" pass custom_rule for partition rules \"\n            )\n\n        self.arguments.configs_to_initialize_model_class[\n            \"config\"\n        ].use_pjit_attention_force = self.arguments.use_pjit_attention_force\n\n        self.arguments.configs_to_initialize_model_class[\"config\"].axis_dims = self.arguments.sharding_array\n\n        model = self.arguments.model_class(\n            **self.arguments.configs_to_initialize_model_class,\n            _do_init=False\n        )\n\n        config = self.arguments.configs_to_initialize_model_class[\"config\"]\n\n    else:\n        extra_configs[\"gradient_checkpointing\"] = self.arguments.gradient_checkpointing\n        extra_configs[\"use_pjit_attention_force\"] = self.arguments.use_pjit_attention_force\n\n        model = AutoEasyDelModelForCausalLM.from_pretrained(\n            self.arguments.model_huggingface_repo_id,\n            dtype=self.arguments.dtype,\n            param_dtype=self.arguments.param_dtype,\n            _do_init=False\n        )\n        if hasattr(model, \"config\"):\n            for k, v in extra_configs.items():\n                setattr(model.config, k, v)\n            config = model.config\n        else:\n            config = None\n            warnings.warn(\n                \"Config is being set to None due to not detecting Model Configuration from taken Model \"\n                \"this will cause errors later.\"\n            )\n    tx, scheduler = self.arguments.get_optimizer_and_scheduler(self.max_training_steps)\n    return TrainerConfigureModelFuncOutput(\n        model=model,\n        tx=tx,\n        scheduler=scheduler,\n        config=config\n    )\n</code></pre>"},{"location":"generated-trainer-base_trainer/#lib.python.EasyDel.trainer.base_trainer.BaseTrainer.finish","title":"<code>finish()</code>  <code>staticmethod</code>","text":"<p>The finish function is called when the experiment ends. It can be used to save data, upload files, or do any other cleanup tasks.</p> <p>Returns:</p> Type Description <p>A dictionary of the run's metadata</p> Source code in <code>lib/python/EasyDel/trainer/base_trainer.py</code> <pre><code>@staticmethod\ndef finish():\n    \"\"\"\n    The finish function is called when the experiment ends.\n    It can be used to save data, upload files, or do any other cleanup tasks.\n\n    :return: A dictionary of the run's metadata\n\n    \"\"\"\n    wandb.finish()\n</code></pre>"},{"location":"generated-trainer-base_trainer/#lib.python.EasyDel.trainer.base_trainer.BaseTrainer.initialize_trainer_utils","title":"<code>initialize_trainer_utils()</code>","text":"<p>The initialize_trainer_utils function is responsible for initializing the following:     - wandb_runtime (if you use_wandb is True)     - timer object (for logging time taken by various functions)     - dataloader objects for training and evaluation data, along with max steps per epoch.       The configure_dataloader function accomplishes this task.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A tuple of functions</p> Source code in <code>lib/python/EasyDel/trainer/base_trainer.py</code> <pre><code>def initialize_trainer_utils(self):\n    \"\"\"\n    The initialize_trainer_utils function is responsible for initializing the following:\n        - wandb_runtime (if you use_wandb is True)\n        - timer object (for logging time taken by various functions)\n        - dataloader objects for training and evaluation data, along with max steps per epoch.\n          The configure_dataloader function accomplishes this task.\n\n    :param self: Represent the instance of the class\n    :return: A tuple of functions\n\n    \"\"\"\n    self.wandb_runtime = self.arguments.get_wandb_init() if self.arguments.use_wandb else None\n    self.timer = Timers(\n        use_wandb=False,\n        tensorboard_writer=self.arguments.get_board()\n    )\n\n    self.timer(\"configure dataloaders\").start()\n    dataset_configurations = self.configure_dataloader()\n    self.dataloader_train = dataset_configurations.dataloader_train\n    self.max_training_steps = dataset_configurations.max_training_steps\n    self.dataloader_eval = dataset_configurations.dataloader_eval\n    self.max_evaluation_steps = dataset_configurations.max_evaluation_steps\n\n    self.timer(\"configure dataloaders\").stop()\n\n    self.timer.log([\"configure dataloaders\"])\n\n    self.timer(\"configure Model ,Optimizer ,Scheduler and Config\").start()\n    model_configurations = self.configure_model()\n    model = model_configurations.model\n    tx = model_configurations.tx\n    scheduler = model_configurations.scheduler\n    config = model_configurations.config\n    self.model = model\n    self.tx = tx\n    self.scheduler = scheduler\n    self.config = config\n    if self.rapture is not None:\n        lora_modules = self.rapture.apply_lora(\n            module=model,\n            parameters=self.arguments.rapture_config.parameters,\n            tx=tx,\n        )\n        self.lora_parameters = lora_modules.lora_parameters\n        self.lora_apply_fn = lora_modules.lora_module.__call__\n        self.lora_opt_state = lora_modules.lora_opt_state\n        self.lora_model = lora_modules.lora_module\n        self.lora_tx = lora_modules.lora_tx\n\n    self.timer(\"configure Model ,Optimizer ,Scheduler and Config\").stop()\n    self.timer.log([\"configure Model ,Optimizer ,Scheduler and Config\"])\n    self.timer(\"configure functions and sharding them\").start()\n    function_configurations = self.configure_functions()\n    self.create_sharded_state_from_params_function = \\\n        function_configurations.create_sharded_state_from_params_function\n    self.sharded_train_step_function = function_configurations.sharded_train_step_function\n    self.mesh = function_configurations.mesh\n    self.checkpoint_manager = function_configurations.checkpoint_manager\n    self.initialize_state_function = function_configurations.initialize_state_function\n    self.timer(\"configure functions and sharding them\").stop()\n    self.timer.log([\"configure functions and sharding them\"])\n</code></pre>"},{"location":"generated-trainer-causal_language_model_trainer/","title":"trainer.causal_language_model_trainer","text":""},{"location":"generated-trainer-causal_language_model_trainer/#lib.python.EasyDel.trainer.causal_language_model_trainer.CausalLanguageModelTrainer","title":"<code>CausalLanguageModelTrainer</code>","text":"<p>             Bases: <code>BaseTrainer</code></p> Source code in <code>lib/python/EasyDel/trainer/causal_language_model_trainer.py</code> <pre><code>class CausalLanguageModelTrainer(BaseTrainer):\n\n    def create_collate_function(\n            self,\n            max_sequence_length: int,\n            is_left_padded: bool\n    ) -&gt; Callable:\n        def collate_fn(batch):\n            results = {}\n            corrected_sequence = None\n            for key in batch[0].keys():\n                if is_left_padded:\n                    corrected_sequence = [\n                        jnp.array(f[key])[..., -max_sequence_length:] for f in batch\n                    ]\n                else:\n                    corrected_sequence = [\n                        jnp.array(f[key])[..., :max_sequence_length] for f in batch\n                    ]\n                results[key] = jnp.stack(corrected_sequence).reshape(\n                    -1,\n                    corrected_sequence[0].shape[-1]\n                )\n            return results\n\n        return collate_fn\n\n    def configure_functions(self) -&gt; TrainerConfigureFunctionFuncOutput:\n        \"\"\"\n        The configure_functions function is responsible for configuring the functions that will be used in training.\n        It does this by first defining a function called function_configurations, which initializes the model parameters and returns\n        them as a EasyDelState object. The EasyDelState object contains all the information needed to train or evaluate\n        on a batch of data, including:\n        :param self: Access the class attributes\n        :return: A TrainerConfigureFunctionFuncOutput object\n\n        \"\"\"\n\n        def initialize_state_function():\n            initialized_parameters = self.model.init_weights(\n                jax.random.PRNGKey(0),\n                self.arguments.init_input_shape\n            )\n\n            if self.arguments.dtype == jnp.bfloat16:\n                initialized_parameters = self.model.to_bf16(initialized_parameters)\n            elif self.arguments.dtype == jnp.float16:\n                initialized_parameters = self.model.to_fp16(initialized_parameters)\n\n            tx = self.tx\n            parameters = flax.core.freeze({\"params\": initialized_parameters})\n            tx_init = copy.deepcopy(self.arguments.optimizer_kwargs)\n\n            if self.rapture is not None:\n                lora_parameters = self.lora_parameters\n                if self.arguments.dtype == jnp.bfloat16:\n                    lora_parameters = self.model.to_bf16(lora_parameters)\n                elif self.arguments.dtype == jnp.float16:\n                    lora_parameters = self.model.to_fp16(lora_parameters)\n\n                return EasyDelState(\n                    step=0,\n                    apply_fn=self.lora_apply_fn,\n                    params=lora_parameters,\n                    tx=self.lora_tx,\n                    opt_state=self.lora_opt_state,\n                    tx_init=EasyDelState.safe_dict(tx_init),\n                    hyperparameters=EasyDelState.create_hyperparameters(self.model.config.model_type),\n                    module=self.lora_model,\n                    module_config=self.model.config,\n                    module_config_args=None,\n                )\n            else:\n                return EasyDelState.create(\n                    tx=tx,\n                    params=parameters,\n                    apply_fn=self.model.__call__,\n                    module_config=copy.deepcopy(self.model.config),\n                    tx_init=tx_init,\n                    hyperparameters=EasyDelState.create_hyperparameters(self.model.config.model_type),\n                    module=self.model,\n                    module_config_args=None\n                )\n\n        def create_state_from_params_function(parameters):\n            if self.rapture is None:\n                return EasyDelState.create(\n                    tx=self.tx,\n                    params=parameters,\n                    apply_fn=self.model.__call__,\n                    module_config=copy.deepcopy(self.model.config),\n                    tx_init=copy.deepcopy(self.arguments.optimizer_kwargs),\n                    hyperparameters=EasyDelState.create_hyperparameters(self.model.config.model_type),\n                    module=self.model,\n                    module_config_args=None\n                )\n            else:\n                return EasyDelState(\n                    step=0,\n                    apply_fn=self.lora_apply_fn,\n                    params=parameters,\n                    tx=self.lora_tx,\n                    opt_state=self.lora_opt_state,\n                    tx_init=EasyDelState.safe_dict(copy.deepcopy(self.arguments.optimizer_kwargs)),\n                    hyperparameters=EasyDelState.create_hyperparameters(self.model.config.model_type),\n                    module=self.lora_model,\n                    module_config=self.model.config,\n                    module_config_args=None,\n                )\n\n        state_shape = jax.eval_shape(initialize_state_function)\n        state_partition_spec = match_partition_rules(\n            self.config.get_partition_rules(\n                fully_sharded_data_parallel=self.arguments.fully_sharded_data_parallel\n            ) if self.arguments.custom_rule is None else self.arguments.custom_rule,\n            state_shape\n        )\n        create_sharded_state_from_params_function = pjit(\n            create_state_from_params_function,\n            in_shardings=(state_partition_spec.params,),\n            out_shardings=state_partition_spec,\n            donate_argnums=(0,)\n        )\n        sharded_train_step_function = pjit(\n            create_casual_language_model_train_step(self.arguments.step_partition_spec),\n            in_shardings=(state_partition_spec, PartitionSpec()),\n            out_shardings=(state_partition_spec, PartitionSpec(), PartitionSpec()),\n            donate_argnums=(0, 0),\n        )\n\n        mesh = self.arguments.get_mesh()\n        self.arguments.ckpt_path_exists()\n        checkpoint_manager = self.arguments.get_streaming_checkpointer()\n        self.state_partition_spec = state_partition_spec\n        self.state_shape = state_shape\n\n        return TrainerConfigureFunctionFuncOutput(\n            create_sharded_state_from_params_function=create_sharded_state_from_params_function,\n            sharded_train_step_function=sharded_train_step_function,\n            mesh=mesh,\n            checkpoint_manager=checkpoint_manager,\n            initialize_state_function=initialize_state_function\n        )\n\n    def eval(\n            self,\n            state: EasyDelState\n    ):\n        if self.dataset_eval is not None:\n            pbar_eval = tqdm(total=self.max_evaluation_steps)\n            for _, batch_eval in enumerate(self.dataloader_eval):\n                _ = batch_eval.pop(\"token_type_ids\", None)\n                batch_eval[\"labels\"] = batch_eval[\"input_ids\"][..., 1:]\n                for pop_arg in self.arguments.ids_to_pop_from_dataset:\n                    _ = batch_eval.pop(pop_arg, None)\n                loss_eval, accuracy_eval = create_casual_language_model_evaluation_step(\n                    self.arguments.step_partition_spec\n                )(\n                    state, batch_eval\n                )\n                pbar_eval.update(1)\n                if self.wandb_runtime is not None:\n                    self.wandb_runtime.log(\n                        {\n                            \"loss_eval\": loss_eval.tolist(),\n                            \"accuracy_eval\": accuracy_eval.tolist()\n                        }\n                    )\n                pbar_eval.set_postfix(loss_eval=loss_eval.tolist(), accuracy_eval=accuracy_eval.tolist())\n\n    def initialize_state(\n            self,\n            model_parameters: Optional[flax.core.FrozenDict] = None,\n            state: Optional[EasyDelState] = None,\n    ) -&gt; Tuple[EasyDelState, Mapping[str, Callable], Mapping[str, Callable]]:\n        if model_parameters is None and state is None and self.rapture is None:\n            raise RuntimeError(\n                \"You are passing `model_parameters=None` and `state=None` and also you are not using LoRA if you are \"\n                \"Using LoRA make sure to pass parameters and Rapture Config correctly otherwise pass the \"\n                \"model_parameters or state.\"\n            )\n        if model_parameters is None and state is None:\n            model_parameters = self.lora_parameters\n        with self.mesh:\n            shard_fns, gather_fns = make_shard_and_gather_fns(\n                self.state_partition_spec,\n                dtype_specs=self.dtype\n            )\n            if state is not None:\n                sharded_state = state\n                params = sharded_state.params if not self.arguments.do_shard_fns else jax.tree_util.tree_map(\n                    lambda f, x: f(x),\n                    shard_fns.params,\n                    sharded_state.params\n                )\n                sharded_state.params = params\n                if sharded_state.opt_state is None:\n                    prefix_print(\n                        \"Action\", \"Optimizer State is not Found!, initializing one.\"\n                    )\n                    with jax.default_device(self.arguments.offload_device):\n                        sharded_state = sharded_state.init_opt_state()\n                        opt_state = sharded_state.opt_state if not self.arguments.do_shard_fns else jax.tree_util.tree_map(\n                            lambda f, x: f(x),\n                            shard_fns.opt_state,\n                            sharded_state.opt_state\n                        )\n                        sharded_state = sharded_state.replace(\n                            opt_state=opt_state\n                        )\n            elif self.finetune:\n\n                if model_parameters is None and self.checkpoint_path is not None:\n                    prefix_print(\n                        \"Action\", f\"Loading Model From {self.checkpoint_path}\"\n                    )\n                    with jax.default_device(self.arguments.offload_device):\n                        sharded_state = EasyDelState.load_state(\n                            verbose=self.arguments.verbose,\n                            state_shard_fns=shard_fns,\n                            init_optimizer_state=True,\n                            checkpoint_path=self.checkpoint_path,\n                        )\n                    if self.arguments.remove_ckpt_after_load:\n                        os.remove(self.checkpoint_path)\n                elif model_parameters is not None and self.checkpoint_path is None:\n                    prefix_print(\n                        \"Action\", f\"Sharding Passed Parameters\"\n                    )\n                    from flax.core import unfreeze\n                    if not isinstance(model_parameters, flax.core.FrozenDict):\n                        prefix_print(\n                            \"Warning\",\n                            \"Model Parameters should be like FrozenDict({'params': params}) make sure to \"\n                            \"pass as type FrozenDict in case of not getting UnExcepted Errors \"\n                        )\n                    # if self.rapture is None:\n                    model_parameters = model_parameters if not self.arguments.do_shard_fns else jax.tree_util.tree_map(\n                        lambda f, x: f(x),\n                        shard_fns.params,\n                        model_parameters,\n                    )\n                    sharded_state = self.create_sharded_state_from_params_function(model_parameters)\n                elif model_parameters is not None and self.checkpoint_path is not None:\n                    raise EasyDelTimerError(\n                        \"You can't pass `model_parameters` and `checkpoint_path` at same time\"\n                    )\n                else:\n                    raise EasyDelTimerError(\n                        \"You should pass `model_parameters` or `checkpoint_path` to trainer in order to load model\"\n                    )\n            else:\n                sharded_state = self.initialize_state_function()\n                params = sharded_state.params if not self.arguments.do_shard_fns else jax.tree_util.tree_map(\n                    lambda f, x: f(x),\n                    shard_fns.params,\n                    sharded_state.params\n                )\n                sharded_state.params = params\n\n            self.sharded_state = sharded_state\n            return sharded_state, shard_fns, gather_fns\n\n    def _save_state(\n            self,\n            state: EasyDelState,\n            gather_fns: Optional[Any | Mapping[str, Callable] | dict[Callable]],\n            milestone: bool = False\n    ) -&gt; str:\n        step = int(\n            jax.device_get(\n                state.step\n            )\n        ) + self.arguments.step_start_point if self.arguments.step_start_point is not None else int(\n            jax.device_get(\n                state.step\n            )\n        )\n        checkpoint_name = f\"{self.arguments.model_name}-S{step}\"\n        filename = f\"{checkpoint_name}_{step}\" if milestone else f\"{checkpoint_name}\"\n        filename += \".easy\"\n        termcolor.cprint(f\"Saving Model {filename}.\", color=\"cyan\", force_color=True)\n        state.save_state(\n            filename=filename,\n            checkpoint_dir=os.path.join(self.arguments.save_dir, self.arguments.model_name),\n            gather_fns=gather_fns,\n            float_dtype=self.dtype,\n            verbose=self.arguments.verbose,\n            save_optimizer=self.arguments.save_optimizer_state,\n        )\n        return filename\n\n    def train(\n            self,\n            model_parameters: Optional[flax.core.FrozenDict] = None,\n            state: Optional[EasyDelState] = None\n    ) -&gt; TrainerOutput:\n        \"\"\"\n        The train function is the main function of this module.\n        It takes a model_parameters argument which can be used to load a pretrained model and finetune it.\n        The train function returns an TrainerOutput object that contains the last saved file name, predict func,\n        train state, mesh and checkpoint streamer.\n\n\n        :param self: Make the class methods aware of other methods and attributes within the class\n        :param model_parameters: flax.core.FrozenDict: Load a pre-trained model\n        :param state: Optional[EasyDelState]: Ready to Use State\n        :return: An object of type \"TrainerOutput\"\n\n        \"\"\"\n\n        def count_model_parameters(_p):\n            termcolor.cprint(\n                f\"Model Contain {sum(n.size for n in jax.tree_util.tree_flatten(flax.core.unfreeze(_p))[0]) / 1e9} \"\n                f\"Billion Parameters\",\n                color=\"red\", force_color=True\n            )\n\n        dir_prefix: str = \"/dev/shm\" if sys.platform != \"win32\" else \".\"\n        checkpoint_path = \"SAVING_SKIPPED\"\n        if self.arguments.track_memory:\n            initialise_tracking(dir_prefix=dir_prefix)\n        start_time = time.time()\n        sharded_state, shard_fns, gather_fns = self.initialize_state(\n            model_parameters=model_parameters,\n            state=state\n        )\n\n        count_model_parameters(sharded_state.params)\n        with self.mesh:\n            pbar = tqdm(total=self.max_training_steps)\n            current_step = sharded_state.step.tolist()\n            losses = []\n            accuracies = []\n            pbar.update(sharded_state.step.tolist())\n            learning_rates = []\n            if self.wandb_runtime is not None:\n                model_parameters_number = sum(\n                    n.size for n in\n                    jax.tree_util.tree_flatten(flax.core.unfreeze(sharded_state.params))[0]\n                ) / 1e9\n                self.wandb_runtime.log(\n                    {\n                        \"Number of Model Parameters (Billion)\": model_parameters_number\n                    }\n                )\n                wandb.summary[\"Number of Model Parameters (Billion)\"] = model_parameters_number\n            try:\n                for epoch in range(self.arguments.num_train_epochs):\n                    for batch in self.dataloader_train:\n                        current_step += 1\n                        if (\n                                self.arguments.step_start_point is not None\n                                and\n                                self.arguments.step_start_point &gt; current_step\n                        ):\n                            pbar.update(1)\n                        elif current_step &lt; self.max_training_steps:\n\n                            batch[\"labels\"] = batch[\"input_ids\"][..., 1:]\n                            for ssb in self.arguments.ids_to_pop_from_dataset:\n                                _ = batch.pop(ssb, None)\n                            time_s = time.time()\n                            sharded_state, loss, accuracy = self.sharded_train_step_function(\n                                sharded_state,\n                                batch\n                            )\n                            ttl_time = time.time() - time_s\n                            losses.append(loss)\n                            learning_rates.append(self.scheduler(current_step).tolist())\n                            accuracies.append(accuracy)\n                            if self.arguments.track_memory:\n                                mem_res = get_mem(dir_prefix=dir_prefix)\n                            else:\n                                mem_res = \"Tracking Option is OFF\"\n                            pbar.update(1)\n\n                            if self.wandb_runtime is not None:\n                                trained_tokens = (\n                                        current_step * self.arguments.total_batch_size *\n                                        self.arguments.gradient_accumulation_steps * self.arguments.max_sequence_length\n                                )\n\n                                information_queries = {}\n                                if self.arguments.track_memory:\n                                    for key in [\"Used\", \"Usage Percent\"]:\n                                        for device, info in get_capacity_matrix(dir_prefix=dir_prefix).items():\n                                            information_queries[f\"{device.replace('_', ' ')} ({key})\"] = float(\n                                                info[key].replace(\"%\", \"\").replace(\"GB\", \"\"))\n                                with jax.spmd_mode(\"allow_all\"):\n                                    self.wandb_runtime.log(\n                                        {\n                                            \"loss\": loss.tolist(),\n                                            \"mean loss\": (sum(losses) / len(losses)).tolist(),\n                                            \"accuracy\": accuracy.tolist(),\n                                            \"mean accuracy\": (sum(accuracies) / len(accuracies)).tolist(),\n                                            \"learning_rate\": self.scheduler(\n                                                sharded_state.step.tolist()\n                                            ).tolist(),\n                                            \"step\": sharded_state.step.tolist(),\n                                            \"step time\": ttl_time,\n                                            \"perplexity\": jnp.exp(loss).tolist(),\n                                            \"trained_tokens\": trained_tokens,\n                                            \"accelerators\": information_queries,\n                                            \"epoch\": epoch\n                                        }\n                                    ),\n                                    wandb.summary[\"captured_memory_log\"] = mem_res\n\n                            if self.arguments.track_memory:\n                                IPython.display.clear_output(True)\n                                pbar.display(mem_res)\n                            pbar.set_postfix(\n                                loss=loss,\n                                learning_rate=self.scheduler(sharded_state.step.tolist()).tolist(),\n                                step=sharded_state.step.tolist(),\n                                perplexity=jnp.exp(loss).tolist(),\n                                accuracy=accuracy,\n                                epoch=epoch\n                            )\n                            if self.arguments.training_time is not None:\n                                if time.time() - start_time &gt; self.arguments.training_time:\n                                    raise EasyDelTimerError(\"Time Out\")\n                        else:\n                            break\n                        if self.arguments.save_steps is not None and current_step % self.arguments.save_steps == 0:\n                            if self.rapture is None:\n                                filename = self._save_state(\n                                    state=sharded_state,\n                                    gather_fns=gather_fns,\n                                    milestone=True\n                                )\n                                checkpoint_path = f\"{str(self.arguments.get_path())}/{filename}\"\n                            else:\n                                print(\n                                    termcolor.colored(\n                                        \"Info : \", color=\"red\", force_color=True\n                                    ),\n                                    termcolor.colored(\n                                        \"You can not use `save_steps` while using LoRA \"\n                                        \"right now. this action will be skipped\", color=\"white\", force_color=True\n                                    )\n                                )\n            except KeyboardInterrupt:\n                termcolor.cprint(\n                    \"KeyboardInterrupt At training model Will return Current State of the Model with Parameters.\",\n                    color=\"cyan\",\n                    force_color=True\n                )\n\n            except EasyDelTimerError:\n                termcolor.cprint(\n                    \"Training reached out maximum training Time Killing training Process \"\n                    \"and Will return Current State of the Model with Parameters.\",\n                    color=\"cyan\",\n                    force_color=True\n                )\n            if self.arguments.merge_lora_rapture_parameters and self.rapture is not None:\n                print(\n                    termcolor.colored(\n                        \"Info : \", color=\"red\", force_color=True\n                    ),\n                    termcolor.colored(\n                        \"Merging LoRA Parameters.\", color=\"white\", force_color=True\n                    )\n                )\n                sharded_state = sharded_state.replace(\n                    params=self.rapture.merge_parameters(sharded_state.params)\n                )\n            output = TrainerOutput(\n                state=sharded_state,\n                mesh=self.mesh,\n                shard_fns=shard_fns,\n                gather_fns=gather_fns,\n                checkpoint_manager=self.checkpoint_manager,\n            )\n            if self.arguments.save_steps is None and self.arguments.do_last_save:\n                shard_fns, gather_fns = make_shard_and_gather_fns(\n                    match_partition_rules(\n                        self.config.get_partition_rules(\n                            fully_sharded_data_parallel=self.arguments.fully_sharded_data_parallel\n                        ) if self.arguments.custom_rule is None else self.arguments.custom_rule,\n                        jax.eval_shape(lambda: sharded_state)\n                    ),\n                    dtype_specs=self.dtype\n                )  # You have to re-init the new shard and gather functions in order to be able to skip LoRA weight\n                # crashing errors and saving errors\n                filename = self._save_state(\n                    state=sharded_state,\n                    gather_fns=gather_fns\n                )\n                checkpoint_path = f\"{str(self.arguments.get_path())}/{filename}\"\n\n            if self.arguments.do_eval:\n                self.eval(\n                    sharded_state\n                )\n\n            output.checkpoint_path = checkpoint_path\n            output.last_save_file_name = filename\n            wandb.finish()\n\n            return output\n</code></pre>"},{"location":"generated-trainer-causal_language_model_trainer/#lib.python.EasyDel.trainer.causal_language_model_trainer.CausalLanguageModelTrainer.configure_functions","title":"<code>configure_functions()</code>","text":"<p>The configure_functions function is responsible for configuring the functions that will be used in training. It does this by first defining a function called function_configurations, which initializes the model parameters and returns them as a EasyDelState object. The EasyDelState object contains all the information needed to train or evaluate on a batch of data, including:</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the class attributes</p> required <p>Returns:</p> Type Description <code>TrainerConfigureFunctionFuncOutput</code> <p>A TrainerConfigureFunctionFuncOutput object</p> Source code in <code>lib/python/EasyDel/trainer/causal_language_model_trainer.py</code> <pre><code>def configure_functions(self) -&gt; TrainerConfigureFunctionFuncOutput:\n    \"\"\"\n    The configure_functions function is responsible for configuring the functions that will be used in training.\n    It does this by first defining a function called function_configurations, which initializes the model parameters and returns\n    them as a EasyDelState object. The EasyDelState object contains all the information needed to train or evaluate\n    on a batch of data, including:\n    :param self: Access the class attributes\n    :return: A TrainerConfigureFunctionFuncOutput object\n\n    \"\"\"\n\n    def initialize_state_function():\n        initialized_parameters = self.model.init_weights(\n            jax.random.PRNGKey(0),\n            self.arguments.init_input_shape\n        )\n\n        if self.arguments.dtype == jnp.bfloat16:\n            initialized_parameters = self.model.to_bf16(initialized_parameters)\n        elif self.arguments.dtype == jnp.float16:\n            initialized_parameters = self.model.to_fp16(initialized_parameters)\n\n        tx = self.tx\n        parameters = flax.core.freeze({\"params\": initialized_parameters})\n        tx_init = copy.deepcopy(self.arguments.optimizer_kwargs)\n\n        if self.rapture is not None:\n            lora_parameters = self.lora_parameters\n            if self.arguments.dtype == jnp.bfloat16:\n                lora_parameters = self.model.to_bf16(lora_parameters)\n            elif self.arguments.dtype == jnp.float16:\n                lora_parameters = self.model.to_fp16(lora_parameters)\n\n            return EasyDelState(\n                step=0,\n                apply_fn=self.lora_apply_fn,\n                params=lora_parameters,\n                tx=self.lora_tx,\n                opt_state=self.lora_opt_state,\n                tx_init=EasyDelState.safe_dict(tx_init),\n                hyperparameters=EasyDelState.create_hyperparameters(self.model.config.model_type),\n                module=self.lora_model,\n                module_config=self.model.config,\n                module_config_args=None,\n            )\n        else:\n            return EasyDelState.create(\n                tx=tx,\n                params=parameters,\n                apply_fn=self.model.__call__,\n                module_config=copy.deepcopy(self.model.config),\n                tx_init=tx_init,\n                hyperparameters=EasyDelState.create_hyperparameters(self.model.config.model_type),\n                module=self.model,\n                module_config_args=None\n            )\n\n    def create_state_from_params_function(parameters):\n        if self.rapture is None:\n            return EasyDelState.create(\n                tx=self.tx,\n                params=parameters,\n                apply_fn=self.model.__call__,\n                module_config=copy.deepcopy(self.model.config),\n                tx_init=copy.deepcopy(self.arguments.optimizer_kwargs),\n                hyperparameters=EasyDelState.create_hyperparameters(self.model.config.model_type),\n                module=self.model,\n                module_config_args=None\n            )\n        else:\n            return EasyDelState(\n                step=0,\n                apply_fn=self.lora_apply_fn,\n                params=parameters,\n                tx=self.lora_tx,\n                opt_state=self.lora_opt_state,\n                tx_init=EasyDelState.safe_dict(copy.deepcopy(self.arguments.optimizer_kwargs)),\n                hyperparameters=EasyDelState.create_hyperparameters(self.model.config.model_type),\n                module=self.lora_model,\n                module_config=self.model.config,\n                module_config_args=None,\n            )\n\n    state_shape = jax.eval_shape(initialize_state_function)\n    state_partition_spec = match_partition_rules(\n        self.config.get_partition_rules(\n            fully_sharded_data_parallel=self.arguments.fully_sharded_data_parallel\n        ) if self.arguments.custom_rule is None else self.arguments.custom_rule,\n        state_shape\n    )\n    create_sharded_state_from_params_function = pjit(\n        create_state_from_params_function,\n        in_shardings=(state_partition_spec.params,),\n        out_shardings=state_partition_spec,\n        donate_argnums=(0,)\n    )\n    sharded_train_step_function = pjit(\n        create_casual_language_model_train_step(self.arguments.step_partition_spec),\n        in_shardings=(state_partition_spec, PartitionSpec()),\n        out_shardings=(state_partition_spec, PartitionSpec(), PartitionSpec()),\n        donate_argnums=(0, 0),\n    )\n\n    mesh = self.arguments.get_mesh()\n    self.arguments.ckpt_path_exists()\n    checkpoint_manager = self.arguments.get_streaming_checkpointer()\n    self.state_partition_spec = state_partition_spec\n    self.state_shape = state_shape\n\n    return TrainerConfigureFunctionFuncOutput(\n        create_sharded_state_from_params_function=create_sharded_state_from_params_function,\n        sharded_train_step_function=sharded_train_step_function,\n        mesh=mesh,\n        checkpoint_manager=checkpoint_manager,\n        initialize_state_function=initialize_state_function\n    )\n</code></pre>"},{"location":"generated-trainer-causal_language_model_trainer/#lib.python.EasyDel.trainer.causal_language_model_trainer.CausalLanguageModelTrainer.train","title":"<code>train(model_parameters=None, state=None)</code>","text":"<p>The train function is the main function of this module. It takes a model_parameters argument which can be used to load a pretrained model and finetune it. The train function returns an TrainerOutput object that contains the last saved file name, predict func, train state, mesh and checkpoint streamer.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Make the class methods aware of other methods and attributes within the class</p> required <code>model_parameters</code> <code>Optional[FrozenDict]</code> <p>flax.core.FrozenDict: Load a pre-trained model</p> <code>None</code> <code>state</code> <code>Optional[EasyDelState]</code> <p>Optional[EasyDelState]: Ready to Use State</p> <code>None</code> <p>Returns:</p> Type Description <code>TrainerOutput</code> <p>An object of type \"TrainerOutput\"</p> Source code in <code>lib/python/EasyDel/trainer/causal_language_model_trainer.py</code> <pre><code>def train(\n        self,\n        model_parameters: Optional[flax.core.FrozenDict] = None,\n        state: Optional[EasyDelState] = None\n) -&gt; TrainerOutput:\n    \"\"\"\n    The train function is the main function of this module.\n    It takes a model_parameters argument which can be used to load a pretrained model and finetune it.\n    The train function returns an TrainerOutput object that contains the last saved file name, predict func,\n    train state, mesh and checkpoint streamer.\n\n\n    :param self: Make the class methods aware of other methods and attributes within the class\n    :param model_parameters: flax.core.FrozenDict: Load a pre-trained model\n    :param state: Optional[EasyDelState]: Ready to Use State\n    :return: An object of type \"TrainerOutput\"\n\n    \"\"\"\n\n    def count_model_parameters(_p):\n        termcolor.cprint(\n            f\"Model Contain {sum(n.size for n in jax.tree_util.tree_flatten(flax.core.unfreeze(_p))[0]) / 1e9} \"\n            f\"Billion Parameters\",\n            color=\"red\", force_color=True\n        )\n\n    dir_prefix: str = \"/dev/shm\" if sys.platform != \"win32\" else \".\"\n    checkpoint_path = \"SAVING_SKIPPED\"\n    if self.arguments.track_memory:\n        initialise_tracking(dir_prefix=dir_prefix)\n    start_time = time.time()\n    sharded_state, shard_fns, gather_fns = self.initialize_state(\n        model_parameters=model_parameters,\n        state=state\n    )\n\n    count_model_parameters(sharded_state.params)\n    with self.mesh:\n        pbar = tqdm(total=self.max_training_steps)\n        current_step = sharded_state.step.tolist()\n        losses = []\n        accuracies = []\n        pbar.update(sharded_state.step.tolist())\n        learning_rates = []\n        if self.wandb_runtime is not None:\n            model_parameters_number = sum(\n                n.size for n in\n                jax.tree_util.tree_flatten(flax.core.unfreeze(sharded_state.params))[0]\n            ) / 1e9\n            self.wandb_runtime.log(\n                {\n                    \"Number of Model Parameters (Billion)\": model_parameters_number\n                }\n            )\n            wandb.summary[\"Number of Model Parameters (Billion)\"] = model_parameters_number\n        try:\n            for epoch in range(self.arguments.num_train_epochs):\n                for batch in self.dataloader_train:\n                    current_step += 1\n                    if (\n                            self.arguments.step_start_point is not None\n                            and\n                            self.arguments.step_start_point &gt; current_step\n                    ):\n                        pbar.update(1)\n                    elif current_step &lt; self.max_training_steps:\n\n                        batch[\"labels\"] = batch[\"input_ids\"][..., 1:]\n                        for ssb in self.arguments.ids_to_pop_from_dataset:\n                            _ = batch.pop(ssb, None)\n                        time_s = time.time()\n                        sharded_state, loss, accuracy = self.sharded_train_step_function(\n                            sharded_state,\n                            batch\n                        )\n                        ttl_time = time.time() - time_s\n                        losses.append(loss)\n                        learning_rates.append(self.scheduler(current_step).tolist())\n                        accuracies.append(accuracy)\n                        if self.arguments.track_memory:\n                            mem_res = get_mem(dir_prefix=dir_prefix)\n                        else:\n                            mem_res = \"Tracking Option is OFF\"\n                        pbar.update(1)\n\n                        if self.wandb_runtime is not None:\n                            trained_tokens = (\n                                    current_step * self.arguments.total_batch_size *\n                                    self.arguments.gradient_accumulation_steps * self.arguments.max_sequence_length\n                            )\n\n                            information_queries = {}\n                            if self.arguments.track_memory:\n                                for key in [\"Used\", \"Usage Percent\"]:\n                                    for device, info in get_capacity_matrix(dir_prefix=dir_prefix).items():\n                                        information_queries[f\"{device.replace('_', ' ')} ({key})\"] = float(\n                                            info[key].replace(\"%\", \"\").replace(\"GB\", \"\"))\n                            with jax.spmd_mode(\"allow_all\"):\n                                self.wandb_runtime.log(\n                                    {\n                                        \"loss\": loss.tolist(),\n                                        \"mean loss\": (sum(losses) / len(losses)).tolist(),\n                                        \"accuracy\": accuracy.tolist(),\n                                        \"mean accuracy\": (sum(accuracies) / len(accuracies)).tolist(),\n                                        \"learning_rate\": self.scheduler(\n                                            sharded_state.step.tolist()\n                                        ).tolist(),\n                                        \"step\": sharded_state.step.tolist(),\n                                        \"step time\": ttl_time,\n                                        \"perplexity\": jnp.exp(loss).tolist(),\n                                        \"trained_tokens\": trained_tokens,\n                                        \"accelerators\": information_queries,\n                                        \"epoch\": epoch\n                                    }\n                                ),\n                                wandb.summary[\"captured_memory_log\"] = mem_res\n\n                        if self.arguments.track_memory:\n                            IPython.display.clear_output(True)\n                            pbar.display(mem_res)\n                        pbar.set_postfix(\n                            loss=loss,\n                            learning_rate=self.scheduler(sharded_state.step.tolist()).tolist(),\n                            step=sharded_state.step.tolist(),\n                            perplexity=jnp.exp(loss).tolist(),\n                            accuracy=accuracy,\n                            epoch=epoch\n                        )\n                        if self.arguments.training_time is not None:\n                            if time.time() - start_time &gt; self.arguments.training_time:\n                                raise EasyDelTimerError(\"Time Out\")\n                    else:\n                        break\n                    if self.arguments.save_steps is not None and current_step % self.arguments.save_steps == 0:\n                        if self.rapture is None:\n                            filename = self._save_state(\n                                state=sharded_state,\n                                gather_fns=gather_fns,\n                                milestone=True\n                            )\n                            checkpoint_path = f\"{str(self.arguments.get_path())}/{filename}\"\n                        else:\n                            print(\n                                termcolor.colored(\n                                    \"Info : \", color=\"red\", force_color=True\n                                ),\n                                termcolor.colored(\n                                    \"You can not use `save_steps` while using LoRA \"\n                                    \"right now. this action will be skipped\", color=\"white\", force_color=True\n                                )\n                            )\n        except KeyboardInterrupt:\n            termcolor.cprint(\n                \"KeyboardInterrupt At training model Will return Current State of the Model with Parameters.\",\n                color=\"cyan\",\n                force_color=True\n            )\n\n        except EasyDelTimerError:\n            termcolor.cprint(\n                \"Training reached out maximum training Time Killing training Process \"\n                \"and Will return Current State of the Model with Parameters.\",\n                color=\"cyan\",\n                force_color=True\n            )\n        if self.arguments.merge_lora_rapture_parameters and self.rapture is not None:\n            print(\n                termcolor.colored(\n                    \"Info : \", color=\"red\", force_color=True\n                ),\n                termcolor.colored(\n                    \"Merging LoRA Parameters.\", color=\"white\", force_color=True\n                )\n            )\n            sharded_state = sharded_state.replace(\n                params=self.rapture.merge_parameters(sharded_state.params)\n            )\n        output = TrainerOutput(\n            state=sharded_state,\n            mesh=self.mesh,\n            shard_fns=shard_fns,\n            gather_fns=gather_fns,\n            checkpoint_manager=self.checkpoint_manager,\n        )\n        if self.arguments.save_steps is None and self.arguments.do_last_save:\n            shard_fns, gather_fns = make_shard_and_gather_fns(\n                match_partition_rules(\n                    self.config.get_partition_rules(\n                        fully_sharded_data_parallel=self.arguments.fully_sharded_data_parallel\n                    ) if self.arguments.custom_rule is None else self.arguments.custom_rule,\n                    jax.eval_shape(lambda: sharded_state)\n                ),\n                dtype_specs=self.dtype\n            )  # You have to re-init the new shard and gather functions in order to be able to skip LoRA weight\n            # crashing errors and saving errors\n            filename = self._save_state(\n                state=sharded_state,\n                gather_fns=gather_fns\n            )\n            checkpoint_path = f\"{str(self.arguments.get_path())}/{filename}\"\n\n        if self.arguments.do_eval:\n            self.eval(\n                sharded_state\n            )\n\n        output.checkpoint_path = checkpoint_path\n        output.last_save_file_name = filename\n        wandb.finish()\n\n        return output\n</code></pre>"},{"location":"generated-trainer-causal_language_model_trainer/#lib.python.EasyDel.trainer.causal_language_model_trainer.calculate_accuracy","title":"<code>calculate_accuracy(predictions, targets)</code>","text":"<p>The calculate_accuracy function takes in two arrays, predictions and targets. The function then calculates the accuracy of the model by comparing the predicted classes to the target classes. The predicted class is determined by taking argmax along axis - 1 of predictions. The correct_predictions variable is an array containing True or False values depending on whether or not the prediction was correct for each example in a batch. The total number of examples that were correctly predicted are summed up and divided by the total number of examples to get an accuracy value between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>predictions</code> <code>Array</code> <p>chex.Array: Pass in the predictions from the model</p> required <code>targets</code> <code>Array</code> <p>chex.Array: Calculate the accuracy of the model</p> required <p>Returns:</p> Type Description <p>A single value, the accuracy</p> Source code in <code>lib/python/EasyDel/trainer/causal_language_model_trainer.py</code> <pre><code>def calculate_accuracy(predictions: chex.Array, targets: chex.Array):\n    \"\"\"\n    The calculate_accuracy function takes in two arrays, predictions and targets.\n    The function then calculates the accuracy of the model by comparing the predicted classes to\n    the target classes. The predicted class is determined by taking argmax along axis - 1 of predictions.\n    The correct_predictions variable is an array containing True or False values depending on whether or not\n    the prediction was correct for each example in a batch. The total number of examples that were correctly\n    predicted are summed up and divided by the total number of examples to get an accuracy value between 0 and 1.\n\n    :param predictions: chex.Array: Pass in the predictions from the model\n    :param targets: chex.Array: Calculate the accuracy of the model\n    :return: A single value, the accuracy\n\n    \"\"\"\n    predicted_classes = jnp.argmax(predictions, axis=-1)\n    correct_predictions = (predicted_classes == targets).sum()\n    total_predictions = targets.shape[0]\n    accuracy = correct_predictions / total_predictions\n    return accuracy\n</code></pre>"},{"location":"generated-trainer-causal_language_model_trainer/#lib.python.EasyDel.trainer.causal_language_model_trainer.create_casual_language_model_evaluation_step","title":"<code>create_casual_language_model_evaluation_step(partition_spec=PartitionSpec(('dp', 'fsdp'), 'sp'))</code>","text":"<p>The create_casual_language_model_evaluation_step function is used to create a function that calculates the loss  and accuracy of a model. It takes in a set of parameters, which are then passed into the state.apply_fn function to generate logits for each token in the batch. The cross entropy loss and accuracy are then calculated from these  logits.</p> <p>Parameters:</p> Name Type Description Default <code>partition_spec</code> <p>Specify the partitioning of the model parameters</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp')</code> <p>Returns:</p> Type Description <p>A function that can be used to calculate the loss and accuracy of a model</p> Source code in <code>lib/python/EasyDel/trainer/causal_language_model_trainer.py</code> <pre><code>def create_casual_language_model_evaluation_step(partition_spec=PartitionSpec((\"dp\", \"fsdp\"), \"sp\")):\n    \"\"\"\n    The create_casual_language_model_evaluation_step function is used to create a function that calculates the loss\n     and accuracy of a model. It takes in a set of parameters, which are then passed into the state.apply_fn function\n    to generate logits for each token in the batch. The cross entropy loss and accuracy are then calculated from these \n    logits.\n\n    :param partition_spec: Specify the partitioning of the model parameters\n    :return: A function that can be used to calculate the loss and accuracy of a model\n\n    \"\"\"\n\n    def casual_language_model_evaluation_step(state, batch_eval):\n        \"\"\"\n        The casual_language_model_evaluation_step function is used to calculate the loss and accuracy of a model.\n        It takes in a set of parameters, which are then passed into the state.apply_fn function\n        to generate logits for each token in the batch. The cross entropy loss and accuracy are then calculated from \n        these logits.\n\n        :param state: Store the model parameters and other information about the training process\n        :param batch_eval: Pass the batch of data to the function\n        :return: The loss and accuracy of the model\n\n        \"\"\"\n        batch_eval = with_sharding_constraint(\n            batch_eval, partition_spec\n        )\n\n        def calculate_loss(params):\n            \"\"\"\n            The calculate_loss function is used to calculate the loss and accuracy of a model.\n            It takes in a set of parameters, which are then passed into the state.apply_fn function\n            to generate logits for each token in the batch. The cross entropy loss and accuracy are then calculated \n            from these logits.\n\n            :param params: Pass the model parameters to the function\n            :return: The loss and the accuracy\n\n            \"\"\"\n            labels = batch_eval.pop(\"labels\")\n            logits = state.apply_fn(params=params, **batch_eval,\n                                    return_dict=True).logits\n\n            loss, accuracy = cross_entropy_loss_and_accuracy(\n                logits[:, :-1, :], labels, batch_eval[\"attention_mask\"].astype(jnp.float32)[:, 1:]\n            )\n            return loss, accuracy\n\n        loss__, accuracy__ = calculate_loss(state.params)\n        return loss__, accuracy__\n\n    return casual_language_model_evaluation_step\n</code></pre>"},{"location":"generated-trainer-causal_language_model_trainer/#lib.python.EasyDel.trainer.causal_language_model_trainer.create_casual_language_model_train_step","title":"<code>create_casual_language_model_train_step(partition_spec=PartitionSpec(('dp', 'fsdp'), 'sp'))</code>","text":"<p>The create_casual_language_model_train_step function is a training step function that takes in the current state  of the model,and a batch of data. It then calculates the loss and accuracy for this batch, and returns  an updated state with new parameters based on these gradients.</p> <p>Parameters:</p> Name Type Description Default <code>partition_spec</code> <p>Specify which devices the model will be split across</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp')</code> <p>Returns:</p> Type Description <p>A casual_language_model_train_step function that takes in the current state of the model,</p> Source code in <code>lib/python/EasyDel/trainer/causal_language_model_trainer.py</code> <pre><code>def create_casual_language_model_train_step(partition_spec=PartitionSpec((\"dp\", \"fsdp\"), \"sp\")):\n    \"\"\"\n    The create_casual_language_model_train_step function is a training step function that takes in the current state \n    of the model,and a batch of data. It then calculates the loss and accuracy for this batch, and returns \n    an updated state with new parameters based on these gradients.\n\n    :param partition_spec: Specify which devices the model will be split across\n    :return: A casual_language_model_train_step function that takes in the current state of the model,\n\n    \"\"\"\n\n    def casual_language_model_train_step(state, batch):\n        \"\"\"\n        The casual_language_model_train_step function is a training step function that takes in the current state \n        of the model and a batch of data. It then calculates the loss and accuracy for this batch, \n        and returns an updated state with new parameters based on these gradients.\n\n        :param state: Store the model parameters\n        :param batch: Pass the data to the model\n        :return: A tuple of (state, loss, accuracy)\n\n        \"\"\"\n        batch = with_sharding_constraint(batch, partition_spec)\n\n        def calculate_loss(params):\n            labels = batch.pop(\"labels\")\n            logits = state.apply_fn(\n                params=params,\n                **batch,\n                return_dict=True\n            ).logits\n\n            loss, accuracy = cross_entropy_loss_and_accuracy(\n                logits[:, :-1, :], labels, batch[\"attention_mask\"].astype(jnp.float32)[:, 1:]\n            )\n            return loss, accuracy\n\n        grad_fn = jax.value_and_grad(calculate_loss, has_aux=True)\n        (loss__, accuracy__), grad = grad_fn(state.params)\n        state = state.apply_gradients(grads=grad)\n        return state, loss__, accuracy__\n\n    return casual_language_model_train_step\n</code></pre>"},{"location":"generated-trainer-training_configurations/","title":"trainer.training_configurations","text":""},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments","title":"<code>TrainArguments</code>","text":"<p>             Bases: <code>OrderedDict</code></p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>class TrainArguments(\n    OrderedDict\n):\n    def __init__(\n            self,\n            model_name: str,\n            num_train_epochs: int,\n            model_class: Optional[EasyDelFlaxPretrainedModel | Type[EasyDelFlaxPretrainedModel]] = None,\n            model_huggingface_repo_id: Optional[str] = None,\n            total_batch_size: int = 32,\n            max_training_steps: Optional[int] = None,\n            optimizer: AVAILABLE_OPTIMIZERS = EasyDelOptimizers.ADAMW,\n            scheduler: AVAILABLE_SCHEDULERS = EasyDelSchedulers.NONE,\n            learning_rate: Union[int, float] = 5e-5,\n            learning_rate_end: Optional[float] = 5e-6,\n            gradient_accumulation_steps: int = 1,\n            weight_decay: float = 0.01,\n            gradient_checkpointing: AVAILABLE_GRADIENT_CHECKPOINTS = EasyDelGradientCheckPointers.NOTHING_SAVEABLE,\n            max_sequence_length: Optional[int] = 4096,\n            sharding_array: Union[tuple, int] = (1, -1, 1, 1),\n            is_fine_tuning: bool = True,\n            do_train: bool = True,\n            do_eval: bool = False,\n            do_test: Optional[bool] = False,\n            backend: Optional[str] = None,\n            extra_optimizer_kwargs: dict = None,\n            save_steps: Optional[int] = None,\n            save_dir: str = \"EasyDel-Checkpoints\",\n            use_pjit_attention_force: bool = False,\n            dtype: jnp.dtype = jnp.bfloat16,\n            param_dtype: jnp.dtype = jnp.bfloat16,\n            fully_sharded_data_parallel: bool = True,\n            use_wandb: bool = True,\n            custom_rule: Mapping[str, PartitionSpec] = None,\n            extra_configs: Optional[dict] = None,\n            ids_to_pop_from_dataset: Optional[list] = None,\n            remove_ckpt_after_load: bool = False,\n            configs_to_initialize_model_class: Optional[dict] = None,\n            do_last_save: bool = True,\n            model_parameters: Optional[dict] = None,\n            do_shard_fns: bool = True,\n            track_memory: bool = True,\n            loss_re_mat: str = \"\",\n            loss_chunk: int = 1024,\n            is_left_padded: bool = False,\n            warmup_steps: int = 500,\n            init_input_shape: Tuple[int, int] = (1, 1),\n            step_partition_spec: PartitionSpec = PartitionSpec((\"dp\", \"fsdp\"), \"sp\"),\n            training_time: Optional[str] = None,\n            dataloader_num_workers: Optional[int] = 0,\n            dataloader_pin_memory: Optional[bool] = False,\n            jax_distributed_config: Optional[dict] = None,\n            log_all_workers: bool = False,\n            wandb_entity: Optional[str] = None,\n            save_optimizer_state: bool = False,\n            step_start_point: Optional[int] = None,\n            verbose: bool = True,\n            offload_device: jax.Device = jax.devices(\"cpu\")[0],\n            rapture_config: Optional[EasyDeLXRapTureConfig] = None,\n            merge_lora_rapture_parameters: bool = True,\n            state_apply_fn_kwarguments_to_model: Optional[dict] = None,\n            **kwargs\n    ):\n        \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up the attributes of an object, which are sometimes called fields or properties.\n    The __init__ function can accept arguments, just like a normal function.\n\n    :param self: Represent the instance of the class\n    :param model_name: str: Specify the model name\n    :param num_train_epochs: int: Set the number of epochs for training\n    :param model_huggingface_repo_id: Optional[str]: Load a pretrained model from the huggingface model hub\n    :param model_class: Optional[EasyDelFlaxPretrainedModel]: Pass a model class to the trainer\n    :param total_batch_size: int: Set the batch size of the model\n    :param max_training_steps: Optional[int]: Set the maximum number of steps to train for\n    :param optimizer: AVAILABLE_OPTIMIZERS: Specify the optimizer used to train the model\n    :param scheduler: AVAILABLE_SCHEDULERS: Set the learning rate scheduler\n    :param learning_rate: Union[int: Set the learning rate for the optimizer\n    :param float]: Set the learning rate\n    :param learning_rate_end: Optional[float]: Set the learning rate at the end of training\n    :param gradient_accumulation_steps: int: Accumulate gradients over multiple batches\n    :param weight_decay: float: Specify the weight decay to be used by the optimizer\n    :param gradient_checkpointing: AVAILABLE_GRADIENT_CHECKPOINTS: Determine how to use gradient checkpointing\n    :param max_sequence_length: Optional[int]: Set the maximum length of the input sequence\n    :param sharding_array: Union[tuple,int]: Specify the mesh of devices to use for training\n    :param is_fine_tuning: bool: Tell the model whether or not to initialize the weights of\n    :param do_train: bool: Indicate whether to train the model or not\n    :param do_eval: bool: Determine whether to run evaluation on the validation set after training\n    :param do_test: Optional[bool]: Determine if the model should be tested\n    :param backend: Optional[str]: Specify the backend of jax\n    :param extra_optimizer_kwargs: dict: Pass extra arguments to the optimizer\n    :param save_steps: Optional[int]: Save the model after every n steps\n    :param save_dir: str: Define the directory where the checkpoints will be saved\n    :param use_pjit_attention_force: bool: Force the use of pjit for attention layers\n    :param dtype: jnp.dtype: Set the dtype of the model parameters\n    :param param_dtype: jnp.dtype: Specify the data type of the model parameters\n    :param fully_sharded_data_parallel: bool: Determine if the model should be fully fsdp or not\n    :param use_wandb: bool: Enable or disable the wandb logging\n    :param custom_rule: Mapping[str, PartitionSpec]: Specify the partitioning rules of the model\n    :param extra_configs: Optional[dict]: Pass extra configurations to the model class\n    :param ids_to_pop_from_dataset: Optional[list]: Remove some of the ids from the dataset\n    :param remove_ckpt_after_load: bool: Remove the checkpoint after loading it\n    :param configs_to_initialize_model_class: Optional[dict]: Pass extra configurations to the model class\n    :param do_last_save: bool: Save the model after training is complete\n    :param model_parameters: Optional[dict]: Pass the model parameters to the model class\n    :param do_shard_fns: bool: Shard the model functions across devices\n    :param track_memory: bool: Track the memory usage of the model\n    :param loss_re_mat: str: Specify the regular expression to match the loss function name\n    :param loss_chunk: int: Chunk the loss to avoid memory overflow\n    :param is_left_padded: bool: Determine if the input is left padded or not\n    :param warmup_steps: int: Specify the number of steps to warm up the learning rate\n    :param init_input_shape: Tuple[int, int]: Initialize the model with a shape that is not (batch_size, length)\n    :param step_partition_spec: PartitionSpec: Partition the model for training\n    :param training_time: Optional[str]: Set a time limit for the training process\n    :param dataloader_num_workers: Optional[int]: Set the number of workers used by pytorch's\n    :param dataloader_pin_memory: Optional[bool]: Pin the memory of the dataloader\n    :param jax_distributed_config: Optional[dict]: Configure the jax distributed backend\n    :param log_all_workers: bool: Log all workers in wandb,\n    :param wandb_entity: Optional[str]: Specify the entity to use when logging to weights &amp;amp; biases\n    :param save_optimizer_state : bool: when ever to save optimizer state and other args in checkpoint\n    :param step_start_point: Optional[int]: start training from given step for example instead of starting training from\n    step 0 it will start from 20000 and leave the data behind\n    :param verbose: bool: when ever to turn verbose mode of or on\n    :param offload_device: jax.Device: device to be used to offload parameters on\n    :param rapture_config: Optional[EasyDeLXRaptureConfig]: LoRA Config for models\n    :param merge_lora_rapture_parameters: bool: whenever to merge lora parameters with original parameters before saving\n    :param state_apply_fn_kwarguments_to_model: Optional[dict]: state_apply_fn_kwarguments_to_model is a dictionary that\n    be used to apply the parameters and extra things that you want to deliver to model.\n    :param **kwargs: Pass keyword, variable-length argument list\n    :return: Nothing\n        \"\"\"\n        super().__init__()\n\n        if ids_to_pop_from_dataset is None:\n            ids_to_pop_from_dataset = []\n        if extra_optimizer_kwargs is None:\n            extra_optimizer_kwargs = {}\n\n        if model_class is None and model_huggingface_repo_id is None:\n            print(\n                termcolor.colored(\n                    \"Warning : \", color=\"red\", force_color=True\n                ) + termcolor.colored(\n                    \"You should at least pass model_class or model_huggingface_repo_id if you want to use \"\n                    \"CasualLanguageModel Trainer But in case that you want to use \"\n                    \"DPOTrainer you can ignore this warning\", color=\"white\",\n                    force_color=True\n                )\n            )\n        assert backend in AVAILABLE_BACKENDS, (\n            f\"{backend} is not recognized, \"\n            f\"available backends are {AVAILABLE_BACKENDS}\"\n        )\n\n        available_backends = len(jax.devices(backend))\n\n        total_batch_size *= gradient_accumulation_steps\n\n        array_devices = jnp.ones((available_backends, 1)).reshape(sharding_array)\n\n        JaxDistributedConfig.initialize(jax_distributed_config)\n\n        self.available_backends = available_backends\n        self.array_devices_shape = array_devices.shape\n        self.model_huggingface_repo_id = model_huggingface_repo_id\n        self.num_train_epochs = num_train_epochs\n        self.wandb_entity = wandb_entity\n        self.total_batch_size = total_batch_size\n        self.max_training_steps = max_training_steps\n        self.optimizer = optimizer\n        self.scheduler = scheduler\n        self.extra_optimizer_kwargs = extra_optimizer_kwargs\n        self.learning_rate = learning_rate\n        self.learning_rate_end = learning_rate_end\n        self.weight_decay = weight_decay\n        self.model_name = model_name\n        self.gradient_checkpointing = gradient_checkpointing\n        self.max_sequence_length = max_sequence_length\n        self.sharding_array = sharding_array\n        self.is_fine_tuning = is_fine_tuning\n        self.do_train = do_train\n        self.do_eval = do_eval\n        self.do_test = do_test\n        self.save_steps = save_steps\n        self.save_dir = save_dir\n        self.use_pjit_attention_force = use_pjit_attention_force\n        self.dtype = dtype\n        self.warmup_steps = warmup_steps\n        self.param_dtype = param_dtype\n        self.fully_sharded_data_parallel = fully_sharded_data_parallel\n        self.use_wandb = use_wandb\n        self.custom_rule = custom_rule\n        self.extra_configs = extra_configs\n        self.ids_to_pop_from_dataset = ids_to_pop_from_dataset\n        self.remove_ckpt_after_load = remove_ckpt_after_load\n        self.model_class = model_class\n        self.configs_to_initialize_model_class = configs_to_initialize_model_class\n        self.do_last_save = do_last_save\n        self.model_parameters = model_parameters\n        self.do_shard_fns = do_shard_fns\n        self.gradient_accumulation_steps = gradient_accumulation_steps\n        self.track_memory = track_memory\n        self.loss_chunk = loss_chunk\n        self.loss_re_mat = loss_re_mat\n        self.init_input_shape = init_input_shape\n        self.is_left_padded = is_left_padded\n        self.step_partition_spec = step_partition_spec\n        self.jax_distributed_config = jax_distributed_config\n        self.log_all_workers = log_all_workers\n        self.dataloader_num_workers = dataloader_num_workers\n        self.dataloader_pin_memory = dataloader_pin_memory\n        self.save_optimizer_state = save_optimizer_state\n        self.step_start_point = step_start_point if step_start_point is not None else 0\n        self.verbose = verbose\n        self.offload_device = offload_device\n        self.optimizer_kwargs = dict(\n            learning_rate=self.learning_rate,\n            learning_rate_end=self.learning_rate_end,\n            optimizer=self.optimizer,\n            scheduler=self.scheduler,\n            extra_optimizer_kwargs=self.extra_optimizer_kwargs,\n            warmup_steps=self.warmup_steps,\n            gradient_accumulation_steps=self.gradient_accumulation_steps,\n            weight_decay=self.weight_decay,\n            steps=self.max_training_steps,\n        )\n        self.training_time = self._time_to_seconds(training_time) if training_time is not None else None\n        torch.set_default_device(\"cpu\")\n        self.merge_lora_rapture_parameters = merge_lora_rapture_parameters\n        self.rapture = None\n        self.rapture_config = None\n        self.state_apply_fn_kwarguments_to_model = (\n            state_apply_fn_kwarguments_to_model\n        ) if state_apply_fn_kwarguments_to_model is not None else {}\n        if rapture_config is not None:\n            print(\n                termcolor.colored(\"Warning : \", color=\"red\", force_color=True),\n                termcolor.colored(\n                    \"You are using LoRA (Low-Rank Adaptation of Large Language Models) and this feature is\"\n                    \"still in Beta mode so it might act unexpected\", color=\"red\", force_color=True\n                )\n            )\n            self.rapture_config = rapture_config\n            self.rapture = XRapTure(config=rapture_config)\n\n        self.__dict__.update(**kwargs)\n\n    @staticmethod\n    def _time_to_seconds(time_str):\n        pattern = r\"(\\d+)\\s*(h|min)\"\n        match = re.match(pattern, time_str.lower())\n\n        if match:\n            value = int(match.group(1))\n            unit = match.group(2).lower()\n\n            if unit == \"h\":\n                return value * 3600  # Convert hours to seconds\n            elif unit == \"min\":\n                return value * 60  # Convert minutes to seconds\n        else:\n            raise SyntaxError(\n                \"Invalid input format it should be like 50Min for M and 23H for hours\")\n\n    def __call__(self):\n        return {k: v for k, v in self.__dict__.items()}\n\n    def get_meter_dict(self):\n        \"\"\"\n        The get_meter_dict function is used to return a dictionary of the hyperparameters.\n        The function iterates through all the attributes in the class and returns a dictionary with\n        the key as &amp;quot;hyperparameters/{k}&amp;quot; and value as v for each attribute k,v in self.__dict__ if it is an\n         instance of int, float, str, bool or torch.Tensor.\n\n        :param self: Represent the instance of the class\n        :return: A dictionary of hyperparameters\n\n        \"\"\"\n        return {\n            f\"hyperparameters/{k}\": v for k, v in self.__dict__.items() if\n            isinstance(v, (int, float, str, bool, torch.Tensor))\n        }\n\n    def get_wandb_init(self) -&gt; Run | RunDisabled | None:\n        \"\"\"\n        The get_wandb_init function is a helper function that returns the wandb.init() call with\n        the project name, config object, and tags set to appropriate values for this model.\n\n        :param self: Pass the class instance to the function\n        :return: A wandb or None\n\n        \"\"\"\n        return wandb.init(\n            project=f\"EasyDeL-{self.model_name}\",\n            config=self(),\n            tags=[\n                \"Easy Del\",\n                \"FJFormer\",\n                \"OST-OpenSourceTransformers\",\n                \"Jax/Flax\"\n            ],\n            entity=self.wandb_entity\n\n        ) if self.log_all_workers or (jax.process_index() == 0) else None\n\n    def __str__(self):\n        string = f\"{self.__class__.__name__}(\\n\"\n        for k, v in self.__call__().items():\n            if isinstance(v, Callable):\n                def string_func(it_self):\n                    string_ = f\"{it_self.__class__.__name__}(\\n\"\n                    for k_, v_ in it_self.__dict__.items():\n                        string_ += f\"\\t\\t{k_} : {v_}\\n\"\n                    string_ += \"\\t)\"\n                    return string_\n\n                v.__str__ = string_func\n                v = v.__str__(v)\n            string += f\"\\t{k} : {v}\\n\"\n        string += \")\"\n        return string\n\n    def get_path(self):\n        \"\"\"\n        The get_path function returns a pathlib.Path object, which is a class that\n        represents file paths and provides methods for interacting with the files at\n        those paths. The get_path function takes no arguments and returns an instance of\n        the Path class initialized with two arguments: self.save_dir (a string) and\n        self.model_name (also a string). The save directory is the directory where we'll\n        store our model checkpoints, while the model name will be used to create unique\n        filenames for each checkpoint.\n\n        :param self: Represent the instance of the class\n        :return: A pathlib\n\n        \"\"\"\n        return pathlib.Path(\n            self.save_dir, self.model_name\n        )\n\n    def ckpt_path_exists(self):\n        \"\"\"\n        The ckpt_path_exists function checks to see if the path exists. If it does not, then it creates a new directory.\n\n        :param self: Represent the instance of the class\n        :return: A path\n\n        \"\"\"\n        path = self.get_path()\n        if not path.exists():\n            path.mkdir(parents=True)\n\n    def get_mesh(self):\n        \"\"\"\n        The get_mesh function is used to create a mesh object that can be used\n        to define the geometry of the device. The mesh object contains two arrays:\n        a list of vertices and a list of faces. Each face is defined by three indices,\n        which correspond to three vertices in the vertex array. The get_mesh function\n        is called when creating an instance of DeviceGeometry, which is then passed\n        into an instance of DeviceSimulation.\n\n        :param self: Refer to the object itself\n        :return: A mesh object with the device array shape and the mesh names\n\n        \"\"\"\n        return Mesh(\n            create_device_mesh(\n                self.array_devices_shape\n            ),\n            self.get_mesh_names()\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n    @staticmethod\n    def get_mesh_names():\n        return \"dp\", \"fsdp\", \"tp\", \"sp\"\n\n    def get_optimizer_and_scheduler(\n            self,\n            steps: int | None = None\n    ):\n        self.optimizer_kwargs[\"steps\"] = steps or self.optimizer_kwargs[\"steps\"]\n        return get_optimizer_and_scheduler(\n            **self.optimizer_kwargs\n        )\n\n    def get_streaming_checkpointer(self):\n        \"\"\"\n        The get_streaming_checkpointer function is used to save the model's weights.\n        The streaming checkpointer saves the model's weights in a file called &amp;quot;checkpoint&amp;quot; and then\n        saves a copy of that file with an incrementing number appended to it (e.g., checkpoint_001,\n        checkpoint_002, etc.). This allows you to keep multiple versions of your trained models.\n\n        :param self: Represent the instance of the class\n        :return: A CheckpointManager object\n\n        \"\"\"\n        return CheckpointManager(\n            os.path.join(self.save_dir, self.model_name),\n            save_optimizer_state=self.save_optimizer_state,\n            verbose=self.verbose\n        )\n\n    def get_board(self):\n        \"\"\"\n        The get_board function is a helper function that returns a TensorBoard object.\n        The TensorBoard object is used to log the training and validation loss, as well as\n        the accuracy of the model during training. The get_board function takes no arguments,\n        and returns an instance of torch.utils.tensorboard SummaryWriter class.\n\n        :param self: Represent the instance of the class\n        :return: A summary-writer object\n\n        \"\"\"\n        return torch.utils.tensorboard.SummaryWriter(\n            log_dir=str(self.get_path()),\n            comment=f\"{self.model_name}\",\n            filename_suffix=\"easydel\"\n        )\n</code></pre>"},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments.__init__","title":"<code>__init__(model_name, num_train_epochs, model_class=None, model_huggingface_repo_id=None, total_batch_size=32, max_training_steps=None, optimizer=EasyDelOptimizers.ADAMW, scheduler=EasyDelSchedulers.NONE, learning_rate=5e-05, learning_rate_end=5e-06, gradient_accumulation_steps=1, weight_decay=0.01, gradient_checkpointing=EasyDelGradientCheckPointers.NOTHING_SAVEABLE, max_sequence_length=4096, sharding_array=(1, -1, 1, 1), is_fine_tuning=True, do_train=True, do_eval=False, do_test=False, backend=None, extra_optimizer_kwargs=None, save_steps=None, save_dir='EasyDel-Checkpoints', use_pjit_attention_force=False, dtype=jnp.bfloat16, param_dtype=jnp.bfloat16, fully_sharded_data_parallel=True, use_wandb=True, custom_rule=None, extra_configs=None, ids_to_pop_from_dataset=None, remove_ckpt_after_load=False, configs_to_initialize_model_class=None, do_last_save=True, model_parameters=None, do_shard_fns=True, track_memory=True, loss_re_mat='', loss_chunk=1024, is_left_padded=False, warmup_steps=500, init_input_shape=(1, 1), step_partition_spec=PartitionSpec(('dp', 'fsdp'), 'sp'), training_time=None, dataloader_num_workers=0, dataloader_pin_memory=False, jax_distributed_config=None, log_all_workers=False, wandb_entity=None, save_optimizer_state=False, step_start_point=None, verbose=True, offload_device=jax.devices('cpu')[0], rapture_config=None, merge_lora_rapture_parameters=True, state_apply_fn_kwarguments_to_model=None, **kwargs)</code>","text":"<p>The init function is called when the class is instantiated. It sets up the attributes of an object, which are sometimes called fields or properties. The init function can accept arguments, just like a normal function.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>model_name</code> <code>str</code> <p>str: Specify the model name</p> required <code>num_train_epochs</code> <code>int</code> <p>int: Set the number of epochs for training</p> required <code>model_huggingface_repo_id</code> <code>Optional[str]</code> <p>Optional[str]: Load a pretrained model from the huggingface model hub</p> <code>None</code> <code>model_class</code> <code>Optional[EasyDelFlaxPretrainedModel | Type[EasyDelFlaxPretrainedModel]]</code> <p>Optional[EasyDelFlaxPretrainedModel]: Pass a model class to the trainer</p> <code>None</code> <code>total_batch_size</code> <code>int</code> <p>int: Set the batch size of the model</p> <code>32</code> <code>max_training_steps</code> <code>Optional[int]</code> <p>Optional[int]: Set the maximum number of steps to train for</p> <code>None</code> <code>optimizer</code> <code>AVAILABLE_OPTIMIZERS</code> <p>AVAILABLE_OPTIMIZERS: Specify the optimizer used to train the model</p> <code>ADAMW</code> <code>scheduler</code> <code>AVAILABLE_SCHEDULERS</code> <p>AVAILABLE_SCHEDULERS: Set the learning rate scheduler</p> <code>NONE</code> <code>learning_rate</code> <code>Union[int, float]</code> <p>Union[int: Set the learning rate for the optimizer</p> <code>5e-05</code> <code>float]</code> <p>Set the learning rate</p> required <code>learning_rate_end</code> <code>Optional[float]</code> <p>Optional[float]: Set the learning rate at the end of training</p> <code>5e-06</code> <code>gradient_accumulation_steps</code> <code>int</code> <p>int: Accumulate gradients over multiple batches</p> <code>1</code> <code>weight_decay</code> <code>float</code> <p>float: Specify the weight decay to be used by the optimizer</p> <code>0.01</code> <code>gradient_checkpointing</code> <code>AVAILABLE_GRADIENT_CHECKPOINTS</code> <p>AVAILABLE_GRADIENT_CHECKPOINTS: Determine how to use gradient checkpointing</p> <code>NOTHING_SAVEABLE</code> <code>max_sequence_length</code> <code>Optional[int]</code> <p>Optional[int]: Set the maximum length of the input sequence</p> <code>4096</code> <code>sharding_array</code> <code>Union[tuple, int]</code> <p>Union[tuple,int]: Specify the mesh of devices to use for training</p> <code>(1, -1, 1, 1)</code> <code>is_fine_tuning</code> <code>bool</code> <p>bool: Tell the model whether or not to initialize the weights of</p> <code>True</code> <code>do_train</code> <code>bool</code> <p>bool: Indicate whether to train the model or not</p> <code>True</code> <code>do_eval</code> <code>bool</code> <p>bool: Determine whether to run evaluation on the validation set after training</p> <code>False</code> <code>do_test</code> <code>Optional[bool]</code> <p>Optional[bool]: Determine if the model should be tested</p> <code>False</code> <code>backend</code> <code>Optional[str]</code> <p>Optional[str]: Specify the backend of jax</p> <code>None</code> <code>extra_optimizer_kwargs</code> <code>dict</code> <p>dict: Pass extra arguments to the optimizer</p> <code>None</code> <code>save_steps</code> <code>Optional[int]</code> <p>Optional[int]: Save the model after every n steps</p> <code>None</code> <code>save_dir</code> <code>str</code> <p>str: Define the directory where the checkpoints will be saved</p> <code>'EasyDel-Checkpoints'</code> <code>use_pjit_attention_force</code> <code>bool</code> <p>bool: Force the use of pjit for attention layers</p> <code>False</code> <code>dtype</code> <code>dtype</code> <p>jnp.dtype: Set the dtype of the model parameters</p> <code>bfloat16</code> <code>param_dtype</code> <code>dtype</code> <p>jnp.dtype: Specify the data type of the model parameters</p> <code>bfloat16</code> <code>fully_sharded_data_parallel</code> <code>bool</code> <p>bool: Determine if the model should be fully fsdp or not</p> <code>True</code> <code>use_wandb</code> <code>bool</code> <p>bool: Enable or disable the wandb logging</p> <code>True</code> <code>custom_rule</code> <code>Mapping[str, PartitionSpec]</code> <p>Mapping[str, PartitionSpec]: Specify the partitioning rules of the model</p> <code>None</code> <code>extra_configs</code> <code>Optional[dict]</code> <p>Optional[dict]: Pass extra configurations to the model class</p> <code>None</code> <code>ids_to_pop_from_dataset</code> <code>Optional[list]</code> <p>Optional[list]: Remove some of the ids from the dataset</p> <code>None</code> <code>remove_ckpt_after_load</code> <code>bool</code> <p>bool: Remove the checkpoint after loading it</p> <code>False</code> <code>configs_to_initialize_model_class</code> <code>Optional[dict]</code> <p>Optional[dict]: Pass extra configurations to the model class</p> <code>None</code> <code>do_last_save</code> <code>bool</code> <p>bool: Save the model after training is complete</p> <code>True</code> <code>model_parameters</code> <code>Optional[dict]</code> <p>Optional[dict]: Pass the model parameters to the model class</p> <code>None</code> <code>do_shard_fns</code> <code>bool</code> <p>bool: Shard the model functions across devices</p> <code>True</code> <code>track_memory</code> <code>bool</code> <p>bool: Track the memory usage of the model</p> <code>True</code> <code>loss_re_mat</code> <code>str</code> <p>str: Specify the regular expression to match the loss function name</p> <code>''</code> <code>loss_chunk</code> <code>int</code> <p>int: Chunk the loss to avoid memory overflow</p> <code>1024</code> <code>is_left_padded</code> <code>bool</code> <p>bool: Determine if the input is left padded or not</p> <code>False</code> <code>warmup_steps</code> <code>int</code> <p>int: Specify the number of steps to warm up the learning rate</p> <code>500</code> <code>init_input_shape</code> <code>Tuple[int, int]</code> <p>Tuple[int, int]: Initialize the model with a shape that is not (batch_size, length)</p> <code>(1, 1)</code> <code>step_partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec: Partition the model for training</p> <code>PartitionSpec(('dp', 'fsdp'), 'sp')</code> <code>training_time</code> <code>Optional[str]</code> <p>Optional[str]: Set a time limit for the training process</p> <code>None</code> <code>dataloader_num_workers</code> <code>Optional[int]</code> <p>Optional[int]: Set the number of workers used by pytorch's</p> <code>0</code> <code>dataloader_pin_memory</code> <code>Optional[bool]</code> <p>Optional[bool]: Pin the memory of the dataloader</p> <code>False</code> <code>jax_distributed_config</code> <code>Optional[dict]</code> <p>Optional[dict]: Configure the jax distributed backend</p> <code>None</code> <code>log_all_workers</code> <code>bool</code> <p>bool: Log all workers in wandb,</p> <code>False</code> <code>wandb_entity</code> <code>Optional[str]</code> <p>Optional[str]: Specify the entity to use when logging to weights &amp; biases</p> <code>None</code> <code></code> <code>save_optimizer_state</code> <p>bool: when ever to save optimizer state and other args in checkpoint</p> required <code>step_start_point</code> <code>Optional[int]</code> <p>Optional[int]: start training from given step for example instead of starting training from step 0 it will start from 20000 and leave the data behind</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>bool: when ever to turn verbose mode of or on</p> <code>True</code> <code>offload_device</code> <code>Device</code> <p>jax.Device: device to be used to offload parameters on</p> <code>devices('cpu')[0]</code> <code>rapture_config</code> <code>Optional[EasyDeLXRapTureConfig]</code> <p>Optional[EasyDeLXRaptureConfig]: LoRA Config for models</p> <code>None</code> <code>merge_lora_rapture_parameters</code> <code>bool</code> <p>bool: whenever to merge lora parameters with original parameters before saving</p> <code>True</code> <code>state_apply_fn_kwarguments_to_model</code> <code>Optional[dict]</code> <p>Optional[dict]: state_apply_fn_kwarguments_to_model is a dictionary that be used to apply the parameters and extra things that you want to deliver to model.</p> <code>None</code> <code>**kwargs</code> <p>Pass keyword, variable-length argument list</p> <code>{}</code> <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>def __init__(\n        self,\n        model_name: str,\n        num_train_epochs: int,\n        model_class: Optional[EasyDelFlaxPretrainedModel | Type[EasyDelFlaxPretrainedModel]] = None,\n        model_huggingface_repo_id: Optional[str] = None,\n        total_batch_size: int = 32,\n        max_training_steps: Optional[int] = None,\n        optimizer: AVAILABLE_OPTIMIZERS = EasyDelOptimizers.ADAMW,\n        scheduler: AVAILABLE_SCHEDULERS = EasyDelSchedulers.NONE,\n        learning_rate: Union[int, float] = 5e-5,\n        learning_rate_end: Optional[float] = 5e-6,\n        gradient_accumulation_steps: int = 1,\n        weight_decay: float = 0.01,\n        gradient_checkpointing: AVAILABLE_GRADIENT_CHECKPOINTS = EasyDelGradientCheckPointers.NOTHING_SAVEABLE,\n        max_sequence_length: Optional[int] = 4096,\n        sharding_array: Union[tuple, int] = (1, -1, 1, 1),\n        is_fine_tuning: bool = True,\n        do_train: bool = True,\n        do_eval: bool = False,\n        do_test: Optional[bool] = False,\n        backend: Optional[str] = None,\n        extra_optimizer_kwargs: dict = None,\n        save_steps: Optional[int] = None,\n        save_dir: str = \"EasyDel-Checkpoints\",\n        use_pjit_attention_force: bool = False,\n        dtype: jnp.dtype = jnp.bfloat16,\n        param_dtype: jnp.dtype = jnp.bfloat16,\n        fully_sharded_data_parallel: bool = True,\n        use_wandb: bool = True,\n        custom_rule: Mapping[str, PartitionSpec] = None,\n        extra_configs: Optional[dict] = None,\n        ids_to_pop_from_dataset: Optional[list] = None,\n        remove_ckpt_after_load: bool = False,\n        configs_to_initialize_model_class: Optional[dict] = None,\n        do_last_save: bool = True,\n        model_parameters: Optional[dict] = None,\n        do_shard_fns: bool = True,\n        track_memory: bool = True,\n        loss_re_mat: str = \"\",\n        loss_chunk: int = 1024,\n        is_left_padded: bool = False,\n        warmup_steps: int = 500,\n        init_input_shape: Tuple[int, int] = (1, 1),\n        step_partition_spec: PartitionSpec = PartitionSpec((\"dp\", \"fsdp\"), \"sp\"),\n        training_time: Optional[str] = None,\n        dataloader_num_workers: Optional[int] = 0,\n        dataloader_pin_memory: Optional[bool] = False,\n        jax_distributed_config: Optional[dict] = None,\n        log_all_workers: bool = False,\n        wandb_entity: Optional[str] = None,\n        save_optimizer_state: bool = False,\n        step_start_point: Optional[int] = None,\n        verbose: bool = True,\n        offload_device: jax.Device = jax.devices(\"cpu\")[0],\n        rapture_config: Optional[EasyDeLXRapTureConfig] = None,\n        merge_lora_rapture_parameters: bool = True,\n        state_apply_fn_kwarguments_to_model: Optional[dict] = None,\n        **kwargs\n):\n    \"\"\"\nThe __init__ function is called when the class is instantiated.\nIt sets up the attributes of an object, which are sometimes called fields or properties.\nThe __init__ function can accept arguments, just like a normal function.\n\n:param self: Represent the instance of the class\n:param model_name: str: Specify the model name\n:param num_train_epochs: int: Set the number of epochs for training\n:param model_huggingface_repo_id: Optional[str]: Load a pretrained model from the huggingface model hub\n:param model_class: Optional[EasyDelFlaxPretrainedModel]: Pass a model class to the trainer\n:param total_batch_size: int: Set the batch size of the model\n:param max_training_steps: Optional[int]: Set the maximum number of steps to train for\n:param optimizer: AVAILABLE_OPTIMIZERS: Specify the optimizer used to train the model\n:param scheduler: AVAILABLE_SCHEDULERS: Set the learning rate scheduler\n:param learning_rate: Union[int: Set the learning rate for the optimizer\n:param float]: Set the learning rate\n:param learning_rate_end: Optional[float]: Set the learning rate at the end of training\n:param gradient_accumulation_steps: int: Accumulate gradients over multiple batches\n:param weight_decay: float: Specify the weight decay to be used by the optimizer\n:param gradient_checkpointing: AVAILABLE_GRADIENT_CHECKPOINTS: Determine how to use gradient checkpointing\n:param max_sequence_length: Optional[int]: Set the maximum length of the input sequence\n:param sharding_array: Union[tuple,int]: Specify the mesh of devices to use for training\n:param is_fine_tuning: bool: Tell the model whether or not to initialize the weights of\n:param do_train: bool: Indicate whether to train the model or not\n:param do_eval: bool: Determine whether to run evaluation on the validation set after training\n:param do_test: Optional[bool]: Determine if the model should be tested\n:param backend: Optional[str]: Specify the backend of jax\n:param extra_optimizer_kwargs: dict: Pass extra arguments to the optimizer\n:param save_steps: Optional[int]: Save the model after every n steps\n:param save_dir: str: Define the directory where the checkpoints will be saved\n:param use_pjit_attention_force: bool: Force the use of pjit for attention layers\n:param dtype: jnp.dtype: Set the dtype of the model parameters\n:param param_dtype: jnp.dtype: Specify the data type of the model parameters\n:param fully_sharded_data_parallel: bool: Determine if the model should be fully fsdp or not\n:param use_wandb: bool: Enable or disable the wandb logging\n:param custom_rule: Mapping[str, PartitionSpec]: Specify the partitioning rules of the model\n:param extra_configs: Optional[dict]: Pass extra configurations to the model class\n:param ids_to_pop_from_dataset: Optional[list]: Remove some of the ids from the dataset\n:param remove_ckpt_after_load: bool: Remove the checkpoint after loading it\n:param configs_to_initialize_model_class: Optional[dict]: Pass extra configurations to the model class\n:param do_last_save: bool: Save the model after training is complete\n:param model_parameters: Optional[dict]: Pass the model parameters to the model class\n:param do_shard_fns: bool: Shard the model functions across devices\n:param track_memory: bool: Track the memory usage of the model\n:param loss_re_mat: str: Specify the regular expression to match the loss function name\n:param loss_chunk: int: Chunk the loss to avoid memory overflow\n:param is_left_padded: bool: Determine if the input is left padded or not\n:param warmup_steps: int: Specify the number of steps to warm up the learning rate\n:param init_input_shape: Tuple[int, int]: Initialize the model with a shape that is not (batch_size, length)\n:param step_partition_spec: PartitionSpec: Partition the model for training\n:param training_time: Optional[str]: Set a time limit for the training process\n:param dataloader_num_workers: Optional[int]: Set the number of workers used by pytorch's\n:param dataloader_pin_memory: Optional[bool]: Pin the memory of the dataloader\n:param jax_distributed_config: Optional[dict]: Configure the jax distributed backend\n:param log_all_workers: bool: Log all workers in wandb,\n:param wandb_entity: Optional[str]: Specify the entity to use when logging to weights &amp;amp; biases\n:param save_optimizer_state : bool: when ever to save optimizer state and other args in checkpoint\n:param step_start_point: Optional[int]: start training from given step for example instead of starting training from\nstep 0 it will start from 20000 and leave the data behind\n:param verbose: bool: when ever to turn verbose mode of or on\n:param offload_device: jax.Device: device to be used to offload parameters on\n:param rapture_config: Optional[EasyDeLXRaptureConfig]: LoRA Config for models\n:param merge_lora_rapture_parameters: bool: whenever to merge lora parameters with original parameters before saving\n:param state_apply_fn_kwarguments_to_model: Optional[dict]: state_apply_fn_kwarguments_to_model is a dictionary that\nbe used to apply the parameters and extra things that you want to deliver to model.\n:param **kwargs: Pass keyword, variable-length argument list\n:return: Nothing\n    \"\"\"\n    super().__init__()\n\n    if ids_to_pop_from_dataset is None:\n        ids_to_pop_from_dataset = []\n    if extra_optimizer_kwargs is None:\n        extra_optimizer_kwargs = {}\n\n    if model_class is None and model_huggingface_repo_id is None:\n        print(\n            termcolor.colored(\n                \"Warning : \", color=\"red\", force_color=True\n            ) + termcolor.colored(\n                \"You should at least pass model_class or model_huggingface_repo_id if you want to use \"\n                \"CasualLanguageModel Trainer But in case that you want to use \"\n                \"DPOTrainer you can ignore this warning\", color=\"white\",\n                force_color=True\n            )\n        )\n    assert backend in AVAILABLE_BACKENDS, (\n        f\"{backend} is not recognized, \"\n        f\"available backends are {AVAILABLE_BACKENDS}\"\n    )\n\n    available_backends = len(jax.devices(backend))\n\n    total_batch_size *= gradient_accumulation_steps\n\n    array_devices = jnp.ones((available_backends, 1)).reshape(sharding_array)\n\n    JaxDistributedConfig.initialize(jax_distributed_config)\n\n    self.available_backends = available_backends\n    self.array_devices_shape = array_devices.shape\n    self.model_huggingface_repo_id = model_huggingface_repo_id\n    self.num_train_epochs = num_train_epochs\n    self.wandb_entity = wandb_entity\n    self.total_batch_size = total_batch_size\n    self.max_training_steps = max_training_steps\n    self.optimizer = optimizer\n    self.scheduler = scheduler\n    self.extra_optimizer_kwargs = extra_optimizer_kwargs\n    self.learning_rate = learning_rate\n    self.learning_rate_end = learning_rate_end\n    self.weight_decay = weight_decay\n    self.model_name = model_name\n    self.gradient_checkpointing = gradient_checkpointing\n    self.max_sequence_length = max_sequence_length\n    self.sharding_array = sharding_array\n    self.is_fine_tuning = is_fine_tuning\n    self.do_train = do_train\n    self.do_eval = do_eval\n    self.do_test = do_test\n    self.save_steps = save_steps\n    self.save_dir = save_dir\n    self.use_pjit_attention_force = use_pjit_attention_force\n    self.dtype = dtype\n    self.warmup_steps = warmup_steps\n    self.param_dtype = param_dtype\n    self.fully_sharded_data_parallel = fully_sharded_data_parallel\n    self.use_wandb = use_wandb\n    self.custom_rule = custom_rule\n    self.extra_configs = extra_configs\n    self.ids_to_pop_from_dataset = ids_to_pop_from_dataset\n    self.remove_ckpt_after_load = remove_ckpt_after_load\n    self.model_class = model_class\n    self.configs_to_initialize_model_class = configs_to_initialize_model_class\n    self.do_last_save = do_last_save\n    self.model_parameters = model_parameters\n    self.do_shard_fns = do_shard_fns\n    self.gradient_accumulation_steps = gradient_accumulation_steps\n    self.track_memory = track_memory\n    self.loss_chunk = loss_chunk\n    self.loss_re_mat = loss_re_mat\n    self.init_input_shape = init_input_shape\n    self.is_left_padded = is_left_padded\n    self.step_partition_spec = step_partition_spec\n    self.jax_distributed_config = jax_distributed_config\n    self.log_all_workers = log_all_workers\n    self.dataloader_num_workers = dataloader_num_workers\n    self.dataloader_pin_memory = dataloader_pin_memory\n    self.save_optimizer_state = save_optimizer_state\n    self.step_start_point = step_start_point if step_start_point is not None else 0\n    self.verbose = verbose\n    self.offload_device = offload_device\n    self.optimizer_kwargs = dict(\n        learning_rate=self.learning_rate,\n        learning_rate_end=self.learning_rate_end,\n        optimizer=self.optimizer,\n        scheduler=self.scheduler,\n        extra_optimizer_kwargs=self.extra_optimizer_kwargs,\n        warmup_steps=self.warmup_steps,\n        gradient_accumulation_steps=self.gradient_accumulation_steps,\n        weight_decay=self.weight_decay,\n        steps=self.max_training_steps,\n    )\n    self.training_time = self._time_to_seconds(training_time) if training_time is not None else None\n    torch.set_default_device(\"cpu\")\n    self.merge_lora_rapture_parameters = merge_lora_rapture_parameters\n    self.rapture = None\n    self.rapture_config = None\n    self.state_apply_fn_kwarguments_to_model = (\n        state_apply_fn_kwarguments_to_model\n    ) if state_apply_fn_kwarguments_to_model is not None else {}\n    if rapture_config is not None:\n        print(\n            termcolor.colored(\"Warning : \", color=\"red\", force_color=True),\n            termcolor.colored(\n                \"You are using LoRA (Low-Rank Adaptation of Large Language Models) and this feature is\"\n                \"still in Beta mode so it might act unexpected\", color=\"red\", force_color=True\n            )\n        )\n        self.rapture_config = rapture_config\n        self.rapture = XRapTure(config=rapture_config)\n\n    self.__dict__.update(**kwargs)\n</code></pre>"},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments.ckpt_path_exists","title":"<code>ckpt_path_exists()</code>","text":"<p>The ckpt_path_exists function checks to see if the path exists. If it does not, then it creates a new directory.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A path</p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>def ckpt_path_exists(self):\n    \"\"\"\n    The ckpt_path_exists function checks to see if the path exists. If it does not, then it creates a new directory.\n\n    :param self: Represent the instance of the class\n    :return: A path\n\n    \"\"\"\n    path = self.get_path()\n    if not path.exists():\n        path.mkdir(parents=True)\n</code></pre>"},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments.get_board","title":"<code>get_board()</code>","text":"<p>The get_board function is a helper function that returns a TensorBoard object. The TensorBoard object is used to log the training and validation loss, as well as the accuracy of the model during training. The get_board function takes no arguments, and returns an instance of torch.utils.tensorboard SummaryWriter class.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A summary-writer object</p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>def get_board(self):\n    \"\"\"\n    The get_board function is a helper function that returns a TensorBoard object.\n    The TensorBoard object is used to log the training and validation loss, as well as\n    the accuracy of the model during training. The get_board function takes no arguments,\n    and returns an instance of torch.utils.tensorboard SummaryWriter class.\n\n    :param self: Represent the instance of the class\n    :return: A summary-writer object\n\n    \"\"\"\n    return torch.utils.tensorboard.SummaryWriter(\n        log_dir=str(self.get_path()),\n        comment=f\"{self.model_name}\",\n        filename_suffix=\"easydel\"\n    )\n</code></pre>"},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments.get_mesh","title":"<code>get_mesh()</code>","text":"<p>The get_mesh function is used to create a mesh object that can be used to define the geometry of the device. The mesh object contains two arrays: a list of vertices and a list of faces. Each face is defined by three indices, which correspond to three vertices in the vertex array. The get_mesh function is called when creating an instance of DeviceGeometry, which is then passed into an instance of DeviceSimulation.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Refer to the object itself</p> required <p>Returns:</p> Type Description <p>A mesh object with the device array shape and the mesh names</p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>def get_mesh(self):\n    \"\"\"\n    The get_mesh function is used to create a mesh object that can be used\n    to define the geometry of the device. The mesh object contains two arrays:\n    a list of vertices and a list of faces. Each face is defined by three indices,\n    which correspond to three vertices in the vertex array. The get_mesh function\n    is called when creating an instance of DeviceGeometry, which is then passed\n    into an instance of DeviceSimulation.\n\n    :param self: Refer to the object itself\n    :return: A mesh object with the device array shape and the mesh names\n\n    \"\"\"\n    return Mesh(\n        create_device_mesh(\n            self.array_devices_shape\n        ),\n        self.get_mesh_names()\n    )\n</code></pre>"},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments.get_meter_dict","title":"<code>get_meter_dict()</code>","text":"<p>The get_meter_dict function is used to return a dictionary of the hyperparameters. The function iterates through all the attributes in the class and returns a dictionary with the key as \"hyperparameters/{k}\" and value as v for each attribute k,v in self.dict if it is an  instance of int, float, str, bool or torch.Tensor.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A dictionary of hyperparameters</p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>def get_meter_dict(self):\n    \"\"\"\n    The get_meter_dict function is used to return a dictionary of the hyperparameters.\n    The function iterates through all the attributes in the class and returns a dictionary with\n    the key as &amp;quot;hyperparameters/{k}&amp;quot; and value as v for each attribute k,v in self.__dict__ if it is an\n     instance of int, float, str, bool or torch.Tensor.\n\n    :param self: Represent the instance of the class\n    :return: A dictionary of hyperparameters\n\n    \"\"\"\n    return {\n        f\"hyperparameters/{k}\": v for k, v in self.__dict__.items() if\n        isinstance(v, (int, float, str, bool, torch.Tensor))\n    }\n</code></pre>"},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments.get_path","title":"<code>get_path()</code>","text":"<p>The get_path function returns a pathlib.Path object, which is a class that represents file paths and provides methods for interacting with the files at those paths. The get_path function takes no arguments and returns an instance of the Path class initialized with two arguments: self.save_dir (a string) and self.model_name (also a string). The save directory is the directory where we'll store our model checkpoints, while the model name will be used to create unique filenames for each checkpoint.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A pathlib</p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>def get_path(self):\n    \"\"\"\n    The get_path function returns a pathlib.Path object, which is a class that\n    represents file paths and provides methods for interacting with the files at\n    those paths. The get_path function takes no arguments and returns an instance of\n    the Path class initialized with two arguments: self.save_dir (a string) and\n    self.model_name (also a string). The save directory is the directory where we'll\n    store our model checkpoints, while the model name will be used to create unique\n    filenames for each checkpoint.\n\n    :param self: Represent the instance of the class\n    :return: A pathlib\n\n    \"\"\"\n    return pathlib.Path(\n        self.save_dir, self.model_name\n    )\n</code></pre>"},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments.get_streaming_checkpointer","title":"<code>get_streaming_checkpointer()</code>","text":"<p>The get_streaming_checkpointer function is used to save the model's weights. The streaming checkpointer saves the model's weights in a file called \"checkpoint\" and then saves a copy of that file with an incrementing number appended to it (e.g., checkpoint_001, checkpoint_002, etc.). This allows you to keep multiple versions of your trained models.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>A CheckpointManager object</p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>def get_streaming_checkpointer(self):\n    \"\"\"\n    The get_streaming_checkpointer function is used to save the model's weights.\n    The streaming checkpointer saves the model's weights in a file called &amp;quot;checkpoint&amp;quot; and then\n    saves a copy of that file with an incrementing number appended to it (e.g., checkpoint_001,\n    checkpoint_002, etc.). This allows you to keep multiple versions of your trained models.\n\n    :param self: Represent the instance of the class\n    :return: A CheckpointManager object\n\n    \"\"\"\n    return CheckpointManager(\n        os.path.join(self.save_dir, self.model_name),\n        save_optimizer_state=self.save_optimizer_state,\n        verbose=self.verbose\n    )\n</code></pre>"},{"location":"generated-trainer-training_configurations/#lib.python.EasyDel.trainer.training_configurations.TrainArguments.get_wandb_init","title":"<code>get_wandb_init()</code>","text":"<p>The get_wandb_init function is a helper function that returns the wandb.init() call with the project name, config object, and tags set to appropriate values for this model.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Pass the class instance to the function</p> required <p>Returns:</p> Type Description <code>Run | RunDisabled | None</code> <p>A wandb or None</p> Source code in <code>lib/python/EasyDel/trainer/training_configurations.py</code> <pre><code>def get_wandb_init(self) -&gt; Run | RunDisabled | None:\n    \"\"\"\n    The get_wandb_init function is a helper function that returns the wandb.init() call with\n    the project name, config object, and tags set to appropriate values for this model.\n\n    :param self: Pass the class instance to the function\n    :return: A wandb or None\n\n    \"\"\"\n    return wandb.init(\n        project=f\"EasyDeL-{self.model_name}\",\n        config=self(),\n        tags=[\n            \"Easy Del\",\n            \"FJFormer\",\n            \"OST-OpenSourceTransformers\",\n            \"Jax/Flax\"\n        ],\n        entity=self.wandb_entity\n\n    ) if self.log_all_workers or (jax.process_index() == 0) else None\n</code></pre>"},{"location":"generated-trainer-utils/","title":"trainer.utils","text":""},{"location":"generated-trainer-utils/#lib.python.EasyDel.trainer.utils.JaxDistributedConfig","title":"<code>JaxDistributedConfig</code>","text":"<p>             Bases: <code>object</code></p> <p>Utility class for initializing JAX distributed.</p> Source code in <code>lib/python/EasyDel/trainer/utils.py</code> <pre><code>class JaxDistributedConfig(object):\n    \"\"\" Utility class for initializing JAX distributed. \"\"\"\n\n    @staticmethod\n    def get_default_config(updates=None):\n        config = ConfigDict()\n        config.initialize_jax_distributed = False\n        config.coordinator_address = placeholder(str)\n        config.num_processes = placeholder(int)\n        config.process_id = placeholder(int)\n        config.local_device_ids = placeholder(str)\n\n        if updates is not None:\n            config.update(ConfigDict(updates).copy_and_resolve_references())\n        return config\n\n    @classmethod\n    def initialize(cls, config):\n        config = cls.get_default_config(config)\n        if config.initialize_jax_distributed:\n            if config.local_device_ids is not None:\n                local_device_ids = [int(x) for x in config.local_device_ids.split(',')]\n            else:\n                local_device_ids = None\n\n            jax.distributed.initialize(\n                coordinator_address=config.coordinator_address,\n                num_processes=config.num_processes,\n                process_id=config.process_id,\n                local_device_ids=local_device_ids,\n            )\n</code></pre>"},{"location":"generated-transform-easydel_transform/","title":"transform.easydel_transform","text":""},{"location":"generated-transform-easydel_transform/#lib.python.EasyDel.transform.easydel_transform.float_tensor_to_dtype","title":"<code>float_tensor_to_dtype(tensor, dtype)</code>","text":"<p>The float_tensor_to_dtype function is used to convert a tensor's dtype to the specified dtype.</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <p>Convert the tensor to a float dtype</p> required <code>dtype</code> <p>Convert the tensor to a specific dtype</p> required <p>Returns:</p> Type Description <p>A tensor with the specified dtype</p> Source code in <code>lib/python/EasyDel/transform/easydel_transform.py</code> <pre><code>def float_tensor_to_dtype(tensor, dtype):\n    \"\"\"\n    The float_tensor_to_dtype function is used to convert a tensor's dtype to the specified dtype.\n\n    :param tensor: Convert the tensor to a float dtype\n    :param dtype: Convert the tensor to a specific dtype\n    :return: A tensor with the specified dtype\n\n    \"\"\"\n    if dtype is None or dtype == \"\":\n        return tensor\n    if isinstance(dtype, str):\n        dtype = get_dtype(dtype)\n    float_dtypes = (jax.numpy.bfloat16, jax.numpy.float16, jax.numpy.float32, jax.numpy.float64)\n    if getattr(tensor, \"dtype\", None) in float_dtypes:\n        tensor = tensor.astype(dtype)\n    return tensor\n</code></pre>"},{"location":"generated-transform-easydel_transform/#lib.python.EasyDel.transform.easydel_transform.huggingface_to_easydel","title":"<code>huggingface_to_easydel(state_dict, *, device, embedding_layer_names=None, layer_norm_names=None, shard_fns=None, dtype=jax.numpy.float16, **kwargs)</code>","text":"<p>The huggingface_to_easydel function takes a huggingface model's state_dict and converts it to an easydel model's flax_dict. The function is designed to be used in conjunction with the load_huggingface function, which loads a huggingface model from disk. The embedding layer name must be specified as well as the device on which the conversion will take place.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <p>Load the weights from a huggingface model</p> required <code>embedding_layer_names</code> <code>Optional[List[str]]</code> <p>List[str]: Identify the embedding layer in the huggingface model</p> <code>None</code> <code>device</code> <p>Determine which device the model will be loaded on</p> required <code>layer_norm_names</code> <code>Optional[List[str]]</code> <p>Replaces weight or kernel with (scale)</p> <code>None</code> <code>shard_fns</code> <code>Optional[Mapping[tuple, Callable]]</code> <p>Optional[Mapping[tuple, Callable]]: Sharding Function to be used to shard model</p> <code>None</code> <code>dtype</code> <code>dtype</code> <p>jax.numpy.dtype: Specify the data type of the tensors</p> <code>float16</code> <p>Returns:</p> Type Description <p>A dictionary of the weights and biases in a format that can be used by flax (it's an UnFlattenDict)</p> Source code in <code>lib/python/EasyDel/transform/easydel_transform.py</code> <pre><code>def huggingface_to_easydel(\n        state_dict,\n        *,\n        device,\n        embedding_layer_names: Optional[List[str]] = None,\n        layer_norm_names: Optional[List[str]] = None,\n        shard_fns: Optional[Mapping[tuple, Callable]] = None,\n        dtype: jax.numpy.dtype = jax.numpy.float16,\n        **kwargs\n):\n    \"\"\"\n    The huggingface_to_easydel function takes a huggingface model's state_dict and converts it to an easydel\n    model's flax_dict. The function is designed to be used in conjunction with the load_huggingface function, which\n    loads a huggingface model from disk. The embedding layer name must be specified as well as the device on which\n    the conversion will take place.\n\n    :param state_dict: Load the weights from a huggingface model\n    :param embedding_layer_names: List[str]: Identify the embedding layer in the huggingface model\n    :param device: Determine which device the model will be loaded on\n    :param layer_norm_names: Replaces weight or kernel with (scale)\n    :param shard_fns: Optional[Mapping[tuple, Callable]]: Sharding Function to be used to shard model\n    :param dtype: jax.numpy.dtype: Specify the data type of the tensors\n    :return: A dictionary of the weights and biases in a format that can be used by flax (it's an UnFlattenDict)\n\n    \"\"\"\n    embedding_layer_names = embedding_layer_names or []\n    layer_norm_names = layer_norm_names or []\n    if isinstance(embedding_layer_names, str):\n        embedding_layer_names = [embedding_layer_names]\n    _l = len(\".weight\")\n    _b = len(\".bias\")\n    with jax.default_device(device):\n        flax_dict = {}\n        for key, tensor in state_dict.items():\n            do_rc = True\n            for embedding_layer_name in embedding_layer_names:\n                if embedding_layer_name in key:\n                    key = key[:-_l] + \".embedding\"\n                    do_rc = False\n            for layer_norm in layer_norm_names:\n                if layer_norm in key:\n                    if key.endswith(\".weight\"):\n                        key = key[:-_l] + \".scale\"\n                        do_rc = False\n            if match_keywords(key, [\"weight\"], [\"none\"]) and do_rc:\n                if len(tensor.shape) == 2:\n                    tensor = tensor.transpose(0, 1)\n                if key.endswith(\".weight\"):\n                    key = key[:-_l] + \".kernel\"\n            key_tuple = key.split(\".\")\n            key_names = ()\n            tensor = tensor.detach().cpu().numpy()\n\n            for k in key_tuple:\n                key_names += k,\n            if shard_fns is not None:\n                tensor = shard_fns[key_names](tensor)\n            flax_dict[key_names] = tensor\n        return flax.traverse_util.unflatten_dict(flax_dict)\n</code></pre>"},{"location":"generated-transform-easydel_transform/#lib.python.EasyDel.transform.easydel_transform.match_keywords","title":"<code>match_keywords(string, ts, ns)</code>","text":"<p>The match_keywords function takes a string, and two lists of strings. The first list is the \"must-have\" keywords, and the second list is the \"not-allowed\" keywords. It returns True if all of the must-have keywords are in string, but none of not allowed are in it.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <p>Pass in the text that is being searched</p> required <code>ts</code> <p>Specify the required keywords and ns is used to specify the non-required keywords</p> required <code>ns</code> <p>Specify a list of negative keywords</p> required <p>Returns:</p> Type Description <p>True if all the keywords in ts are present and none of the</p> Source code in <code>lib/python/EasyDel/transform/easydel_transform.py</code> <pre><code>def match_keywords(string, ts, ns):\n    \"\"\"\n    The match_keywords function takes a string, and two lists of strings.\n    The first list is the &amp;quot;must-have&amp;quot; keywords, and the second list is the &amp;quot;not-allowed&amp;quot; keywords.\n    It returns True if all of the must-have keywords are in string, but none of not allowed are in it.\n\n    :param string: Pass in the text that is being searched\n    :param ts: Specify the required keywords and ns is used to specify the non-required keywords\n    :param ns: Specify a list of negative keywords\n    :return: True if all the keywords in ts are present and none of the\n\n    \"\"\"\n    for t in ts:\n        if t not in string:\n            return False\n    for n in ns:\n        if n in string:\n            return False\n    return True\n</code></pre>"},{"location":"generated-transform-easydel_transform/#lib.python.EasyDel.transform.easydel_transform.read_ckpt","title":"<code>read_ckpt(path, shard_fns=None, add_extra_past_fix=None)</code>","text":"<p>The read_ckpt function reads a checkpoint file and returns the tensors in it.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>[str, PathLike]</code> <p>[str, os.PathLike]: Specify the path to the checkpoint file</p> required <code>shard_fns</code> <p>Shard the tensors</p> <code>None</code> <code>add_extra_past_fix</code> <code>list</code> <p>list: Add an extra past to the key</p> <code>None</code> <p>Returns:</p> Type Description <p>A dictionary of tensors</p> Source code in <code>lib/python/EasyDel/transform/easydel_transform.py</code> <pre><code>def read_ckpt(path: [str, os.PathLike], shard_fns=None, add_extra_past_fix: list = None):\n    \"\"\"\n    The read_ckpt function reads a checkpoint file and returns the tensors in it.\n\n    :param path: [str, os.PathLike]: Specify the path to the checkpoint file\n    :param shard_fns: Shard the tensors\n    :param add_extra_past_fix: list: Add an extra past to the key\n    :return: A dictionary of tensors\n\n    \"\"\"\n    tensors = {}\n    with open(path, \"rb\") as stream:\n        unpacker = msgpack.Unpacker(stream, read_size=83886080, max_buffer_size=0)\n        for key, value in unpacker:\n            if add_extra_past_fix is not None:\n                key = add_extra_past_fix + key\n            key = tuple(key)\n            tensor = from_bytes(None, value)\n            if shard_fns is not None:\n                tensor = shard_fns[key](tensor)\n            tensors[key] = tensor\n    return tensors\n</code></pre>"},{"location":"generated-transform-easydel_transform/#lib.python.EasyDel.transform.easydel_transform.save_ckpt","title":"<code>save_ckpt(train_state, path, gather_fns=None, float_dtype=None)</code>","text":"<p>The save_ckpt function saves the state of a training run to disk.</p> <p>Parameters:</p> Name Type Description Default <code>train_state</code> <p>Store the current state of the training process</p> required <code>path</code> <p>Specify the location of the checkpoint file</p> required <code>gather_fns</code> <p>Specify a function that will be used to convert the tensor to bytes</p> <code>None</code> <code>float_dtype</code> <p>Convert the tensor to a specific dtype</p> <code>None</code> <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>lib/python/EasyDel/transform/easydel_transform.py</code> <pre><code>def save_ckpt(train_state, path, gather_fns=None, float_dtype=None):\n    \"\"\"\n    The save_ckpt function saves the state of a training run to disk.\n\n    :param train_state: Store the current state of the training process\n    :param path: Specify the location of the checkpoint file\n    :param gather_fns: Specify a function that will be used to convert the tensor to bytes\n    :param float_dtype: Convert the tensor to a specific dtype\n    :return: Nothing\n\n    \"\"\"\n\n    train_state = to_state_dict(train_state)\n    packer = msgpack.Packer()\n    flatten_train_state = flatten_dict(train_state)\n    if gather_fns is not None:\n        gather_fns = flatten_dict(to_state_dict(gather_fns))\n\n    with open(path, \"wb\") as stream:\n        for key, value in flatten_train_state.items():\n            if gather_fns is not None:\n                value = gather_fns[key](value)\n            value = float_tensor_to_dtype(value, float_dtype)\n            stream.write(packer.pack((key, to_bytes(value))))\n</code></pre>"},{"location":"generated-transform-falcon/","title":"transform.falcon","text":""},{"location":"generated-transform-falcon/#lib.python.EasyDel.transform.falcon.falcon_from_pretrained","title":"<code>falcon_from_pretrained(model_id, device)</code>","text":"<p>return: Weight or Params for EasyDel Model , Config</p> Source code in <code>lib/python/EasyDel/transform/falcon.py</code> <pre><code>def falcon_from_pretrained(model_id, device):\n    \"\"\"\n    return: Weight or Params for EasyDel Model , Config\n    \"\"\"\n    # Requested By vwxyzjn at https://github.com/erfanzar/EasyDeL/issues/15#issue-1881044170\n    config = FalconConfig.from_pretrained(model_id)\n    model = FalconForCausalLM.from_pretrained(model_id)\n    easydel_wights = falcon_convert_pt_to_flax_7b(\n        state_dict=model.state_dict(),\n        config=config,\n        device=device\n    )\n    del model\n    gc.collect()\n    config.add_jax_args()\n    return easydel_wights, config\n</code></pre>"},{"location":"generated-transform-llama/","title":"transform.llama","text":""},{"location":"generated-transform-llama/#lib.python.EasyDel.transform.llama.llama_easydel_to_hf","title":"<code>llama_easydel_to_hf(path, config)</code>","text":"<p>Takes path to easydel saved ckpt and return the model in pytorch (Transformers Huggingface)</p> Source code in <code>lib/python/EasyDel/transform/llama.py</code> <pre><code>def llama_easydel_to_hf(path, config: LlamaConfig):\n    \"\"\"\n        Takes path to easydel saved ckpt and return the model in pytorch (Transformers Huggingface)\n    \"\"\"\n    torch_params = load_and_convert_checkpoint_to_torch(path)\n    edited_params = {}\n    for k, v in torch_params.items():\n        edited_params[k.replace('.kernel', '.weight').replace('.embedding', '.weight')] = v\n    model = LlamaForCausalLM(config=config)\n    model.load_state_dict(edited_params)\n    return model\n</code></pre>"},{"location":"generated-transform-llama/#lib.python.EasyDel.transform.llama.llama_from_pretrained","title":"<code>llama_from_pretrained(model_id, device)</code>","text":"<p>return: Weight or Params for EasyDel Model , Config</p> Source code in <code>lib/python/EasyDel/transform/llama.py</code> <pre><code>def llama_from_pretrained(model_id, device):\n    \"\"\"\n    return: Weight or Params for EasyDel Model , Config\n    \"\"\"\n    config = LlamaConfig.from_pretrained(model_id)\n    model = LlamaForCausalLM.from_pretrained(model_id)\n    easydel_wights = llama_convert_hf_to_flax(\n        state_dict=model.state_dict(),\n        config=config,\n        device=device\n    )\n    config.add_jax_args()\n\n    del model\n    gc.collect()\n    return easydel_wights, config\n</code></pre>"},{"location":"generated-transform-mistral/","title":"transform.mistral","text":""},{"location":"generated-transform-mistral/#lib.python.EasyDel.transform.mistral.mistral_easydel_to_hf","title":"<code>mistral_easydel_to_hf(path, config)</code>","text":"<p>Takes path to easydel saved ckpt and return the model in pytorch (Transformers Huggingface)</p> Source code in <code>lib/python/EasyDel/transform/mistral.py</code> <pre><code>def mistral_easydel_to_hf(path, config: MistralConfig):\n    \"\"\"\n    Takes path to easydel saved ckpt and return the model in pytorch (Transformers Huggingface)\n    \"\"\"\n    torch_params = load_and_convert_checkpoint_to_torch(path)\n    edited_params = {}\n    for k, v in torch_params.items():\n        edited_params[k.replace('.kernel', '.weight').replace('.embedding', '.weight')] = v\n    model = MistralForCausalLM(config=config)\n    model.load_state_dict(edited_params)\n    return model\n</code></pre>"},{"location":"generated-transform-mistral/#lib.python.EasyDel.transform.mistral.mistral_from_pretrained","title":"<code>mistral_from_pretrained(model_id, device)</code>","text":"<p>return: Weight or Params for EasyDel Model , Config</p> Source code in <code>lib/python/EasyDel/transform/mistral.py</code> <pre><code>def mistral_from_pretrained(model_id, device):\n    \"\"\"\n    return: Weight or Params for EasyDel Model , Config\n    \"\"\"\n    config = MistralConfig.from_pretrained(model_id)\n    model = MistralForCausalLM.from_pretrained(model_id)\n    easydel_wights = mistral_convert_hf_to_flax(\n        state_dict=model.state_dict(),\n        config=config,\n        device=device\n    )\n    config.add_jax_args()\n\n    del model\n    gc.collect()\n    return easydel_wights, config\n</code></pre>"},{"location":"generated-transform-mpt/","title":"transform.mpt","text":""},{"location":"generated-transform-mpt/#lib.python.EasyDel.transform.mpt.mpt_from_pretrained","title":"<code>mpt_from_pretrained(model_id, device, **kwargs)</code>","text":"<p>return: Weight or Params for EasyDel Model , Config</p> Source code in <code>lib/python/EasyDel/transform/mpt.py</code> <pre><code>def mpt_from_pretrained(model_id, device, **kwargs):\n    \"\"\"\n    return: Weight or Params for EasyDel Model , Config\n    \"\"\"\n    config = MptConfig.from_pretrained(model_id)\n    model = AutoModelForCausalLM.from_pretrained(model_id, trust_remote_code=True, **kwargs)\n\n    easydel_wights = mpt_convert_pt_to_flax_7b(\n        state_dict=model.state_dict(),\n        n_layers=config.num_hidden_layers if hasattr(config, 'num_hidden_layers') else config.n_layers,\n        device=device\n    )\n    config.add_jax_args()\n\n    del model\n    gc.collect()\n    return easydel_wights, config\n</code></pre>"},{"location":"generated-transform-utils/","title":"transform.utils","text":""},{"location":"generated-utils-checker/","title":"utils.checker","text":""},{"location":"generated-utils-prompters/","title":"utils.prompters","text":""},{"location":"generated-utils-prompters/#lib.python.EasyDel.utils.prompters.antitoxin_prompter","title":"<code>antitoxin_prompter(history, prompt, system=None)</code>","text":"<p>The antitoxin_prompter function takes in a history of user-assistant interactions, a prompt from the user, and optionally a system response. It returns an input string that can be fed into the antitoxin model to generate an assistant response.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>List[str]</code> <p>typing.List[str]: Pass in the history of the conversation</p> required <code>prompt</code> <code>str</code> <p>str: Pass the user's input to the assistant</p> required <code>system</code> <code>Optional[str]</code> <p>typing.Optional[str]: Pass the system's response to the prompt</p> <code>None</code> <code></code> <p>Store the history of user and assistant interaction</p> required <p>Returns:</p> Type Description <p>A string that contains the user's prompt,</p> Source code in <code>lib/python/EasyDel/utils/prompters.py</code> <pre><code>def antitoxin_prompter(\n        history: typing.List[str],\n        prompt: str,\n        system: typing.Optional[str] = None,\n):\n    \"\"\"\n    The antitoxin_prompter function takes in a history of user-assistant interactions,\n    a prompt from the user, and optionally a system response. It returns an input string\n    that can be fed into the antitoxin model to generate an assistant response.\n\n    :param history: typing.List[str]: Pass in the history of the conversation\n    :param prompt: str: Pass the user's input to the assistant\n    :param system: typing.Optional[str]: Pass the system's response to the prompt\n    :param : Store the history of user and assistant interaction\n    :return: A string that contains the user's prompt,\n\n    \"\"\"\n    sys_str = f\"&lt;|im_start|&gt;system\\n{system}&lt;|im_end|&gt;\\n\" if system is not None else \"\"\n    histories = \"\"\n    for user, assistance in history:\n        histories += f\"&lt;|im_start|&gt;user\\n{user}&lt;|im_end|&gt;\\n&lt;|im_start|&gt;assistant\\n{assistance}&lt;|im_end|&gt;\\n\"\n    text = f\"&lt;|im_start|&gt;user\\n{prompt}&lt;|im_end|&gt;\\n&lt;|im_start|&gt;assistant\\n\"\n    return sys_str + histories + text\n</code></pre>"},{"location":"generated-utils-prompters/#lib.python.EasyDel.utils.prompters.antitoxin_prompter_chat_format","title":"<code>antitoxin_prompter_chat_format(history, system=None)</code>","text":"<p>The antitoxin_prompter_chat_format function takes a list of strings and returns a string. The input is the history of the chat, which is a list of tuples where each tuple contains two strings: the user's message and the assistant's response. The output is formatted as follows:</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>List[str]</code> <p>typing.List[str]: Pass in the history of user and assistant messages</p> required <code>system</code> <code>Optional[str]</code> <p>typing.Optional[str]: Pass in the system message</p> <code>None</code> <code></code> <p>Store the history of the conversation</p> required <p>Returns:</p> Type Description <p>A string that contains the system message and</p> Source code in <code>lib/python/EasyDel/utils/prompters.py</code> <pre><code>def antitoxin_prompter_chat_format(\n        history: typing.List[str],\n        system: typing.Optional[str] = None,\n):\n    \"\"\"\n    The antitoxin_prompter_chat_format function takes a list of strings and returns a string.\n    The input is the history of the chat, which is a list of tuples where each tuple contains two strings:\n    the user's message and the assistant's response. The output is formatted as follows:\n\n    :param history: typing.List[str]: Pass in the history of user and assistant messages\n    :param system: typing.Optional[str]: Pass in the system message\n    :param : Store the history of the conversation\n    :return: A string that contains the system message and\n\n    \"\"\"\n    sys_str = f\"&lt;|im_start|&gt;system\\n{system}&lt;|im_end|&gt;\\n\" if system is not None else \"\"\n    histories = \"\"\n    for user, assistance in history:\n        histories += f\"&lt;|im_start|&gt;user\\n{user}&lt;|im_end|&gt;\\n&lt;|im_start|&gt;assistant\\n{assistance}&lt;|im_end|&gt;\\n\"\n    return sys_str + histories\n</code></pre>"},{"location":"generated-utils-prompters/#lib.python.EasyDel.utils.prompters.llama2_prompter","title":"<code>llama2_prompter(history, prompt, system=None)</code>","text":"<p>The llama2_prompter function takes a history of user-system interactions, a prompt for the next system response, and optionally a system response. It returns an LLAMA2 formatted string that can be used as input to the LLAMA2 model.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>List[str]</code> <p>typing.List[str]: Store the history of user input and system response</p> required <code>prompt</code> <code>str</code> <p>str: Specify the prompt to be displayed</p> required <code>system</code> <code>Optional[str]</code> <p>typing.Optional[str]: Indicate that the system is optional</p> <code>None</code> <code></code> <p>Specify the system's response</p> required <p>Returns:</p> Type Description <p>A string that is a concatenation of the</p> Source code in <code>lib/python/EasyDel/utils/prompters.py</code> <pre><code>def llama2_prompter(\n        history: typing.List[str],\n        prompt: str,\n        system: typing.Optional[str] = None,\n\n):\n    \"\"\"\n    The llama2_prompter function takes a history of user-system interactions,\n    a prompt for the next system response, and optionally a system response.\n    It returns an LLAMA2 formatted string that can be used as input to the LLAMA2 model.\n\n    :param history: typing.List[str]: Store the history of user input and system response\n    :param prompt: str: Specify the prompt to be displayed\n    :param system: typing.Optional[str]: Indicate that the system is optional\n    :param : Specify the system's response\n    :return: A string that is a concatenation of the\n\n    \"\"\"\n    do_strip = False\n    if system is not None:\n        texts = [f'&lt;s&gt;[INST] &lt;&lt;SYS&gt;&gt;\\n{system}\\n&lt;&lt;/SYS&gt;&gt;\\n\\n']\n    else:\n        texts = [f'&lt;s&gt;[INST] ']\n    for user_input, response in history:\n        user_input = user_input.strip() if do_strip else user_input\n        do_strip = True\n        texts.append(f'{user_input} [/INST] {response.strip()} &lt;/s&gt;&lt;s&gt;[INST] ')\n    prompt = prompt.strip() if do_strip else prompt\n    texts.append(f'{prompt} [/INST]')\n    return \"\".join(texts)\n</code></pre>"},{"location":"generated-utils-prompters/#lib.python.EasyDel.utils.prompters.llama2_prompter_chat_format","title":"<code>llama2_prompter_chat_format(system, messages)</code>","text":"<p>The llama2_prompter_chat_format function takes a system message and a list of messages, and returns the formatted string that can be used to create an LLAMA2 chat file. The system message is optional, and if it is not provided then the function will return only the user messages. The user messages are expected to be in pairs: one for each speaker (system or human).  The first element of each  pair should be the name of that speaker.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>str</code> <p>str: Store the system message</p> required <code>messages</code> <code>List[str]</code> <p>typing.List[str]: Pass in a list of strings</p> required <code></code> <p>Add the system message to the beginning of the chat</p> required <p>Returns:</p> Type Description <p>A string that is the</p> Source code in <code>lib/python/EasyDel/utils/prompters.py</code> <pre><code>def llama2_prompter_chat_format(\n        system: str,\n        messages: typing.List[str],\n):\n    \"\"\"\n    The llama2_prompter_chat_format function takes a system message and a list of messages,\n    and returns the formatted string that can be used to create an LLAMA2 chat file.\n    The system message is optional, and if it is not provided then the function will return only the user messages.\n    The user messages are expected to be in pairs: one for each speaker (system or human).  The first element of each\n     pair should be the name of that speaker.\n\n    :param system: str: Store the system message\n    :param messages: typing.List[str]: Pass in a list of strings\n    :param : Add the system message to the beginning of the chat\n    :return: A string that is the\n\n    \"\"\"\n    if system is not None:\n        string = [f'&lt;s&gt;[INST] &lt;&lt;SYS&gt;&gt;\\n{system}\\n&lt;&lt;/SYS&gt;&gt;\\n\\n']\n    else:\n        string = [f'&lt;s&gt;[INST] ']\n    for index in range(0, len(messages), 2):\n        string.append(\n            f'{messages[index]} [/INST] {messages[index + 1].strip()} &lt;/s&gt;&lt;s&gt;[INST] ')\n    return \"\".join(string).strip()\n</code></pre>"},{"location":"generated-utils-tensor_utils/","title":"utils.tensor_utils","text":""},{"location":"generated-utils-tensor_utils/#lib.python.EasyDel.utils.tensor_utils.np2jax","title":"<code>np2jax(array)</code>","text":"<p>Convert Numpy Array to JAX Array</p> Source code in <code>lib/python/EasyDel/utils/tensor_utils.py</code> <pre><code>def np2jax(array: np.array) -&gt; chex.Array:\n    \"\"\"\n        Convert Numpy Array to JAX Array\n        \"\"\"\n    return jnp.asarray(array)\n</code></pre>"},{"location":"generated-utils-tensor_utils/#lib.python.EasyDel.utils.tensor_utils.pt2jax","title":"<code>pt2jax(array)</code>","text":"<p>Convert Pytorch Array to JAX Array</p> Source code in <code>lib/python/EasyDel/utils/tensor_utils.py</code> <pre><code>def pt2jax(array: torch.Tensor) -&gt; chex.Array:\n    \"\"\"\n    Convert Pytorch Array to JAX Array\n    \"\"\"\n    return np2jax(pt2np(array))\n</code></pre>"},{"location":"generated-utils-tensor_utils/#lib.python.EasyDel.utils.tensor_utils.pt2np","title":"<code>pt2np(array)</code>","text":"<p>Convert Pytorch Array to Numpy Array</p> Source code in <code>lib/python/EasyDel/utils/tensor_utils.py</code> <pre><code>def pt2np(array: torch.Tensor) -&gt; np.array:\n    \"\"\"\n        Convert Pytorch Array to Numpy Array\n        \"\"\"\n    return array.detach().cpu().numpy()\n</code></pre>"},{"location":"generated-utils-utils/","title":"utils.utils","text":""},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timer","title":"<code>Timer</code>","text":"Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>class Timer:\n\n    def __init__(self, name):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the object with a name and initializes other variables.\n\n        :param self: Represent the instance of the class\n        :param name: Give the timer a name\n        :return: An instance of the class\n\n        \"\"\"\n        self.name_ = name\n        self.elapsed_ = 0.0\n        self.started_ = False\n        self.start_time = time.time()\n\n    def start(self):\n        \"\"\"\n        The start function starts the timer.\n                Args:\n                    None\n\n        :param self: Access the attributes and methods of the class in python\n        :return: Nothing\n\n        \"\"\"\n        assert not self.started_, \"timer has already been started\"\n        self.start_time = time.time()\n        self.started_ = True\n\n    def stop(self):\n        \"\"\"\n        The stop function stops the timer and adds the time elapsed since start was called to the total elapsed time.\n\n\n        :param self: Represent the instance of the class\n        :return: The time elapsed since the start function was called\n\n        \"\"\"\n        assert self.started_, \"timer is not started\"\n        self.elapsed_ += time.time() - self.start_time\n        self.started_ = False\n\n    def reset(self):\n        \"\"\"\n        The reset function sets the elapsed time to 0.0 and the started flag to False.\n\n        :param self: Represent the instance of the class\n        :return: True if the timer was running, false otherwise\n\n        \"\"\"\n        self.elapsed_ = 0.0\n        self.started_ = False\n\n    def elapsed(self, reset=True):\n        \"\"\"\n        The elapsed function returns the elapsed time in seconds since the timer was started.\n        If reset is True, then it also resets the timer to zero and restarts it.\n        If reset is False, then it leaves the timer running.\n\n        :param self: Represent the instance of the class\n        :param reset: Reset the timer\n        :return: The elapsed time in seconds\n\n        \"\"\"\n        started_ = self.started_\n        if self.started_:\n            self.stop()\n        elapsed_ = self.elapsed_\n        if reset:\n            self.reset()\n        if started_:\n            self.start()\n        return elapsed_\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timer.__init__","title":"<code>__init__(name)</code>","text":"<p>The init function is called when the class is instantiated. It sets up the object with a name and initializes other variables.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>name</code> <p>Give the timer a name</p> required <p>Returns:</p> Type Description <p>An instance of the class</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def __init__(self, name):\n    \"\"\"\n    The __init__ function is called when the class is instantiated.\n    It sets up the object with a name and initializes other variables.\n\n    :param self: Represent the instance of the class\n    :param name: Give the timer a name\n    :return: An instance of the class\n\n    \"\"\"\n    self.name_ = name\n    self.elapsed_ = 0.0\n    self.started_ = False\n    self.start_time = time.time()\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timer.elapsed","title":"<code>elapsed(reset=True)</code>","text":"<p>The elapsed function returns the elapsed time in seconds since the timer was started. If reset is True, then it also resets the timer to zero and restarts it. If reset is False, then it leaves the timer running.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>reset</code> <p>Reset the timer</p> <code>True</code> <p>Returns:</p> Type Description <p>The elapsed time in seconds</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def elapsed(self, reset=True):\n    \"\"\"\n    The elapsed function returns the elapsed time in seconds since the timer was started.\n    If reset is True, then it also resets the timer to zero and restarts it.\n    If reset is False, then it leaves the timer running.\n\n    :param self: Represent the instance of the class\n    :param reset: Reset the timer\n    :return: The elapsed time in seconds\n\n    \"\"\"\n    started_ = self.started_\n    if self.started_:\n        self.stop()\n    elapsed_ = self.elapsed_\n    if reset:\n        self.reset()\n    if started_:\n        self.start()\n    return elapsed_\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timer.reset","title":"<code>reset()</code>","text":"<p>The reset function sets the elapsed time to 0.0 and the started flag to False.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>True if the timer was running, false otherwise</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def reset(self):\n    \"\"\"\n    The reset function sets the elapsed time to 0.0 and the started flag to False.\n\n    :param self: Represent the instance of the class\n    :return: True if the timer was running, false otherwise\n\n    \"\"\"\n    self.elapsed_ = 0.0\n    self.started_ = False\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timer.start","title":"<code>start()</code>","text":"<p>The start function starts the timer.         Args:             None</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Access the attributes and methods of the class in python</p> required <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def start(self):\n    \"\"\"\n    The start function starts the timer.\n            Args:\n                None\n\n    :param self: Access the attributes and methods of the class in python\n    :return: Nothing\n\n    \"\"\"\n    assert not self.started_, \"timer has already been started\"\n    self.start_time = time.time()\n    self.started_ = True\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timer.stop","title":"<code>stop()</code>","text":"<p>The stop function stops the timer and adds the time elapsed since start was called to the total elapsed time.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <p>Returns:</p> Type Description <p>The time elapsed since the start function was called</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def stop(self):\n    \"\"\"\n    The stop function stops the timer and adds the time elapsed since start was called to the total elapsed time.\n\n\n    :param self: Represent the instance of the class\n    :return: The time elapsed since the start function was called\n\n    \"\"\"\n    assert self.started_, \"timer is not started\"\n    self.elapsed_ += time.time() - self.start_time\n    self.started_ = False\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timers","title":"<code>Timers</code>","text":"<p>Group of timers.</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>class Timers:\n    \"\"\"Group of timers.\"\"\"\n\n    def __init__(self, use_wandb, tensorboard_writer):\n        self.timers = {}\n        self.use_wandb = use_wandb\n        self.tensorboard_writer = tensorboard_writer\n\n    def __call__(self, name):\n        if name not in self.timers:\n            self.timers[name] = Timer(name)\n        return self.timers[name]\n\n    def write(self, names, iteration, normalizer=1.0, reset=False):\n\n        \"\"\"\n        The write function is used to write the elapsed time of a timer to Tensorboard and/or Weights &amp;amp; Biases.\n\n        :param self: Make the function a method of the class\n        :param names: Specify which timer(s) to write\n        :param iteration: Keep track of the number of iterations\n        :param normalizer: Normalize the time elapsed by a certain value\n        :param reset: Reset the timer after it has been written to tensorboard\n        :return: Nothing\n\n        \"\"\"\n        assert normalizer &gt; 0.0\n        for name in names:\n            value = self.timers[name].elapsed(reset=reset) / normalizer\n\n            if self.tensorboard_writer:\n                self.tensorboard_writer.add_scalar(f\"timers/{name}\", value, iteration)\n\n            if self.use_wandb:\n                wandb.log({f\"timers/{name}\": value}, step=iteration)\n\n    def log(self, names, normalizer=1.0, reset=True):\n        \"\"\"\n        The log function is used to print the time elapsed for a given function.\n\n        :param self: Represent the instance of the class\n        :param names: Specify the name of the timer that we want to log\n        :param normalizer: Normalize the time taken to run a function\n        :param reset: Reset the timer after logging\n        :return: The time taken for the given name\n\n        \"\"\"\n        assert normalizer &gt; 0.0\n\n        if isinstance(names, str):\n            names = [names]\n        for name in names:\n            elapsed_time = self.timers[name].elapsed(reset=reset) * 1000.0 / normalizer\n            termcolor.cprint(\n                f\"Time Took to Complete Task {name} (microseconds) : \"\n                f\"{termcolor.colored(elapsed_time, color='white', force_color=True)}\",\n                color=\"cyan\",\n                force_color=True\n            )\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timers.log","title":"<code>log(names, normalizer=1.0, reset=True)</code>","text":"<p>The log function is used to print the time elapsed for a given function.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Represent the instance of the class</p> required <code>names</code> <p>Specify the name of the timer that we want to log</p> required <code>normalizer</code> <p>Normalize the time taken to run a function</p> <code>1.0</code> <code>reset</code> <p>Reset the timer after logging</p> <code>True</code> <p>Returns:</p> Type Description <p>The time taken for the given name</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def log(self, names, normalizer=1.0, reset=True):\n    \"\"\"\n    The log function is used to print the time elapsed for a given function.\n\n    :param self: Represent the instance of the class\n    :param names: Specify the name of the timer that we want to log\n    :param normalizer: Normalize the time taken to run a function\n    :param reset: Reset the timer after logging\n    :return: The time taken for the given name\n\n    \"\"\"\n    assert normalizer &gt; 0.0\n\n    if isinstance(names, str):\n        names = [names]\n    for name in names:\n        elapsed_time = self.timers[name].elapsed(reset=reset) * 1000.0 / normalizer\n        termcolor.cprint(\n            f\"Time Took to Complete Task {name} (microseconds) : \"\n            f\"{termcolor.colored(elapsed_time, color='white', force_color=True)}\",\n            color=\"cyan\",\n            force_color=True\n        )\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.Timers.write","title":"<code>write(names, iteration, normalizer=1.0, reset=False)</code>","text":"<p>The write function is used to write the elapsed time of a timer to Tensorboard and/or Weights &amp; Biases.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Make the function a method of the class</p> required <code>names</code> <p>Specify which timer(s) to write</p> required <code>iteration</code> <p>Keep track of the number of iterations</p> required <code>normalizer</code> <p>Normalize the time elapsed by a certain value</p> <code>1.0</code> <code>reset</code> <p>Reset the timer after it has been written to tensorboard</p> <code>False</code> <p>Returns:</p> Type Description <p>Nothing</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def write(self, names, iteration, normalizer=1.0, reset=False):\n\n    \"\"\"\n    The write function is used to write the elapsed time of a timer to Tensorboard and/or Weights &amp;amp; Biases.\n\n    :param self: Make the function a method of the class\n    :param names: Specify which timer(s) to write\n    :param iteration: Keep track of the number of iterations\n    :param normalizer: Normalize the time elapsed by a certain value\n    :param reset: Reset the timer after it has been written to tensorboard\n    :return: Nothing\n\n    \"\"\"\n    assert normalizer &gt; 0.0\n    for name in names:\n        value = self.timers[name].elapsed(reset=reset) / normalizer\n\n        if self.tensorboard_writer:\n            self.tensorboard_writer.add_scalar(f\"timers/{name}\", value, iteration)\n\n        if self.use_wandb:\n            wandb.log({f\"timers/{name}\": value}, step=iteration)\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.get_mesh","title":"<code>get_mesh(shape=(1, -1, 1, 1), axis_names=('dp', 'fsdp', 'tp', 'sp'))</code>","text":"<p>The get_mesh function is a helper function that creates a JAX Mesh object.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Sequence[int]</code> <p>typing.Sequence[int]: Specify the shape of the array that is used to create the mesh</p> <code>(1, -1, 1, 1)</code> <code>axis_names</code> <code>Sequence[str]</code> <p>typing.Sequence[int]: Specify the Axis Names in mesh</p> <code>('dp', 'fsdp', 'tp', 'sp')</code> <p>Returns:</p> Type Description <p>A mesh object</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def get_mesh(\n        shape: typing.Sequence[int] = (1, -1, 1, 1),\n        axis_names: typing.Sequence[str] = (\"dp\", \"fsdp\", \"tp\", \"sp\")\n):\n    \"\"\"\n    The get_mesh function is a helper function that creates a JAX Mesh object.\n\n    :param shape: typing.Sequence[int]: Specify the shape of the array that is used to create the mesh\n    :param axis_names: typing.Sequence[int]: Specify the Axis Names in mesh\n    :return: A mesh object\n\n    \"\"\"\n    from jax.sharding import Mesh\n    from jax.experimental import mesh_utils\n    array = jnp.ones((len(jax.devices()), 1)).reshape(shape)\n    return Mesh(mesh_utils.create_device_mesh(array.shape), axis_names)\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.get_names_from_partition_spec","title":"<code>get_names_from_partition_spec(partition_specs)</code>","text":"<p>The get_names_from_partition_spec function takes a partition_specs argument, which is either a dictionary or list. If it's a dictionary, the function converts it to a list of values. Then for each item in the partition_specs list:     If the item is None, continue (do nothing) and move on to next iteration of loop.     If the item is an instance of str (i.e., if it's just one string), add that string to names set and move on      to next iteration of loop.     Otherwise, (if not None or str), call get_names_from_partition_spec recurs</p> <p>Parameters:</p> Name Type Description Default <code>partition_specs</code> <p>Specify the partitioning of a table</p> required <p>Returns:</p> Type Description <p>A list of names from a partition spec</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def get_names_from_partition_spec(partition_specs):\n    \"\"\"\n    The get_names_from_partition_spec function takes a partition_specs argument, which is either a dictionary or list.\n    If it's a dictionary, the function converts it to a list of values. Then for each item in the partition_specs list:\n        If the item is None, continue (do nothing) and move on to next iteration of loop.\n        If the item is an instance of str (i.e., if it's just one string), add that string to names set and move on \n        to next iteration of loop.\n        Otherwise, (if not None or str), call get_names_from_partition_spec recurs\n\n    :param partition_specs: Specify the partitioning of a table\n    :return: A list of names from a partition spec\n\n    \"\"\"\n    names = set()\n    if isinstance(partition_specs, dict):\n        partition_specs = partition_specs.values()\n    for item in partition_specs:\n        if item is None:\n            continue\n        elif isinstance(item, str):\n            names.add(item)\n        else:\n            names.update(get_names_from_partition_spec(item))\n\n    return list(names)\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.make_shard_and_gather_fns","title":"<code>make_shard_and_gather_fns(partition_specs, dtype_specs=None)</code>","text":"<p>The make_shard_and_gather_fns function takes in a partition_specs and dtype_specs, and returns two functions: shard_fns and gather_fns. The shard function is used to shard the input tensor into the specified partitions, while the gather function is used to gather all of those shards back together. This allows us to use different data types for each partition (e.g., float16 for weights, float32 for activations)</p> <p>Parameters:</p> Name Type Description Default <code>partition_specs</code> <p>Specify the partitioning of each tensor in the model</p> required <code>dtype_specs</code> <p>Specify the dtype of the tensor</p> <code>None</code> <p>Returns:</p> Type Description <p>A tuple of two functions:</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def make_shard_and_gather_fns(partition_specs, dtype_specs=None):\n    \"\"\"\n    The make_shard_and_gather_fns function takes in a partition_specs and dtype_specs,\n    and returns two functions: shard_fns and gather_fns. The shard function is used to\n    shard the input tensor into the specified partitions, while the gather function is used to\n    gather all of those shards back together. This allows us to use different data types for each\n    partition (e.g., float16 for weights, float32 for activations)\n\n    :param partition_specs: Specify the partitioning of each tensor in the model\n    :param dtype_specs: Specify the dtype of the tensor\n    :return: A tuple of two functions:\n\n    \"\"\"\n    float_dtypes = (jnp.bfloat16, jnp.float16, jnp.float32, jnp.float64)\n\n    def make_to_dtype_fn(dtype_spec):\n        def to_dtype(tensor):\n            if dtype_specs in float_dtypes and getattr(tensor, \"dtype\", None) in float_dtypes:\n                return tensor.astype(dtype_specs)\n            elif hasattr(dtype_spec, \"dtype\") and hasattr(tensor, \"dtype\"):\n                return tensor.astype(dtype_spec.dtype)\n            return tensor\n\n        return to_dtype\n\n    def make_shard_fn(partition_spec, dtype_spec=None):\n        jax_shard_function = pjit(\n            make_to_dtype_fn(dtype_spec),\n            in_shardings=None,\n            out_shardings=partition_spec\n        )\n\n        def shard_fn(tensor):\n            return jax_shard_function(tensor).block_until_ready()\n\n        return shard_fn\n\n    def make_gather_fn(partition_spec, dtype_spec=None):\n        jax_gather_fn = pjit(\n            make_to_dtype_fn(dtype_spec),\n            in_shardings=partition_spec,\n            out_shardings=None\n        )\n\n        def gather_fn(tensor):\n            return jax.device_get(jax_gather_fn(tensor))\n\n        return gather_fn\n\n    if dtype_specs is None or dtype_specs in float_dtypes:\n        shard_fns = jax.tree_util.tree_map(make_shard_fn, partition_specs)\n        gather_fns = jax.tree_util.tree_map(make_gather_fn, partition_specs)\n    else:\n        shard_fns = jax.tree_util.tree_map(\n            make_shard_fn, partition_specs, dtype_specs\n        )\n        gather_fns = jax.tree_util.tree_map(\n            make_gather_fn, partition_specs, dtype_specs\n        )\n    return shard_fns, gather_fns\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.names_in_mesh","title":"<code>names_in_mesh(*names)</code>","text":"<p>The names_in_mesh function is a decorator that can be used to check whether the names of the axes passed into a function are valid.  It will raise an exception if any of the axis names are not in the physical mesh.  For example, if you have a function that takes two axes as arguments, and you want to make sure they're both in your mesh:</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <p>Pass in a variable number of arguments</p> <code>()</code> <p>Returns:</p> Type Description <p>A boolean indicating whether all of the given names are in the physical mesh</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def names_in_mesh(*names):\n    \"\"\"\n    The names_in_mesh function is a decorator that can be used to check whether\n    the names of the axes passed into a function are valid.  It will raise an\n    exception if any of the axis names are not in the physical mesh.  For example,\n    if you have a function that takes two axes as arguments, and you want to make sure they're both in your mesh:\n\n    :param *names: Pass in a variable number of arguments\n    :return: A boolean indicating whether all of the given names are in the physical mesh\n\n    \"\"\"\n    return set(names) &lt;= set(pxla.thread_resources.env.physical_mesh.axis_names)\n</code></pre>"},{"location":"generated-utils-utils/#lib.python.EasyDel.utils.utils.with_sharding_constraint","title":"<code>with_sharding_constraint(x, partition_specs)</code>","text":"<p>The with_sharding_constraint function is used to ensure that the sharding of a tensor is consistent with the sharding of its inputs.  This function should be called on any tensor which has been created by an operation which does not automatically handle this, such as tf.concat or tf.split.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <p>Pass in the tensor that is to be sharded</p> required <code>partition_specs</code> <p>Specify the axis names and partition sizes</p> required <p>Returns:</p> Type Description <p>The same value as the original function</p> Source code in <code>lib/python/EasyDel/utils/utils.py</code> <pre><code>def with_sharding_constraint(x, partition_specs):\n    \"\"\"\n    The with_sharding_constraint function is used to ensure that the sharding of a tensor\n    is consistent with the sharding of its inputs.  This function should be called on any\n    tensor which has been created by an operation which does not automatically handle this,\n    such as tf.concat or tf.split.\n\n    :param x: Pass in the tensor that is to be sharded\n    :param partition_specs: Specify the axis names and partition sizes\n    :return: The same value as the original function\n\n    \"\"\"\n    axis_names = get_names_from_partition_spec(partition_specs)\n    if names_in_mesh(*axis_names):\n        x = wsc(x, partition_specs)\n    return x\n</code></pre>"}]}